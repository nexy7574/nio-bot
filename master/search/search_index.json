{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Welcome to the Nio-Bot Documentation</p>"},{"location":"#what-is-niobot","title":"What is NioBot?","text":"<p>NioBot (&amp; nio-bot) is a framework built upon the matrix-nio client library, built with the creation of bots in mind. NioBot provides a simple and intuitive way to build bots for the Matrix framework by simplifying a lot of the mundane tasks that come with building a bot.</p> <p>By making use of <code>nio</code>, you can access the full power of the Matrix protocol, while still being able to build a bot using <code>nio-bot</code> with ease.</p> Why NioBot, and not just regular nio? <p>Take for example, the following code:</p> <pre><code>from niobot import NioBot, Context\n\n\nbot = NioBot(\n    homeserver=\"https://matrix-client.matrix.org\",\n    user_id=\"@my_user:matrix.org\",\n    command_prefix=\"!\"\n)\n\n@bot.command(\"ping\")\nasync def ping_command(ctx: Context):\n    \"\"\"Checks if the bot is online &amp; responding.\"\"\"\n    await ctx.respond(\"Pong!\")\n\n\nbot.run(access_token=\"abc123\")\n</code></pre> <p>This is an incredibly simple working example of a bot that responds to the command <code>!ping</code> with <code>Pong!</code>. You simply run this with <code>python3 bot.py</code>, and you're away!</p> <p>Here's the same code (not fully, there are a LOT of behind the scenes in niobot) in base <code>nio</code>:</p> <pre><code>import asyncio\nfrom nio import AsyncClient, MatrixRoom, RoomMessage\n\n\nclient = AsyncClient(\"https://matrix-client.matrix.org\", \"@my_user:matrix.org\")\n\n\nasync def ping_command(room: MatrixRoom, event: RoomMessage):\n    if event.sender == client.user_id:\n        return\n    body = event.body\n    if event.body.startswith(\"!\"):\n        if event.body.split()[0][1:].lower() == \"ping\":\n            await client.room_send(\n                room.room_id,\n                \"m.room.message\",\n                {\n                    \"msgtype\": \"m.notice\",\n                    \"body\": \"Pong!\",\n                    \"m.relates_to\": {\n                        \"m.in_reply_to\": {\n                            \"event_id\": event.event_id\n                        }\n                    }\n                }\n            )\n\n\nclient.add_event_callback(ping_command, (RoomMessage,))\nclient.access_token = \"abc123\"\n\nasyncio.run(client.sync_forever())\n</code></pre> <p>At first, it doesn't look too difficult right? But, as you start to add more commands, or add more functionality, you'll end up building up more and more boilerplate, and it can get quite messy quite quickly.</p> <p>This is where <code>nio-bot</code> comes in. By abstracting away a lot of the nuanced functionality in favour of a simplified interface, so that you can focus on building meaningful code, rather than annoying boilerplate.</p>"},{"location":"#features","title":"Features","text":"<p>NioBot contains all of the features of matrix-nio, plus a few more:</p> <ul> <li>Integrated command system: Easily create commands with a decorater and function. That's all you need.</li> <li>Powerful context: Access all of the metadata you need about a command with the <code>[niobot.Context][]</code> object, given to every command.</li> <li>Robust error handling: Your bot won't crash as soon as an error occurs. Instead, it will be passed on to a handler, and the bot will continue running.</li> <li>Simple configuration: Pass in a few parameters to <code>[niobot.NioBot][]</code>, and you're ready to go.</li> <li>Automatic Markdown + HTML rendering: Send messages in markdown or HTML, and NioBot will automatically render them for you.</li> <li>Easy events: Listening for events in NioBot is incredibly similar to listening for commands, and is just as easy.</li> </ul> NioBot does not make an effort to support end-to-end encryption <p>While NioBot does support end-to-end encryption, it does not make an effort to support it. Making end-to-end encryption work in a headless fashion is incredibly difficult, and while it does work, users have reported that E2EE is unreliable and can unexpectedly break at any time, and is hard to debug.</p> <p>We do not recommend that you expect E2EE to work when building a bot with NioBot. If it works, that's great! If not, we cannot help.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install NioBot from PyPi:</p> <pre><code>pip install nio-bot\n# Or, get the latest pre-release\npip install --pre nio-bot\n</code></pre> <p>or straight from git:</p> <pre><code>pip install git+https://github.com/nexy7574/nio-bot.git\n</code></pre>"},{"location":"#contact","title":"Contact","text":"<p>See the Matrix room for help, or open a GitHub issue for bugs or feature requests.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"These changes are not in a stable release. <p>You can only get these changes by installing the library from GitHub. This is not recommended in production, as these changes are often not properly battle-tested.</p> <p>However, if you encounter an issue with these changes, you should open an issue on GitHub so that we can release them sooner!</p> <p>Potentially breaking changes since the last release</p> <p>The following changes may be potentially breaking if you use some lower-level features of the library:</p> <ul> <li>Attachments have been massively reworked, please check your code to see if there are any intellisense errors, or if you are using any of the removed methods.</li> <li>Argument detection has been massively reworked - while it should be a massive improvement, please check to make sure your arguments are still parsed as expected.</li> <li>The sync store has been completely rewritten - any code previously using helper functions will likely break.</li> </ul> <ul> <li>Added the sync filter \"lazy load members\" - should hopefully improve performance in large rooms.</li> <li>Removed temporary lock on <code>niobot.NioBot.process_message</code>, which should allow parallel command execution again.</li> <li>Removed faulty fallback reply parser, it is no-longer needed. Clients should not be sending fallback replies anymore.</li> <li>Overhauled argument parsing</li> <li><code>*args</code> no longer works - please use <code>list[str]</code> (<code>typing.List[str]</code> on python 3.9) instead.</li> <li>Arguments are no-longer given <code>None</code> (I am not sure what even caused this, but it's fixed now)</li> <li>Greedy arguments are now correctly greedy.</li> <li>Extra arguments passed to commands once again correctly raise an error.</li> <li>Added support for <code>list[TYPE]</code></li> <li>Added python 3.13 to the CI matrix</li> <li>Updated the pre-commit hooks (they were ANCIENT)</li> <li>Set <code>__license__</code> in <code>__init__.py</code> to <code>LGPLv3</code> (it was previously still <code>GPLv3</code>)</li> <li>Completely overhauled how attachments are handled</li> <li>the monolithic <code>niobot.attachments</code> module has been split into its own package</li> <li><code>detect_mime_type</code> no-longer requires <code>magic</code> to be installed (but still REALLY prefers it, and will be noisy if it's not)</li> <li><code>niobot.AudioAttachment</code> is now located in <code>niobot/attachments/audio.py</code></li> <li><code>niobot.VideoAttachment</code> is now located in <code>niobot/attachments/video.py</code></li> <li><code>niobot.ImageAttachment</code> is now located in <code>niobot/attachments/image.py</code></li> <li><code>niobot.FileAttachment</code> is now located in <code>niobot/attachments/file.py</code></li> <li>The extensible <code>niobot.BaseAttachment</code> is now located in <code>niobot/attachments/base.py</code></li> <li>Added task names to the asyncio background tasks for commands dispatched by the bot using the format: <code>COMMAND_{event.sender}_{room.room_id}_{command.name}_{monotonic_nanoseconds}</code>. This allows you to see what tasks are running by calling <code>asyncio.all_tasks()</code>, and means you can precisely cancel running commands.</li> <li>Fixed [niobot.NioBot.add_event_listener][] not accepting <code>nio.Event</code> types, again.</li> <li>Fixed niobot.NioBot.remove_event_listener not accepting <code>nio.Event</code> types.</li> <li>Added niobot.NioBot.wait_for_event, a generic evolution of niobot.NioBot.wait_for_message.</li> <li>Removed <code>niobot.NioBot._recursively_upload_attachments</code>, attachments should now properly be uploaded by the <code>send_message</code> function.</li> <li>Remove the archaic deprecated behaviour that permitted non-niobot.Parser objects to be used as parsers in commands.</li> <li>As mentioned above, overhauled argument parsing, in the process making [niobot.Argument.autodetect_args][] less complex and more reliable.</li> <li>Fixed <code>repr(ContextualResponse)</code> raising an AttributeError</li> <li>Fixed niobot.ContextualResponse being broken after niobot.ContextualResponse.edit was called.</li> <li>Added <code>NIOBOT_DEPRECATION_ERROR</code> environment variable, which when set, causes deprecation warnings to become errors instead. Intended for CI testing, but useful for local development too.</li> <li>Fixed niobot.NioBot.get_account_data and niobot.NioBot.set_account_data not working   (#40)</li> <li>Added <code>process_message_edits</code> argument to niobot.NioBot, enabled by default, which will treat edited messages as   new messages when checking for commands (meaning editing a message to invoke a command will invoke that command).</li> <li>Added niobot.SimpleNioBot as a simplified version of niobot.NioBot.</li> <li>Fixed a bug that caused thumbnail bodies to duplicate</li> <li>Removed the storage of left rooms in the sync store (has DRASTICALLY sped up startup times)</li> <li>Duplicate events (compared via event ID and body) are no longer added to the sync store (reducing space taken)</li> <li>Limited the number of timeline events that are stored in the sync store</li> <li>Added SQL indexes for the sync store</li> <li>Limited the sync payload to only include 100 timeline &amp; state events per room</li> <li>Implemented niobot.NioBot.global_command_check to allow for global command checks</li> <li>Added niobot.utils.HTMLTable to help with generating tables in HTML and plaintext</li> <li>Fixed incremental syncs having a hard timeout of 30 seconds, disrespecting the configured timeout</li> <li>Fixed filter uploads on startup not being fatal (later causing an exception)</li> <li>Fixed file uploads not respecting room encryption</li> <li>Fixed command argument detection not working with py 3.10 type syntaxes, and greedy not being detected correctly</li> <li>Removed python 3.9 from the testing matrix (and consequently support)</li> <li>Rewrote the sync store to actually store state rather than just sync payloads</li> </ul>"},{"location":"changelog/#v120","title":"v1.2.0","text":"<p>There are a lot of changes in v1.2.0, so in this release you'll see a lot of performance improvements and some fancy new features for you to take advantage of!</p> <p>Major update</p> <p>This release has had a lot of changes in it since v1.1.0, so please make sure you test your bot when updating to make sure that everything still works. If you encounter an error you believe is due to broken backwards compatiblity, please open an issue on GitHub so that we can patch it.</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Allowed <code>command_prefix</code> to be an iterable, converting single-strings into a single-item iterable too.</li> <li>Added beautifulsoup4 as a hard dependency. Backwards compatibility is still kept in case bs4 is not installed.</li> <li>Added support for passing raw <code>nio.Event</code> types to event listeners</li> <li>Added proper support for <code>typing.Optional</code> in automatic argument detection</li> <li>Added support for <code>*args</code> in automatic argument detection</li> <li>Added <code>niobot.utils.Mentions</code> to handle intentional mentions in messages</li> <li>Added <code>Command.can_run(ctx)</code>, which runs through and makes sure that all of the command checks pass.</li> <li>Added backwards compatibility support for legacy media endpoints (servers that don't support matrix v1.11 yet). Authenticated media will still be used by default.</li> <li>Python 3.13 is now supported</li> <li>niobot attachment types now support os.PathLike, as well as str, BytesIO, and Pathlib, in case you had some freaky custom path type</li> <li><code>niobot.NioBot</code> now allows you to pass a static presence (<code>online</code>, <code>unavailable</code>, <code>offline</code>), <code>False</code> to outright disable presence, and <code>None</code> (default) to set it automatically based on the startup stage (recommended for slower connections)</li> <li>You can now, if you needed to for some reason, disable full state sync via <code>sync_full_state=False</code>.</li> <li>Added the <code>reason</code> parameter to <code>niobot.NioBot.join</code> and <code>niobot.NioBot.room_leave</code> as optional strings</li> <li>NioBot's auto-join feature now includes a reason when automatically joining rooms</li> <li>Added <code>force_initial_sync</code> to <code>niobot.NioBot</code>, which will force the bot to sync all rooms before starting the event loop.</li> <li>Added a real sync store (huge optimisation, especially for larger accounts)</li> </ul>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Changed the event type of the <code>message</code> event to be any nio.RoomMessage, not just <code>Text</code>.</li> <li>Merged <code>xyzamorganblurhash</code> into <code>ImageAttachment</code></li> <li>(Typing) send_message can now reply to any RoomMessage, not just RoomMessageText.</li> <li>niobot.NioBot.start will now query <code>/_matrix/client/versions</code> to fetch server version metadata.</li> <li>Updated the documentation index page and added documentation for Mentions</li> <li>Unified all of the help functions into a single class, <code>niobot.utils.help_command.DefaultHelpCommand</code>, to make subclassing easier.</li> <li><code>default_help_command</code> was replaced with <code>DefaultHelpCommand().respond</code>.</li> <li>Help command will no longer display commands in the command list that the current user cannot run</li> <li><code>niobot.NioBot.send_message</code> will now automatically parse mentions if not explicitly provided, to take full advantage of intentional mentions.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed <code>force_write</code> properly</li> <li>Removed deprecated <code>automatic_markdown_parser</code> option and functionality in NioBot</li> <li>Removed the deprecated <code>name</code> parameter from niobot checks</li> <li><code>niobot.util.help_command.help_command_callback</code> was removed, in line with deprecation.</li> <li>Removed the password login critical log in favour of simply documenting the dangers of using a password</li> <li>Removed fallback replies in messages (see: MSC2781)</li> <li>Removed the legacy function-based argument parsers in favour of the class-based system</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug fixes","text":"<ul> <li>Fix <code>&lt;instance&gt; has no attribute 'mro'</code> error when initialising auto-detected arguments</li> <li>Fixed <code>niocli get-access-token</code> crashing on windows</li> <li>Fixed <code>NioBot</code> throwing a warning about failing key uploads without logging the actual error</li> <li>Fixed <code>niobot.utils.parsers.EventParser</code> raising an error when used</li> <li>Fixed some typing dotted around the client</li> <li>Fixed niobot attachments (Image/Video/Audio) sending <code>null</code> for metadata, which may cause incorrect client behaviours</li> <li>Fix RuntimeError due to concurrent typing in send_message</li> <li>Fixed the versioned docs deployment</li> <li>Overlapping typing events in anything using room_send (e.g. send_message, edit_message) will no-longer throw an error if there is a mid-air collision. Instead, a warning will be logged to the stream, and the operation will be a no-op. This may cause some inconsistencies in the typing indicators sent by nio-bot, however that is preferrable to errors.</li> <li>Fixed <code>niobot.NioBot.join</code> throwing a JSON EOF in some cases</li> <li>Fixed module event handlers, in debug logs, being named as anonymous functions, rather than their true names. This will make debugging issues with your event handlers easier.</li> <li>DM rooms are now removed properly from account data when leaving.</li> <li>Fixed niobot.NioBot.on_event not properly accepting raw nio.Event types</li> <li>Fixed some faulty sync responses triggering commands twice</li> <li>Fixed a bug in the default help command that would display hidden commands regardless.</li> </ul>"},{"location":"changelog/#v111-2024-06-26","title":"v1.1.1 (2024-06-26)","text":"<ul> <li>Heavy CI improvements (2024-05-08 -&gt; 2024-06-15)</li> <li>Deprecated unimplemented <code>force_write</code> parameter in some <code>BaseAttachment</code> (and subclass) methods. (2024-06-15)</li> </ul>"},{"location":"changelog/#v110post3-2024-04-16","title":"v1.1.0.post3 (2024-04-16)","text":""},{"location":"changelog/#new-features","title":"New features","text":"<ul> <li>Added <code>CHANGELOG.md</code> (and consequently, this page) to documentation. (2024-02-08)</li> <li><code>NioBot._get_id</code> now tells you what object it couldn't identify in the raised exception. (2024-02-11)</li> <li><code>NioBot.mount_module</code> now warns you if you define a custom <code>setup()</code> that doesn't update the command or event register. (2024-02-11)</li> </ul>"},{"location":"changelog/#v110post2-2024-02-08","title":"v1.1.0.post2 (2024-02-08)","text":""},{"location":"changelog/#new-features_1","title":"New features","text":"<ul> <li>Added <code>auto_read_messages</code> key word argument to <code>NioBot</code> to automatically read messages from rooms. Defaults to <code>True</code>. Disabling this (<code>False</code>) will prevent read reciepts from automatically being sent.</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug fixes","text":"<ul> <li>Fixed <code>NioBot.get_dm_rooms</code> raising a 401 Unauthorised error regardless of any state.</li> <li>Fixed <code>NioBot.get_dm_rooms</code> raising a <code>GenericMatrixError</code> whenever there were no DM rooms, instead of gracefully returning an empty object.</li> <li>Fixed <code>NioBot.get_dm_rooms</code> using outdated code from before <code>matrix-nio==0.24.0</code>.</li> </ul>"},{"location":"changelog/#v110-2024-01-30","title":"v1.1.0 (2024-01-30)","text":"<p>The license changed in this release.</p> <p>With release v1.1.0 (specifically commit 421414d), the license for nio-bot was changed from GPLv3 to LGPLv3. In short, this means you do not have to open source your code, and you are able to commercialise your project if you use nio-bot.</p> This version's changelog includes changes made in its pre-release versions <p>This changelog includes all changes made since the last stable release, including those made in pre-release versions. If you scroll down, you will see duplicate feature changelogs where the feature was changed in a pre-release version.</p>"},{"location":"changelog/#new-features_2","title":"New features","text":"<ul> <li>Added <code>niobot.Context.invoking_prefix</code>.</li> <li>Python 3.12 is now supported.</li> <li>Added <code>niobot.NioBot.is_ready</code>, which is an <code>asyncio.Event</code>.</li> <li>Added command-level checks (<code>@niobot.check</code>)</li> <li>Added sparse DM room support.</li> <li>Added additional exception types, such as <code>GenericMatrixError</code>.</li> <li>Additional type-hinting for the entire library.</li> </ul>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>License changed from <code>GPLv3</code> to <code>LGPLv3</code>.</li> <li>Improved existing type-hinting.</li> <li><code>event_id</code> is prioritised over <code>room_id</code> in <code>niobot.NioBot._get_id</code>.</li> <li><code>niobot</code> was changed to <code>nio-bot</code> (for consistency) throughout documentation and the pip installation guide.</li> </ul>"},{"location":"changelog/#v110b1post1-and-v110b1-2023-10-16","title":"v1.1.0b1.post1 (and v1.1.0b1) (2023-10-16)","text":""},{"location":"changelog/#new-features_3","title":"New features","text":"<ul> <li>Added CI testing to the library.</li> <li>Rewrote argument parsers to use a class-based ABC system, rather than a function-based system. See documentation.</li> <li>Added the <code>ignore_self</code> flag to <code>niobot.NioBot</code>, allowing you to choose whether the client will ignore its own messages.</li> <li>Added support for <code>typing.Annotated</code> in commands.</li> </ul>"},{"location":"changelog/#deprecations-removals","title":"Deprecations &amp; Removals","text":"<ul> <li>The property <code>niobot.Module.log</code> was fully removed - it was never fully functional and often tripped up users as it was unsettable.</li> <li>The property <code>niobot.Module.client</code> was deprecated - you should use <code>niobot.Module.client</code> instead.</li> </ul>"},{"location":"changelog/#v110a3-2023-10-06","title":"v1.1.0a3 (2023-10-06)","text":""},{"location":"changelog/#changes_2","title":"Changes","text":"<ul> <li>Prioritise <code>event_id</code> over <code>room_id</code> for the <code>_get_id</code> function</li> <li>Add <code>Context.invoking_prefix</code></li> <li>Type hinting and code refactor</li> </ul>"},{"location":"changelog/#v110a2-2023-08-21","title":"v1.1.0a2 (2023-08-21)","text":""},{"location":"changelog/#new-features_4","title":"New features","text":"<ul> <li>Backported support to Python 3.9 and Python 3.10.</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>Fixed a bug where disabled commands could crash the command parser.</li> </ul>"},{"location":"changelog/#documentation-changes","title":"Documentation changes","text":"<ul> <li>Replaced <code>niobot</code> with <code>nio-bot</code> for pip install guide.</li> <li>Fixed PyPi link in README.</li> <li>Cleaned up documentation issues.</li> <li>Removed the examples on GitHub (until the package is more stable in terms of design).</li> </ul>"},{"location":"changelog/#v110a1-2023-07-31","title":"v1.1.0a1 (2023-07-31)","text":""},{"location":"changelog/#new-features_5","title":"New features","text":"<ul> <li>Added documentation for events.</li> <li>Added <code>niobot.attachments.which</code> function.</li> <li>Added very early DM room support.</li> <li>Added easier ways to customise the help command.</li> <li>Added more specific exception types.</li> <li>Added <code>event_parser</code> and <code>room_parser</code></li> </ul>"},{"location":"changelog/#changes_3","title":"Changes","text":"<ul> <li><code>force_await</code> now just awaits coroutines rather than casting them to a task</li> <li>Command arguments now properly raise the correct errors</li> </ul>"},{"location":"changelog/#v102-2023-07-16","title":"v1.0.2 (2023-07-16)","text":"<p>This is an urgent security release - denial of service vulnerability.</p> <p>This release fixes a vulnerability where a potentially accidentally crafted message payload could cause the bot to completely crash. If you had disabled ignoring old messages, this could cause a crash loop if your bot automatically restarted.</p> <p>If you cannot update to v1.0.2 from a previous release, you should implement the following workaround:</p> <pre><code>import niobot\n\n\nclass PatchedClient(niobot.NioBot):\n    async def process_message(self, *args):\n        try:\n            await super().process_message(*args)\n        except IndexError:  # IndexError is the only error thrown during parsing\n            pass  # or print, whatever\n\n# bot = niobot.NioBot(...)\nbot = PatchedClient(...)  # use your patched version\n</code></pre>"},{"location":"changelog/#new-features_6","title":"New features","text":"<ul> <li>Added <code>niobot.attachments.get_image_metadata</code> (depends on <code>imagemagick</code>)</li> <li><code>niocli version</code> now shows the OS and CPU architecture.</li> <li><code>niobot.attachment.*</code> now always imports all attachment types into the <code>niobot</code> namespace, regardless of installed external dependencies.</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug fixes","text":"<ul> <li>Fixed <code>niobot.ImageAttachment</code> being unable to detect image streams.</li> <li>Fixed <code>niobot.BaseAttachment</code> setting incorrect file properties</li> <li><code>niobot.ImageAttachment</code> no longer explicitly fails upon encountering an unknown format, it simply emits a warning, in line with <code>niobot.VideoAttachment</code>.</li> <li>Fixed an unexpected input causing the entire process to crash.</li> </ul>"},{"location":"changelog/#v101-2023-07-12","title":"v1.0.1 (2023-07-12)","text":"<ul> <li>Added stub <code>setup.py</code> for really old pip versions.</li> <li>Updated the README.</li> </ul>"},{"location":"changelog/#v100-2023-07-12","title":"v1.0.0 (2023-07-12)","text":"<p>The first stable release! This version has many breaking changes since v0.1.0, and as such is not very backwards compatible.</p> <ul> <li><code>MediaAttachment</code> and <code>Thumbnail</code> were split up into <code>ImageAttachment</code>, <code>VideoAttachment</code>, <code>AudioAttachment</code>, and <code>FileAttachment</code>.</li> <li>Attachments now automatically detect metadata.</li> <li>Thumbnailing was massively improved.</li> <li>Blurhashes are automatically generated for images.</li> <li>Attachments now fully support end-to-end encryption.</li> <li>Attachments will now emit warnings when a non web-safe codec is used.</li> <li>Automatic command parameter parsing, so you no longer have to manually specify <code>Command(arguments=[...])</code>.</li> <li>Automatic help command sanitisation.</li> <li>Added additional requirements.</li> <li>Added the ability to add and remove reactions.</li> <li>Added <code>__repr__</code> to most objects in the library.</li> <li>Added more helper/utility functions.</li> <li>Added documentation (tada!).</li> <li>Added more customisation options to <code>niobot.NioBot</code>.</li> </ul> <p>You've reached the end! There are no previously documented releases before the big 1.0.0. If you want to expand this list, you can contribute on GitHub! Open issues, or even better, make some pull requests. We love new contributors!</p>"},{"location":"guides/001-getting-started/","title":"Getting started / quick start","text":"<p>Want to skip to see some examples?</p> <p>You can see some examples on GitHub</p> <p>So, you've joined matrix, had a look around, and now you want to make your own little bot? Guess what, you can do just that with nio-bot!</p>"},{"location":"guides/001-getting-started/#prerequisites","title":"Prerequisites","text":"<p>You will need the following in general:</p> <ul> <li>A matrix account you can log into (username and password initially)</li> </ul> <p>And the following installed on the machine you want to run the bot on:</p> <ul> <li>Python with sqlite support</li> <li><code>libolm</code> (use your system package manager, like apt or pacman) in order to use end-to-end encryption.</li> <li><code>libmagic</code> (usually you can just install <code>python3-magic</code>) which is required for attachments.</li> <li>A decent network connection (at least a few megabits a second, preferably more)</li> <li>At least 100mb free storage space (for the database and other files)</li> </ul>"},{"location":"guides/001-getting-started/#installation","title":"Installation","text":"<p>After you've installed and acquired the above, you can install nio-bot with the following command: <pre><code>python3 -m pip install nio-bot[cli]\n# Note that we install the extras for `cli` here - the niobot CLI comes with a bunch of useful tools we'll use.\n</code></pre> If you would like to install support for end-to-end encryption, you can install the following instead: <pre><code>python3 -m pip install nio-bot[cli,e2ee]\n</code></pre></p>"},{"location":"guides/001-getting-started/#creating-the-start-of-your-bot","title":"Creating the start of your bot","text":"<p>In our instance here, we'll create a few files:</p> <ol> <li>A <code>config.py</code> file to store our configuration.</li> <li>A <code>main.py</code> file to store our bot code.</li> <li>A <code>fun.py</code> file to store a module (later on).</li> </ol> <p>And you'll need a directory:</p> <ol> <li><code>store</code> - this is where nio-bot will store its database and other files.</li> </ol>"},{"location":"guides/001-getting-started/#file-structure","title":"File structure","text":"<p>And as such, our directory structure will look like this: <pre><code>test-niobot/\n\u251c\u2500\u2500 config.py\n\u251c\u2500\u2500 fun.py\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 store/\n\u2514\u2500\u2500 main.py\n</code></pre></p> <p>Danger</p> <p>Make sure, if you are using version control, to add <code>config.py</code> to your <code>.gitignore</code> file! This file contains all of your personal information, such as your password, and should not be shared with anyone.</p> <p>While you're at it, you should add the <code>store</code> directory to your <code>.gitignore</code> file as well, as that will contain encryption keys later on.</p>"},{"location":"guides/001-getting-started/#setting-up-configpy","title":"Setting up config.py","text":"<p>For this example, we will assume you are using https://matrix.org as your homeserver.</p> <p>In our <code>config.py</code> file, we'll add the following:</p> <pre><code>HOMESERVER = \"https://matrix-client.matrix.org\"\nUSER_ID = \"@my-username:matrix.org\"\nPASSWORD = \"my-password\"\n</code></pre> <p>Warning</p> <p>Make sure to replace the above with your own homeserver, user ID, and password!</p>"},{"location":"guides/001-getting-started/#making-the-bot-runtime-file","title":"Making the bot runtime file","text":"<p>And, to make a simple bot, you can just copy the below template into your <code>main.py</code> file:</p> <pre><code>import niobot\nimport config\n\nbot = niobot.NioBot(\n    homeserver=config.HOMESERVER,\n    user_id=config.USER_ID,\n    device_id='my-device-id',\n    store_path='./store',\n    command_prefix=\"!\",\n    owner_id=\"@my-matrix-username:matrix.org\"\n)\n# We also want to load `fun.py`'s commands before starting:\nbot.mount_module(\"fun\")  # looks at ./fun.py\n\n@bot.on_event(\"ready\")\nasync def on_ready(_):\n    # That first argument is needed as the first result of the sync loop is passed to ready. Without it, this event\n    # will fail to fire, and will cause a potentially catasrophic failure.\n    print(\"Bot is ready!\")\n\n\n@bot.command()\nasync def ping(ctx):  # can be invoked with \"!ping\"\n    await ctx.respond(\"Pong!\")\n\nbot.run(password=config.PASSWORD)\n</code></pre> About <code>owner_id</code> <p><code>owner_id</code> is intended to tell nio-bot who owns the current instance. Do not set this to be the same thing as <code>config.USER_ID</code> (your bot's ID)! The only time you should do that is if you want to run the bot on the same account you use.</p> <p>Otherwise, set this to be your own user ID, so that you can use any \"owner only\" commands.</p> <p>It is not necessary to set this though, so it can be omitted or set to <code>None</code>. Just note that <code>NioBot.is_owner(...)</code> will raise an error when used in that case.</p>"},{"location":"guides/001-getting-started/#enabling-logging","title":"Enabling logging","text":"<p>You'll probably find that it's useful to enable debug logging while you're developing your bot. To do that, you can add the following to your <code>main.py</code> file: <pre><code>import logging\nimport niobot\n\nlogging.basicConfig(level=logging.DEBUG)\n# or to save to a file (uncomment):\n# logging.basicConfig(level=logging.DEBUG, filename=\"bot.log\")\n\nbot = niobot.NioBot(...)\n...\n</code></pre></p> <p>This will print an awful lot of text to your console, but will ultimately be helpful for debugging any issues you are encountering, as it will show you a lot of what niobot is doing.</p>"},{"location":"guides/001-getting-started/#making-funpy","title":"Making fun.py","text":"<p>Now, fun.py is going to be a module.</p> <p>Modules are a great way to organize your code, and make it easier to manage. They also allow you to easily add new commands to your bot without having to edit the main file, which means you can split your code up, and make it... modular!</p> <p>To start, we need to make the fun.py python file, and add the following:</p> <p><pre><code>import niobot\n\n\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\n    def __init__(self, bot):\n        super().__init__(bot)\n        # This gives you access to `self.bot`, which is the NioBot instance you made in main.py!\n</code></pre> And that's it! You made your module!</p>"},{"location":"guides/001-getting-started/#but-wait-theres-more","title":"But wait, there's more!","text":"<p>You may notice that with this being a separate module, you can't use <code>@bot.command</code>, or <code>@bot.on_event</code>, or reference <code>bot</code> at all!</p> <p>You'd initially assume \"Oh, I'll just import bot from main.\" - but that's not going to work. The reason for this is every time <code>main.py</code> is imported, it creates a new <code>NioBot</code>, and then... calls bot.run() at the end, meaning not only would your import never finish, but it would also cause a massive recursion bug!</p> <p>The way you get around this is instead with <code>@niobot.command()</code>. This is a decorator that will register the command with the bot, however is designed specifically with modules in mind.</p> <p>Let's compare the two, for simplicity:</p> <code>@niobot.NioBot.command()</code> <code>@niobot.command()</code> Adds commands to the register immediately Adds commands to the register once the module is loaded Can only be used at runtime, or wherever <code>bot</code> can be imported from Can only be used in modules (has no effect outside a<code>niobot.Module</code>!) Takes priority over <code>@niobot.command()</code> due to the immediate register Lower priority than <code>NioBot.command()</code> due to the \"lazy loading\" <p>Do be aware though, both decorators will take the exact same arguments as <code>niobot.Command</code>.</p>"},{"location":"guides/001-getting-started/#adding-a-command-to-funpy","title":"Adding a command to fun.py","text":"<p>So, let's add a command to our module:</p> <pre><code>import niobot\n\n\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\n    def __init__(self, bot):\n        super().__init__(bot)\n\n    @niobot.command()\n    async def hello(self, ctx: niobot.Context):\n        await ctx.respond(\"Hello %s!\" % ctx.event.sender)\n</code></pre> <p>This will add a command, <code>!hello</code>, that will reply with \"Hello {@author}!\"</p>"},{"location":"guides/001-getting-started/#starting-the-bot","title":"Starting the bot","text":"<p>Hold your horses, you're not quite ready yet!</p> <p>Generally, it's a terrible idea to always use a password in your code. It's a security risk, and in matrix it can result in creating many sessions, which you don't want, especially if you're using encryption!</p>"},{"location":"guides/001-getting-started/#getting-an-access-token","title":"Getting an access token","text":"<p>An access token is like a server-generated long-lived password. You will probably want one in order to repeatedly use the same session, and to avoid having to use your password in your code.</p> <p>You can get your password with <code>niocli get-access-token</code>. For example: <pre><code>(venv) [me@host test-niobot]$ niocli get-access-token\nUser ID (@username:homeserver.tld): @test:matrix.org\nPassword (will not echo):\nDevice ID (a memorable display name for this login, such as 'bot-production') [host]:\nResolving homeserver... OK\nGetting access token... OK\nAccess token: syt_&lt;...&gt;\n</code></pre></p> <p>What you're going to do now, is copy the full access token string, and open <code>config.py</code> again Now, replace <code>PASSWORD=...</code> with <code>ACCESS_TOKEN=\"syt_&lt;...&gt;\"</code>. Make sure to keep the quotes!</p> <p>You will also need to go into <code>main.py</code>, down to the last line, and replace <code>password=config.PASSWORD</code> with <code>access_token=config.ACCESS_TOKEN</code>.</p> What is <code>sso_token</code>? <p>SSO token is a <code>S</code>ingle <code>S</code>ign <code>O</code>n token, employed by the likes of Mozilla, and is often used for SAML. Chances are, if you don't know what it is, you definitely don't need it. And if you do need it, you already know what it is, why you need it, and how to get it.</p>"},{"location":"guides/001-getting-started/#actually-running-the-bot","title":"Actually running the bot","text":"<p>This is the really simple part, actually. All you need to do now is run <code>main.py</code>!</p> <pre><code>(venv) [me@host test-niobot]$ python main.py\n&lt;insert log spam here&gt;\nBot is ready!\n&lt;insert log spam here&gt;\n</code></pre> <p>Its taking FOREVER to log in! is something going wrong?</p> <p>Nope. It can often take a while (upwards of five minutes in some cases!) for the bot to log in. This is because, when you first start the bot, it has to sync your entire state with the server. This often results in a LOT of IO, and a lot of network waiting, etc.</p> <p>You can speed up this process in the future by:</p> <ul> <li>Making sure you have <code>store_path</code> and a valid store in your configuration. Stores mean that the bot doesn't have   to re-sync everything every time it starts up.</li> <li>Using an access token instead of a password. This means that the bot doesn't have to log in, and can just start   syncing immediately, even from the last time it was stopped, which saves a very very large portion of the time   taken</li> </ul>"},{"location":"guides/001-getting-started/#interesting-log-output","title":"Interesting log output","text":"<p>You may notice that, if you enabled logging, you get some interesting log output.</p> <p>Some things you will want to keep an eye out for:</p> <ul> <li><code>INFO:niobot.client:Encryption support enabled automatically.</code> - This means that you have set up requirements for the   bot to use encryption, and it has detected that it can use encryption, and automatically enabled it, which is good!</li> <li><code>DEBUG:niobot.client:&lt;module '...' from '...'&gt; does not have its own setup() - auto-discovering commands and events</code> - This   means that the bot has detected a module, and is automatically loading it. This is good for most cases.   You should only worry about this message if you defined your own setup function.</li> <li><code>DEBUG:niobot.client:Registered command &lt;Command name='...' aliases=[...] disabled=...&gt; into &lt;command_name&gt;</code> - This simply   means a command has been added to the internal register.</li> <li><code>DEBUG:niobot.client:Added event listener &lt;function &lt;function_name&gt; at &lt;address&gt;&gt; for '&lt;event_name&gt;'</code> - Like the above,   this simply means an event has been added to the internal register.</li> </ul>"},{"location":"guides/001-getting-started/#and-thats-it","title":"And that's it!","text":"<p>You've successfully made a bot, and got it running!</p>"},{"location":"guides/001-getting-started/#wait-how-do-i-use-it","title":"Wait, how do I use it?","text":"<p>nio-bot has a handy dandy auto-join feature - if you just invite your bot's user to a room, assuming all is correct, within a couple seconds, your bot will automatically join your room!</p> <p>Then, you can run <code>!help</code> to get a list of commands, and <code>!help &lt;command&gt;</code> to get help on a specific command.</p>"},{"location":"guides/001-getting-started/#final-product","title":"Final product","text":"config.py <pre><code>HOMESERVER = \"https://matrix.org\"  # or your homeserver\nUSER_ID = \"@my-bot:matrix.org\"  # your bot account's user ID\nACCESS_TOKEN = \"syt_&lt;...&gt;\"  # your bot account's access token\n</code></pre> main.py <pre><code>import niobot\nimport logging\nimport config\n\nlogging.basicConfig(level=logging.INFO, filename=\"bot.log\")\n\nbot = niobot.NioBot(\n    homeserver=config.HOMESERVER,\n    user_id=config.USER_ID,\n    device_id='my-device-id',\n    store_path='./store',\n    command_prefix=\"!\",\n    owner_id=\"@my-matrix-username:matrix.org\"\n)\n# We also want to load `fun.py`'s commands before starting:\nbot.mount_module(\"fun\")\n\n@bot.on_event(\"ready\")\nasync def on_ready(_):\n    # That first argument is needed as the first result of the sync loop is passed to ready. Without it, this event\n    # will fail to fire, and will cause a potentially catasrophic failure.\n    print(\"Bot is ready!\")\n\n\n@bot.command()\nasync def ping(ctx):  # can be invoked with \"!ping\"\n    await ctx.respond(\"Pong!\")\n\nbot.run(access_token=config.ACCESS_TOKEN)\n</code></pre> fun.py <pre><code>import niobot\n\n\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\n    def __init__(self, bot):\n        self.bot = bot  # bot is the NioBot instance you made in main.py!\n\n    @niobot.command()\n    async def hello(self, ctx):\n        await ctx.respond(\"Hello %s!\" % ctx.event.sender)\n</code></pre>"},{"location":"guides/001-getting-started/#why-is-logging-in-with-a-password-so-bad","title":"Why is logging in with a password so bad?","text":"<p>Logging in with a password carries more risk than logging in with a token, and is more prone to error. When you log in with a password with nio-bot, you need to store that password. If your password is leaked, an attacker can create as many sessions as they want, reset your password, etc. However, with an access token, they're limited to that session, and cannot reset your password.</p> <p>Furthermore, if you log in with a password, some servers may generate you a completely new session, which is very slow, and can easily break any e2ee you have. Unless you are very careful with your environment, you may find yourself with slow startup times, session spam, and decryption errors.</p> <p>What you should do instead is get an access token.</p> <p>If you already know how to get yours, that's great! Otherwise, <code>niocli</code> has the solution:</p> <pre><code>$ niocli get-access-token\n</code></pre> <p>This will log into the account when prompted, and will grab you an access token, spitting it out into your terminal.</p> <p>From there, you can replace <code>bot.run(password=\"...\")</code> with <code>bot.run(access_token=\"...\")</code>, and you're good to go!</p>"},{"location":"guides/002-a-simple-bot/","title":"A simple bot - example","text":"<p>Let's take the following code and break it down, so that you can better understand how niobot works:</p> <pre><code>import niobot\n\n\nbot = niobot.NioBot(\n    homeserver=\"https://matrix.org\",\n    user_id=\"@my_username:matrix.org\",\n    device_id=\"my_device_name\",  # defaults to the easily recognisable 'nio-bot'.\n    store_path=\"./store\",  # See the 'What is the store?' section for more info.\n    command_prefix=\"!\",\n    case_insensitive=True,  # means `!PING` and `!piNG` will both work and run `!ping`.\n    owner_id=\"@owner:matrix.org\",  # The user ID who owns this bot. Optional, but required for bot.is_owner(...).#\n    # Here, you can pass extra options that you would usually pass to `nio.AsyncClient`. Lets pass a proxy:\n    proxy=\"socks5://username:password@host:port\"\n)\n\n\n# Now, we want to register a command. NioBot uses the decorator `@NioBot.command()` for this.\n# This decorator takes a few arguments, but the only one you'll use most of the time is `name`.\n# There are also other arguments though.\n# For now we'll register a simple `ping` command.\n@bot.command(name=\"ping\")\n# We now need to define the function\nasync def ping(ctx: niobot.Context):\n    \"\"\"Shows the latency between events\"\"\"\n    # So a few things have happened here:\n    # `async def` makes this command asynchronous. This means that it can `await` other things.\n    # `ctx` is the only argument this command takes. By default, all niobot commands must take at least one argument,\n    # which is the command's context.\n    # We also then typehinted it with `niobot.Context`. This isn't critical to make the bot run, however if you're using\n    # an IDE like PyCharm, or just a workspace editor with intellisense like Visual Studio Code, it will help you\n    # to see what attributes and functions `niobot.Context` has without needing to check the documentation.\n    # Anyway, lets write the command itself.\n    # First, we need to measure the latency. NioBot has a handy function for this:\n    latency_ms = bot.latency(ctx.message)\n    # `bot.latency` measures the latency between when the event was dispatched by the server, and when the bot\n    # received it. It then returns the latency in milliseconds.\n    # `Context.message` is the event that triggered this command.\n    # Now, we need to reply to the user.\n    await ctx.respond(\"Pong! Latency: {:.2f}ms\".format(latency_ms))\n    # And that's it! We've written our first command.\n    # `Context.respond` always sends a reply to the user who sent the command.\n    # To send a message without a reply, you can use `NioBot.send_message`.\n\n\n# And while we're at it, we can add an event listener.\n# For this example, we'll add an event listener that tells the user if there's a command error.\n@bot.on_event(\"command_error\")\nasync def on_command_error(ctx: niobot.Context, error: Exception):\n    \"\"\"Called when a command raises an exception\"\"\"\n    # Take a look at the event reference for more information about events.\n    # Now, we can send a message to the user.\n    await ctx.respond(\"Error: {}\".format(error))\n\n\n# And while we're at it, we'll log when a user runs a command.\n@bot.on_event(\"command\")\nasync def on_command(ctx):\n    print(\"User {} ran command {}\".format(ctx.message.sender, ctx.command.name))\n\n\n# Now, we need to start our bot.\n# This is done by calling `NioBot.run()`.\n# In this example, we'll use an access token, rather than an insecure password.\n# You can get an access token through the niobot CLI:\n# $ niocli get-access-token\n# Copy the resulting access token, and then you can put it here:\nbot.run(access_token=\"my_access_token\")\n# Bear in mind that no code will run after `bot.run`. This function will block until the bot is stopped.\n# And even when the bot is stopped, its usually with an exception, so code after `bot.run` is not guaranteed to run.\n</code></pre>"},{"location":"guides/003-sending-attachments/","title":"Sending attachments","text":"<p>Sometimes, you want to upload attachments in your chat. Be that images, videos, or other kinds of files. NioBot supports this, and it's very easy to do.</p>"},{"location":"guides/003-sending-attachments/#before-you-start","title":"Before you start","text":"<p>In order to use the majority of the features in this guide, you will need to install <code>ffmpeg</code> and <code>imagemagick</code>. These are used for thumbnail generation, and metadata detection.</p> <p>You should use your package manager to install these, as they are not python packages.</p> Debian/UbuntuArchFedoramacOSWindows <pre><code>sudo apt install ffmpeg imagemagick\n</code></pre> <pre><code>sudo pacman -S ffmpeg imagemagick\n</code></pre> <pre><code>sudo dnf install ffmpeg imagemagick\n</code></pre> <pre><code>brew install ffmpeg imagemagick\n</code></pre> <p><pre><code>choco install ffmpeg\nchoco install imagemagick\n</code></pre> Or, install it yourself. Make sure the binaries are in your PATH:</p> <ul> <li>gyan.dev/ffmpeg/builds/ffmpeg-git-essentials.7z</li> <li>imagemagick.org/script/download.php</li> </ul>"},{"location":"guides/003-sending-attachments/#faq","title":"FAQ","text":"Why do I need to install <code>ffmpeg</code> and <code>imagemagick</code>? <p><code>imagemagick</code> is actually optional - if you trust <code>ffprobe</code> to work with all of your images (in some cases it can fail to detect newer image formats), then you can skip installing it.</p> <p>However, <code>ffmpeg</code> is required for all but file attachments. This is because in order to get some rich data, such as dimensions and duration, we need to use <code>ffprobe</code> to get this data. Furthermore, in the event <code>imagemagick</code> is not installed, the metadata fetcher falls back to <code>ffprobe</code>.</p> <p>Not having these installed will result in a <code>RuntimeError</code> being raised when you try to send an attachment when it tries to fetch metadata. This is because the metadata fetcher will not be able to find <code>ffprobe</code> or <code>imagemagick</code> in your PATH.</p> Why does it take a couple of seconds for <code>&lt;attachment&gt;.from_file()</code> to return? <p>The <code>from_file</code> method (see: niobot.VideoAttachment.from_file, niobot.ImageAttachment.from_file, etc.)  does a lot of heavy lifting in terms of preparing a file with all the bells and whistles for an upload.  This means that it has to do a lot of processing, which may take a couple of seconds to return.</p>"},{"location":"guides/003-sending-attachments/#sending","title":"Sending:","text":""},{"location":"guides/003-sending-attachments/#regular-files","title":"Regular files","text":"<p>Here, regular files can be anything that isn't a video, image, or audio file. This includes text files, PDFs, etc. You can even send binary or pre-encrypted (why?) files if you want to.</p> <p>Regular files are the simplest file type in niobot, in terms of code complexity and also features. Regular files do not support:</p> <ul> <li>Thumbnails</li> <li>Rich data</li> <li>Previews</li> </ul> <p>All you get from thumbnails is the file name, and the file size. That's it.</p> <p>Anyway, here's how you could send an example text (foo.txt) file: <pre><code>from niobot import NioBot, Context, FileAttachment\n...\n\n@bot.comand(name=\"upload.txt\")\nasync def upload_txt(ctx: Context):\n    \"\"\"Sends a text file!\"\"\"\n    attachment = await FileAttachment.from_file(\"file.txt\")\n    await ctx.respond(file=attachment)\n</code></pre></p> <p>This results in the following: </p> <p>You can then click on the file to download it!</p>"},{"location":"guides/003-sending-attachments/#images","title":"Images","text":"<p>Images are a bit more complex than regular files. They support thumbnails, rich data, and previews.</p> Thumbnails for images <p>While you may think that thumbnails for images are useless, they are actually very useful for clients. Just beware though, having a larger or equal size image for your thumbnail is very counter-productive.</p> <p>A valid use case for image thumbnails is for lower-resolution, likely compressed versions of the image you're sending. Paired with a blurhash, this can provide a very good \"placeholder\" image for people on  painfully slow connections.</p> <p>For your convenience, unless disabled, niobot will automatically generate a \"blurhash\" for your image.</p> <p>A blurhash is very good for providing a \"placeholder\" image, as it is generated by a string of around 30 characters. This means people on super slow connections can see a pretty preview of the image (without much detail), instead of having an ugly loading spinner or outright blank space in place of a loading image.</p> <p>For example:</p> <p> </p> This may slow down your image upload <p>Generating blurhashes, especially for large images, even more especially with a weak CPU, can be very slow. While this will not block your code execution, it means you must wait for the blurhash to be generated before you can do anything with the image.</p> <p>You may want to disable this behaviour. See disabling extra media features.</p> <p>And here's an example: <pre><code>from niobot import NioBot, Context, ImageAttachment\n...\n\n\n@bot.comand(name=\"upload.png\")\nasync def upload_png(ctx: Context):\n    \"\"\"Sends a png image!\"\"\"\n    attachment = await ImageAttachment.from_file(\"file.png\")\n    await ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#audio","title":"Audio","text":"<p>Audio files are actually simpler than images, however they do not support thumbnails or rich data outside of their duration.</p> Beware your codec! <p>You should aim to have your audio files as <code>opus</code>, <code>vorbis</code>, <code>aac</code>, <code>flac</code>, or <code>mp3</code> encoded files, as some clients may not be able to play other formats. Also be mindful of their containers, since some (such as <code>mkv</code>) won't play in some clients.</p> <p>Here's an example: <pre><code>from niobot import NioBot, Context, AudioAttachment\n...\n\n\n@bot.comand(name=\"upload.mp3\")\nasync def upload_mp3(ctx: Context):\n    \"\"\"Sends a mp3 audio file!\"\"\"\n    attachment = await AudioAttachment.from_file(\"file.mp3\")\n    await ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#videos","title":"Videos","text":"<p>Videos are the most complex file type in niobot. They support thumbnails, rich data, and previews.</p> <p>Again though, NioBot makes this easy. All you need to do is pass a video file to <code>VideoAttachment.from_file()</code>.</p> <p>The same warnings apply as images, except for the blurhash. Blurhashes are not generated for videos. However, thumbnails are generated by default, with their own blurhashes. For simplicity, the video's auto-generated thumbnail is simply the first frame of the video.</p> <p>Beware of your codec(s)!</p> <p>A lot of matrix clients at the moment are simple HTML5-based clients - meaning they can only play a limited set of codecs out of the box.</p> <p>You should aim to keep your video codecs as <code>h264</code>, <code>vp8</code>, or <code>vp9</code>, as these are the most widely supported. However, some native apps may not even support vp8/vp9. Use h264/avc when in doubt.</p> <p>Look at audio's warning for more information about audio codecs.</p> <p>Here's an example: <pre><code>from niobot import NioBot, Context, VideoAttachment\n...\n\n\n@bot.comand(name=\"upload.mp4\")\nasync def upload_mp4(ctx: Context):\n    \"\"\"Sends a mp4 video!\"\"\"\n    attachment = await VideoAttachment.from_file(\"file.mp4\")\n    await ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#unsure-which-to-use","title":"Unsure which to use?","text":"<p>If you aren't sure which file type you have, you can find out the most appropriate Attachment type using <code>niobot.attachment.which</code> - this will return either <code>VideoAttachment</code>, <code>ImageAttachment</code>, <code>AudioAttachment</code>, or <code>FileAttachment</code>, based on the mime type of the file.</p> <p>Fpr example:</p> <pre><code>import random\nimport niobot\n\n\n...\n\n\n@bot.comand(name=\"upload\")\nasync def upload_mp4(ctx: Context):\n    \"\"\"Sends a random file!\"\"\"\n    files = (\"file.txt\", \"file.mp4\", \"file.mp3\", \"file.png\")\n    file_name = random.choice(files)\n\n    attachment_type = niobot.which(file_name)\n    attachment = await attachment_type.from_file(file_name)\n    # ^ can also be written as `attachment = await niobot.which(file_name).from_file(file_name)`\n    await ctx.respond(file=attachment)\n</code></pre> <p>This will upload using the appropriate file type.</p>"},{"location":"guides/003-sending-attachments/#disabling-extra-media-features","title":"Disabling extra media features","text":""},{"location":"guides/003-sending-attachments/#disabling-blurhash-generation","title":"Disabling blurhash generation","text":"This will harm the user experience <p>Disabling blurhash generation is a terrible idea - unless you make sure your uploads are a matter of kilobytes, you will always see blank spots while at least a thumbnail is loaded. Please consider alternative options.</p> <p>for niobot.VideoAttachment and niobot.ImageAttachment: <pre><code>from niobot import NioBot, Context, ImageAttachment, VideoAttachment\n...\n\nasync def foo():\n    attachment = await ImageAttachment.from_file(\"file.png\", generate_blurhash=False)\n    # or for Videos\n    attachment = await VideoAttachment.from_file(\"file.mp4\", generate_blurhash=False)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#disabling-thumbnail-generation","title":"Disabling thumbnail generation","text":"This will harm the user experience <p>If you intend to disable thumbnail generation, you should provide your own thumbnail, or at the very least leave blurhash generation enabled.</p> <p>Otherwise, while your video loads, clients will most likely just show a completely transparent box, with a loading spinner at a stretch. This leaves a massive chunk of the UI completely blank while your video loads.</p> <p>for niobot.VideoAttachment only: <pre><code>from niobot import NioBot, Context, ImageAttachment, VideoAttachment\n...\n\nasync def foo():\n    attachment = await VideoAttachment.from_file(\"file.mp4\", thumbnail=False)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#disabling-rich-data","title":"Disabling rich data","text":"<p>A lot of rich data fields will still require values for clients to properly render the media!</p> <p>In this case, \"rich data\" refers to some \"optional\" fields in media uploads, such as <code>height</code>, <code>width</code>, <code>duration</code>, etc. These fields are not required for the server to accept the upload, but they are often used by clients to figure out how to properly display the media.</p> <p>\"Rich data\" is gathered from the [get_metadata][niobot.get_metadata] function, which itself calls <code>ffprobe</code>/imagemagick as a subprocess. If, for whatever reason, this is undesirable, you can avoid it.</p> <p>Disabling rich data is not 100% possible, but you can avoid it by passing minimal values where it would automatically be filled in:</p>"},{"location":"guides/003-sending-attachments/#images_1","title":"Images","text":"<pre><code>from niobot import ImageAttachment\n\nasync def foo():\n    attachment = await ImageAttachment.from_file(\"file.png\", width=0, height=0, unsafe=True)\n</code></pre>"},{"location":"guides/003-sending-attachments/#videos_1","title":"Videos","text":"<p><pre><code>from niobot import VideoAttachment\n\nasync def foo():\n    attachment = await VideoAttachment.from_file(\"file.mp4\", width=0, height=0, duration=0)\n</code></pre> You may also want to consider either manually passing a thumbnail, or disabling thumbnail auto generation, as otherwise you'll still have ffmpeg/imagemagick called.</p>"},{"location":"guides/003-sending-attachments/#audio_1","title":"Audio","text":"<pre><code>from niobot import AudioAttachment\n\nasync def foo():\n    attachment = await AudioAttachment.from_file(\"file.mp3\", duration=0)\n</code></pre>"},{"location":"guides/004-creating-custom-parsers/","title":"Creating custom parsers","text":"<p>New in version 1.1.0b1</p> <p>This feature was added in version 1.1.0b1 - <code>pip install niobot&gt;=1.1.0b1</code></p> <p>NioBot is loaded with some sane defaults for basic types. If you were to pass the following function as a command: <pre><code>async def my_command(ctx: Context, arg1: int, arg2: float, arg3: str):\n    ...\n</code></pre> NioBot would intelligently detect <code>ctx</code> as the context (and realise it's not intended to be something the user provides) and <code>arg1</code> as an integer, <code>arg2</code> as a float, and <code>arg3</code> as a string. Then, when my_command is run, the first argument would be converted to an integer from the message, the second as a  float, and so on.</p> <p>However, these built-in types only go so far - they're limited to a subset of python built-in types, and a couple matrix-specific things (i.e. rooms and events and matrix.to links).</p> <p>This looks worryingly complicated</p> <p>Pre <code>1.1.0b1</code>, parsers were far too flexible and inconsistent. The old structure only required you had a singular synchronous function that took three arguments: <code>ctx</code>, <code>arg</code>, and <code>user_input</code>.</p> <p>This was a problem for a couple reasons:</p> <ol> <li>The flexibility meant that it was difficult to get a uniform experience across all parsers.</li> <li>This was still not very flexible for customising the parsers, and often required wrappers.</li> </ol> <p>However, since 1.1.0b1, the parser structure now uses two new ABC classes, <code>Parser</code> and <code>StatelessParser</code>, to ensure that all parsers are consistent and easy to use, while still being flexible and configurable. As a result of using classes though, some parsers can still feel a little bit bulky. But that's okay!</p>"},{"location":"guides/004-creating-custom-parsers/#creating-a-parser","title":"Creating a parser","text":"<p>Creating a parser is actually really easy. All the library needs from you is a class that subclasses either of the parser ABCs (see below), and implements the <code>__call__</code> dunder method!</p> <p>For example: <pre><code>from niobot.utils.parsers import StatelessParser\nfrom niobot import CommandParserError\n\n\nclass UserParser(StatelessParser):\n    def __call__(self, ctx: Context, arg: Argument, value: str):\n        # Do some stuff here\n        if \"@\" not in value:\n            # Always raise CommandParserError when its an invalid value - this allows for proper error handling.\n            raise CommandParserError(\"Invalid user ID. Expected @user:example.com\")\n        return value[1:]  # Remove the @ from the user ID\n</code></pre></p> <p>You can then use this parser in your commands like so: <pre><code>import niobot\nimport typing\nfrom my_parsers import UserParser\n\n\nbot = niobot.NioBot(...)\n\n\n@bot.command()\nasync def my_command(ctx: niobot.Context, user: typing.Annotated[str, UserParser]):\n    # typing.Annotated[real_type, parser] is a special type that allows you to specify a parser for a type.\n    # In your linter, `user` will be `str`, not `UserParser`.\n    await ctx.respond(\"User ID: {!s}\".format(user))\n</code></pre></p>"},{"location":"guides/004-creating-custom-parsers/#what-if-i-need-to-await-in-my-parser","title":"What if I need to <code>await</code> in my parser?","text":"<p>If you need to use asynchronous functions in your parser, you can simply return the coroutine in __call__, like below:</p> <p><pre><code>class MyParser(Parser):\n    async def internal_caller(self, ctx: Context, arg: Argument, value: str):\n        # Do some stuff here\n        await asyncio.sleep(1)  # or whatever async function you need to call\n        return value\n\n    def __call__(self, *args, **kwargs):\n        return self.internal_caller(*args, **kwargs)  # this returns a coroutine.\n</code></pre> By returning the unawaited coroutine, the library will intelligently detect it needs to be awaited, and will do so.</p> <p>If you want to use a parser like this in your code manually, you can always use niobot.utils.force_await, which will await a coroutine if it needs awaiting, or simply returns the input if it's not a coroutine.</p> <pre><code>from niobot.utils import force_await\ncoro = MyParser()(...)\n# If you're not sure if coro is a coroutine or not, you can use force_await\nparsed = await force_await()\n# Otherwise, simply await the result\ncoro = await MyParser()(...)\n</code></pre>"},{"location":"guides/004-creating-custom-parsers/#whats-the-difference-between-parser-and-statelessparser","title":"What's the difference between Parser and StatelessParser?","text":"<p>Great question!</p> <p>With parsers, there's often a split between complicated/customisable, and fixed parsers. For example,  IntegerParser is a customisable parser - You can pass options to it while initialising it, and it will use those options to parse the input. However, on the contrary, BooleanParser is a fixed parser - it does not take any options, and will always convert the input to a boolean.</p> <p>Basically, <code>StatelessParser</code> never needs to access <code>self</code> while parsing. <code>Parser</code> can.</p>"},{"location":"guides/004-creating-custom-parsers/#which-should-i-choose","title":"Which should I choose?","text":"<p>If you're writing a parser that needs to be customisable and takes options, then you should use <code>Parser</code>. Otherwise, if you don't need <code>self</code>, then you should use <code>StatelessParser</code>.</p>"},{"location":"guides/005-direct-messages/","title":"Direct Messages","text":"<p>New in version 1.1.0b2</p> <p>This feature was added in version 1.1.0b2 - <code>pip install niobot&gt;=1.1.0b2</code></p> <p>In Matrix,  Direct Messages are a bit of a loose concept. In short, a \"direct message\" in Matrix is more of a room, except with initially only two members, and a special flag, <code>is_direct</code>, set to <code>true</code> in the <code>invite</code> event.</p> <p>However, when you join a direct room, or flag a room as direct in a client, this information is stored in account data, on the homeserver. This means that your homeserver will keep track of rooms that you're in that're flagged as \"direct\".</p> <p>Direct does not mean one-to-one!</p> <p>Direct rooms are not necessarily one-to-one. They can have more than two members, and they can be group chats.</p> <p>The only thing that makes a room \"direct\" is the <code>is_direct</code> flag in the <code>invite</code> event.</p> <p>This means that if you want to send a message to a user, you should check if the direct room you've chosen contains only two members. If not, look for another, or create one.</p>"},{"location":"guides/005-direct-messages/#how-do-i-send-dms-in-niobot","title":"How do I send DMs in NioBot?","text":"<p>NioBot handles DMs mostly transparently.</p> <p>In base <code>matrix-nio</code>, trying to use <code>AsyncClient.room_send</code> and passing a user as the <code>room_id</code> will result in an error. You'd probably expect it to send a message to that user, so NioBot does just that!</p> <p>With a bit of magic, NioBot will automatically create a direct room with the user, and send the message there. In addition, if there's already a direct room stored in account data, NioBot will use the first one it finds.</p> <p>Take this example:</p> <pre><code>import niobot\n\nbot = niobot.NioBot(...)\n\n\n@bot.command(\"dm\")\nasync def send_dm(ctx: niobot.Context):\n    \"\"\"Sends you a direct message!\"\"\"\n    await bot.send_message(ctx.message.sender, \"Hello, world!\")\n</code></pre> <p>First, NioBot checks to see if there's a direct room stored in account data. If there is, it'll use that. If not, however, it will create one, and invite the user.</p> <p>And that's it! Its really that simple!</p>"},{"location":"guides/005-direct-messages/#getting-and-creating-direct-rooms","title":"Getting and creating direct rooms","text":"<p>If you want to use direct rooms outside of sending messages, you can use niobot.NioBot.get_dm_rooms, and niobot.NioBot.create_dm_room.</p> <p>For example: <pre><code>import niobot\n\nbot = niobot.NioBot(...)\n\n\n@bot.command(\"get-dm-rooms\")\nasync def get_dm_room(ctx: niobot.Context):\n    \"\"\"Gets the direct room with the user.\"\"\"\n    rooms = await bot.get_dm_rooms(ctx.message.sender)\n\n    if not rooms:\n        await ctx.respond(\"You don't have any direct rooms!\")\n        return\n\n    rooms_text = \"\\n\".join([f\"* https://matrix.to/#/{room_id}\" for room_id in rooms])\n    await ctx.respond(f\"Your {len(rooms):,} direct rooms:\\n\\n{rooms_text}\")\n\n\n@bot.command(\"create-dm-room\")\nasync def create_dm_room(ctx: niobot.Context):\n    \"\"\"Creates a direct room with the user.\"\"\"\n    response = await bot.create_dm_room(ctx.message.sender)\n    await ctx.respond(f\"Created direct room: https://matrix.to/#/{response.room_id}\")\n</code></pre></p> <p>In this example, <code>get-dm-rooms</code> would return a count, alongside a list, of every DM room the client shares with the user. <code>create-dm-room</code> would create a new direct room with the user, and return the room link.</p> <p>The user would've already been automatically invited to the room when it was created, so there's no need to send an invitation separately.</p>"},{"location":"meta/code-of-conduct/","title":"Code of Conduct - niobot chat rooms","text":"<p>While we try to be nice and relaxed in our chat rooms, there are still a few guidelines that you must follow when engaging with our community.</p> <p>For clarification, \"chat room\" here refers to any method of communication surrounding nio-bot. This includes, but is not limited to, the Matrix rooms, and GitHub issues. Read further to see more specific moderation information.</p>"},{"location":"meta/code-of-conduct/#ye-old-rule-book","title":"Ye old rule book","text":"<p>To keep things short and snappy, not every single punishable offense is listed here. Use a bit of common sense and think, \"would I want this in my community?\". If not, neither do we.</p>"},{"location":"meta/code-of-conduct/#1-serve-a-warm-and-kind-environment","title":"1. Serve a warm and kind environment","text":"<p>Conversations in the niobot chat rooms should strive to be a warm and welcoming place for anyone and everyone. This means:</p> <ul> <li>All conversations should be civil and respectful.</li> <li>Drama should be taken to direct messages, unless it directly relates to niobot.</li> <li>Hurtful language should never be used, under any circumstances, ever. This includes language that may be hateful, bigoted, or hurtful.<ul> <li>Swearing is permitted, under the authority that it is not excessive or directed.</li> </ul> </li> <li>Messages should have clear intent - tone is difficult to convey over text.</li> <li>Respect the people around you.<ul> <li>If someone asks you to stop doing something, you should do so. If you have an issue with their request, take it up with them directly in direct messages, or elsewhere.</li> </ul> </li> </ul>"},{"location":"meta/code-of-conduct/#2-do-not-be-disruptive","title":"2. Do not be disruptive","text":"<p>Causing disruption can happen in many forms, but regardless, is entirely unwelcome. Being disruptive is usually in the form of sending spam, such as large blocks of text, or several images, but could also be injecting an off-topic conversation.</p>"},{"location":"meta/code-of-conduct/#3-act-without-malice","title":"3. Act without malice","text":"<p>Any form of malice is not welcome in the niobot chat rooms. Doing ANYTHING with malice is completely unacceptable and will be treated as such. Even if you do not intend malice, if malice is perceived by a group, and you cannot appropriately explain why it was not such, then it will be treated so.</p>"},{"location":"meta/code-of-conduct/#4-the-standard-dont-be-a-thorn","title":"4. The standard \"don't be a thorn\"","text":"<p>For this, you may want to take a gander at the Matrix.org code of conduct. Their CoC has a great list of things that you should not do here, such as doxxing, harassment, or posting anything NSFW.</p> <p>Their code of conduct conduct also applies to our chat rooms as it is a great CoC, aside from:</p> <ul> <li>Contact: see contact</li> <li>Application: Their CoC applies to matrix.org, and our rooms.</li> <li>Affiliation: We are not affiliated with matrix.org, we are simply using their CoC in good faith.</li> </ul>"},{"location":"meta/code-of-conduct/#moderation","title":"Moderation","text":"<p>Moderation in niobot matrix rooms is done by the Draupnir (<code>@draupnir:nexy7574.co.uk</code>) bot. This bot has the power level to mute, kick, ban, and serverban (ACL) in all niobot rooms.</p> <p>Our instance of Draupnir is subscribed to the following moderation lists:</p> <ul> <li>Matrix.org's ToS banlist</li> <li>Matrix.org's CoC banlist</li> <li>envs.net's banlist</li> <li>The Community moderation effort (CME) banlist</li> </ul> <p>Meaning, if your homeserver, or your account, is on any of those ban lists, you will not be able to communicate with our Matrix rooms. Futhermore, we also maintain our own custom ban list, however this is usually only exclusive to us before it is added to the CME.</p> <p>If you violate the code of conduct, depending on the severity of the infraction, you will receive:</p> <ol> <li>A personal warning</li> <li>A temporary mute</li> <li>A kick</li> <li>A ban</li> </ol> <p>Obviously, doing something like posting NSFW images will get you banned straight away, but simply getting into an argument won't.</p> <p>For other platforms, moderation will be done manually, and as such more harshly.</p>"},{"location":"meta/code-of-conduct/#contact","title":"Contact","text":"<p>You can contact anyone in the niobot rooms that you see are a moderator (minus bots), however <code>@nex</code> ((me) in most places) is usually the administrator. You can contact me outside of matrix by looking at the \"contact\" section of my website. If that is not working, you can send an email to <code>admin@</code> (domain can be nexy7574.co.uk or i-am.nexus), but I cannot guarantee a timely response.</p>"},{"location":"reference/attachment/","title":"Attachments","text":""},{"location":"reference/attachment/#niobot.attachment.AudioAttachment","title":"AudioAttachment","text":"<p>               Bases: <code>BaseAttachment</code></p> <p>Represents an audio attachment.</p>"},{"location":"reference/attachment/#niobot.attachment.AudioAttachment.duration","title":"duration  <code>property</code> <code>writable</code>","text":"<pre><code>duration: Optional[int]\n</code></pre> <p>The duration of this audio in milliseconds</p>"},{"location":"reference/attachment/#niobot.attachment.AudioAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\n    file: Union[str, BytesIO, Path],\n    file_name: Optional[str] = None,\n    duration: Optional[int] = None,\n) -&gt; AudioAttachment\n</code></pre> <p>Generates an audio attachment</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>duration</code> <code>Optional[int]</code> <p>The duration of the audio, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>AudioAttachment</code> <p>An audio attachment</p>"},{"location":"reference/attachment/#niobot.attachment.AudioAttachment.get_metadata","title":"get_metadata  <code>async</code> <code>classmethod</code>","text":"<pre><code>get_metadata(file: Union[str, Path]) -&gt; Dict[str, Any]\n</code></pre> <p>Get metadata about an audio file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>The audio file to get metadata for</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The metadata</p>"},{"location":"reference/attachment/#niobot.attachment.AttachmentType","title":"AttachmentType","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration containing the different types of media.</p> <p>Attributes:</p> Name Type Description <code>FILE</code> <code>AttachmentType</code> <p>A generic file.</p> <code>AUDIO</code> <code>AttachmentType</code> <p>An audio file.</p> <code>VIDEO</code> <code>AttachmentType</code> <p>A video file.</p> <code>IMAGE</code> <code>AttachmentType</code> <p>An image file.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment","title":"BaseAttachment","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for attachments</p> <p>Note</p> <p>If you pass a custom <code>file_name</code>, this is only actually used if you pass a io.BytesIO to <code>file</code>. If you pass a [Path][] or a string, the file name will be resolved from the path, overriding the <code>file_name</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, PathLike, Path]</code> <p>The file path or BytesIO object to upload.</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file. Must be specified if uploading a BytesIO object.</p> <code>None</code> <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file. If not specified, it will be detected.</p> <code>None</code> <code>size_bytes</code> <code>Optional[int]</code> <p>The size of the file in bytes. If not specified, it will be detected.</p> <code>None</code> <code>attachment_type</code> <code>AttachmentType</code> <p>The type of attachment. Defaults to <code>AttachmentType.FILE</code>.</p> <code>FILE</code> <p>Attributes:</p> Name Type Description <code>file</code> <code>Union[Path, BytesIO]</code> <p>The file path or BytesIO object to upload. Resolved to a [Path][] object if a string is passed to <code>__init__</code>.</p> <code>file_name</code> <code>str</code> <p>The name of the file. If <code>file</code> was a string or <code>Path</code>, this will be the name of the file.</p> <code>mime_type</code> <code>str</code> <p>The mime type of the file.</p> <code>size</code> <code>int</code> <p>The size of the file in bytes.</p> <code>type</code> <code>AttachmentType</code> <p>The type of attachment.</p> <code>url</code> <code>Optional[str]</code> <p>The URL of the uploaded file. This is set after the file is uploaded.</p> <code>keys</code> <code>Optional[dict[str, str]]</code> <p>The encryption keys for the file. This is set after the file is uploaded.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.size_bytes","title":"size_bytes  <code>property</code>","text":"<pre><code>size_bytes: int\n</code></pre> <p>Returns the size of this attachment in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.as_body","title":"as_body","text":"<pre><code>as_body(body: Optional[str] = None) -&gt; dict\n</code></pre> <p>Generates the body for the attachment for sending. The attachment must've been uploaded first.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Optional[str]</code> <p>The body to use (should be a textual description). Defaults to the file name.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\n    file: Union[str, BytesIO, Path],\n    file_name: Optional[str] = None,\n) -&gt; BaseAttachment\n</code></pre> <p>Creates an attachment from a file.</p> <p>You should use this method instead of the constructor, as it will automatically detect all other values</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file or BytesIO to attach</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the BytesIO file, if applicable</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>Loaded attachment.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.from_mxc","title":"from_mxc  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_mxc(client, url: str) -&gt; BaseAttachment\n</code></pre> <p>Creates an attachment from an MXC URL.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>The current client instance (used to download the attachment)</p> required <code>url</code> <code>str</code> <p>The MXC:// url to download</p> required <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>The downloaded and probed attachment.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.from_http","title":"from_http  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_http(\n    url: str, client_session: Optional[ClientSession] = None\n) -&gt; BaseAttachment\n</code></pre> <p>Creates an attachment from an HTTP URL.</p> <p>This is not necessarily just for images, video, or other media - it can be used for any HTTP resource.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The http/s URL to download</p> required <code>client_session</code> <code>Optional[ClientSession]</code> <p>The aiohttp client session to use. If not specified, a new one will be created.</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>The downloaded and probed attachment.</p> <p>Raises:</p> Type Description <code>niobot.MediaDownloadException</code> <p>if the download failed.</p> <code>aiohttp.ClientError</code> <p>if the download failed.</p> <code>niobot.MediaDetectionException</code> <p>if the MIME type could not be detected.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.size_as","title":"size_as","text":"<pre><code>size_as(\n    unit: Literal[\n        \"b\", \"kb\", \"kib\", \"mb\", \"mib\", \"gb\", \"gib\"\n    ],\n) -&gt; Union[int, float]\n</code></pre> <p>Helper function to convert the size of this attachment into a different unit.</p> <p>Remember:</p> <ul> <li>1 kilobyte (KB) is 1000 bytes</li> <li>1 kibibyte (KiB) is 1024 bytes</li> </ul> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Literal['b', 'kb', 'kib', 'mb', 'mib', 'gb', 'gib']</code> <p>The unit to convert into</p> required <p>Returns:</p> Type Description <code>Union[int, float]</code> <p>The converted size</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(client, encrypted: bool = False) -&gt; Self\n</code></pre> <p>Uploads the file to matrix.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <p>The client to upload</p> required <code>encrypted</code> <code>bool</code> <p>Whether to encrypt the attachment or not</p> <code>False</code> <p>Returns:</p> Type Description <code>Self</code> <p>The attachment</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.get_metadata","title":"get_metadata  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<pre><code>get_metadata(\n    file: Union[str, BytesIO, Path],\n) -&gt; Dict[str, Any]\n</code></pre> <p>Gets metadata for a file.</p>"},{"location":"reference/attachment/#niobot.attachment.FileAttachment","title":"FileAttachment","text":"<p>               Bases: <code>BaseAttachment</code></p> <p>Represents a generic file attachment.</p> <p>You should use VideoAttachment for videos, AudioAttachment for audio, and ImageAttachment for images. This is for everything else.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>Optional[int]</code> <p>The size of the file in bytes</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.FileAttachment.get_metadata","title":"get_metadata  <code>async</code> <code>classmethod</code>","text":"<pre><code>get_metadata(\n    file: Union[str, BytesIO, Path],\n) -&gt; Dict[str, Any]\n</code></pre> <p>Dud method, there's no metadata to fetch for a generic file.</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment","title":"ImageAttachment","text":"<p>               Bases: <code>BaseAttachment</code></p> <p>Represents an image attachment.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>Optional[int]</code> <p>The size of the file in bytes</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height of the image in pixels (e.g. 1080)</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width of the image in pixels (e.g. 1920)</p> <code>None</code> <code>thumbnail</code> <code>Optional[ImageAttachment]</code> <p>A thumbnail of the image. NOT a blurhash.</p> <code>None</code> <code>xyz_amorgan_blurhash</code> <code>Optional[str]</code> <p>The blurhash of the image</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>thumbnail</code> <p>A thumbnail of the image. NOT a blurhash.</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\n    file: Union[str, BytesIO, Path],\n    file_name: Optional[str] = None,\n    height: Optional[int] = None,\n    width: Optional[int] = None,\n    thumbnail: Union[\n        ImageAttachment, Literal[False]\n    ] = None,\n    generate_blurhash: bool = True,\n    *,\n    xyz_amorgan_blurhash: Optional[str] = None\n) -&gt; ImageAttachment\n</code></pre> <p>Generates an image attachment</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height, in pixels, of this image</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width, in pixels, of this image</p> <code>None</code> <code>thumbnail</code> <code>Union[ImageAttachment, Literal[False]]</code> <p>A thumbnail for this image</p> <code>None</code> <code>generate_blurhash</code> <code>bool</code> <p>Whether to generate a blurhash for this image</p> <code>True</code> <code>xyz_amorgan_blurhash</code> <code>Optional[str]</code> <p>The blurhash of the image, if known beforehand.</p> <code>None</code> <p>Returns:</p> Type Description <code>ImageAttachment</code> <p>An image attachment</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.generate_blur_hash","title":"generate_blur_hash  <code>staticmethod</code>","text":"<pre><code>generate_blur_hash(\n    file: Union[str, Path, BytesIO, Image],\n    parts: Tuple[int, int] = (4, 3),\n) -&gt; str\n</code></pre> <p>Creates a blurhash</p> <p>This function may be resource intensive</p> <p>This function may be resource intensive, especially for large images. You should run this in a thread or process pool.</p> <p>You should also scale any images down in order to increase performance.</p> <p>See: woltapp/blurhash</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.get_blurhash","title":"get_blurhash  <code>async</code>","text":"<pre><code>get_blurhash(\n    quality: Tuple[int, int] = (4, 3),\n    file: Optional[Union[str, Path, BytesIO, Image]] = None,\n    disable_auto_crop: bool = False,\n) -&gt; str\n</code></pre> <p>Gets the blurhash of the attachment. See: woltapp/blurhash</p> <p>Parameters:</p> Name Type Description Default <code>quality</code> <code>Tuple[int, int]</code> <p>A tuple of the quality to generate the blurhash at. Defaults to (4, 3).</p> <code>(4, 3)</code> <code>file</code> <code>Optional[Union[str, Path, BytesIO, Image]]</code> <p>The file to generate the blurhash from. Defaults to the file passed in the constructor.</p> <code>None</code> <code>disable_auto_crop</code> <code>bool</code> <p>Whether to disable automatic cropping of the image. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The blurhash</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.generate_thumbnail","title":"generate_thumbnail  <code>staticmethod</code>","text":"<pre><code>generate_thumbnail(\n    image: Union[Image, BytesIO, str, Path],\n    size: Tuple[int, int] = (320, 240),\n    resampling: Union[Resampling] = BICUBIC,\n) -&gt; Image\n</code></pre> <p>Generates a small thumbnail of a large image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Union[Image, BytesIO, str, Path]</code> <p>The image to generate a thumbnail of. Can be a PIL Image, BytesIO, or a path.</p> required <code>size</code> <code>Tuple[int, int]</code> <p>The size of the thumbnail to generate in width x height. Defaults to (320, 240).</p> <code>(320, 240)</code> <code>resampling</code> <code>Union[Resampling]</code> <p>The resampling algorithm to use. Defaults to <code>PIL.Image.Resampling.BICUBIC</code>.</p> <code>BICUBIC</code> <p>Returns:</p> Type Description <code>Image</code> <p>The generated PIL image object</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.get_metadata","title":"get_metadata  <code>async</code> <code>classmethod</code>","text":"<pre><code>get_metadata(\n    file: Union[str, BytesIO, Path],\n) -&gt; Dict[str, Any]\n</code></pre> <p>Gets metadata for an image.</p> <p>New in v1.3.0</p> <p>This function is new in v1.3.0. Additionally, unlike the previous way of fetching metadata, this function does NOT fall back to using imagemagick/ffmpeg. If you use a format too new, it may error.</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.set_thumbnail","title":"set_thumbnail","text":"<pre><code>set_thumbnail(thumbnail: ImageAttachment) -&gt; Self\n</code></pre> <p>Sets the thumbnail for this image attachment.</p> <p>Parameters:</p> Name Type Description Default <code>thumbnail</code> <code>ImageAttachment</code> <p>The thumbnail to set</p> required"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment","title":"VideoAttachment","text":"<p>               Bases: <code>BaseAttachment</code></p> <p>Represents a video attachment.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>Optional[int]</code> <p>The size of the file in bytes</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height of the video in pixels (e.g. 1080)</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width of the video in pixels (e.g. 1920)</p> <code>None</code> <code>duration</code> <code>Optional[int]</code> <p>The duration of the video in seconds</p> <code>None</code> <code>thumbnail</code> <code>Optional[ImageAttachment]</code> <p>A thumbnail of the video. NOT a blurhash.</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.generate_thumbnail","title":"generate_thumbnail  <code>async</code> <code>staticmethod</code>","text":"<pre><code>generate_thumbnail(\n    video: Union[str, Path, VideoAttachment],\n) -&gt; ImageAttachment\n</code></pre> <p>Generates a thumbnail for a video.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>Union[str, Path, VideoAttachment]</code> <p>The video to generate a thumbnail for</p> required <p>Returns:</p> Type Description <code>ImageAttachment</code> <p>The path to the generated thumbnail</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.get_metadata","title":"get_metadata  <code>async</code> <code>classmethod</code>","text":"<pre><code>get_metadata(file: Union[str, Path]) -&gt; Dict[str, Any]\n</code></pre> <p>Get metadata about a video file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>The video file to get metadata for</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The metadata</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.extract_first_frame","title":"extract_first_frame  <code>async</code> <code>staticmethod</code>","text":"<pre><code>extract_first_frame(\n    file: Union[str, Path], file_format: str = \"webp\"\n) -&gt; bytes\n</code></pre> <p>Gets the first frame of a video.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>The video file to get the first frame of</p> required <code>file_format</code> <code>str</code> <p>The format to save the first frame in. Defaults to WebP, which is a good choice.</p> <code>'webp'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The first frame</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\n    file: Union[str, BytesIO, Path],\n    file_name: Optional[str] = None,\n    duration: Optional[int] = None,\n    height: Optional[int] = None,\n    width: Optional[int] = None,\n    thumbnail: Optional[\n        Union[ImageAttachment, Literal[False]]\n    ] = None,\n    generate_blurhash: bool = True,\n) -&gt; VideoAttachment\n</code></pre> <p>Generates a video attachment</p> <p>This function auto-generates a thumbnail!</p> <p>As thumbnails greatly improve user experience, even with blurhashes enabled, this function will by default create a thumbnail of the first frame of the given video if you do not provide one yourself. This may increase your initialisation time by a couple seconds, give or take!</p> <p>If this is undesirable, pass <code>thumbnail=False</code> to disable generating a thumbnail. This is independent of <code>generate_blurhash</code>.</p> <p>Generated thumbnails are always WebP images, so they will always be miniature, so you shouldn't notice a significant increase in upload time, especially considering your video will likely be several megabytes.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>duration</code> <code>Optional[int]</code> <p>The duration of the video, in seconds</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height, in pixels, of this video</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width, in pixels, of this video</p> <code>None</code> <code>thumbnail</code> <code>Optional[Union[ImageAttachment, Literal[False]]]</code> <p>A thumbnail for this image</p> <code>None</code> <code>generate_blurhash</code> <code>bool</code> <p>Whether to generate a blurhash for this image</p> <code>True</code> <p>Returns:</p> Type Description <code>VideoAttachment</code> <p>An image attachment</p>"},{"location":"reference/attachment/#niobot.attachment.detect_mime_type","title":"detect_mime_type","text":"<pre><code>detect_mime_type(file: Union[str, BytesIO, Path]) -&gt; str\n</code></pre> <p>Detect the mime type of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to detect the mime type of. Can be a BytesIO.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The mime type of the file (e.g. <code>text/plain</code>, <code>image/png</code>, <code>application/pdf</code>, <code>video/webp</code> etc.)</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the <code>magic</code> library is not installed.</p> <code>TypeError</code> <p>If the file is not a string, BytesIO, or Path object.</p>"},{"location":"reference/attachment/#niobot.attachment.which","title":"which","text":"<pre><code>which(\n    file_: Union[BytesIO, Path, str],\n    mime_type: Optional[str] = None,\n) -&gt; Union[\n    Type[FileAttachment],\n    Type[ImageAttachment],\n    Type[AudioAttachment],\n    Type[VideoAttachment],\n]\n</code></pre> <p>Gets the correct attachment type for a file.</p> <p>This function will provide either Image/Video/Audio attachment where possible, or FileAttachment otherwise.</p> <p>For example, <code>image/png</code> (from <code>my_image.png</code>) will see <code>image/</code> and will return <code>ImageAttachment</code>, and <code>video/mp4</code> (from <code>my_video.mp4</code>) will see <code>video/</code> and will return <code>VideoAttachment</code>.</p> <p>If the mime type cannot be mapped to an attachment type, this function will return <code>FileAttachment</code>.</p> Usage <pre><code>import niobot\nimport pathlib\n\nmy_file = pathlib.Path(\"/tmp/foo.bar\")\nattachment = await niobot.which(my_file).from_file(my_file)\n# or\nattachment_type = niobot.which(my_file)  # one of the BaseAttachment subclasses\nattachment = await attachment_type.from_file(my_file)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file_</code> <code>Union[BytesIO, Path, str]</code> <p>The file or BytesIO to investigate</p> required <code>mime_type</code> <code>Optional[str]</code> <p>The optional pre-detected mime type. If this is not provided, it will be detected.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Type[FileAttachment], Type[ImageAttachment], Type[AudioAttachment], Type[VideoAttachment]]</code> <p>The correct type for this attachment (not instantiated)</p>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#niobot.client.NioBot","title":"NioBot","text":"<p>               Bases: <code>AsyncClient</code></p> <p>The main client for NioBot.</p> <p>Forcing an initial sync is slow</p> <p>(for the <code>force_initial_sync</code> parameter) By default, nio-bot stores what the last sync token was, and will resume from that next time it starts. This allows you to start up near instantly, and makes development easier and faster.</p> <p>However, in some cases, especially if you are missing some metadata such as rooms or their members, you may need to perform an initial (sometimes referred to as \"full\") sync. An initial sync will fetch ALL the data from the server, rather than just what has changed since the last sync.</p> <p>This initial sync can take several minutes, especially the larger your bot gets, and should only be used if you are missing aforementioned data that you need.</p> <p>Parameters:</p> Name Type Description Default <code>homeserver</code> <code>str</code> <p>The homeserver to connect to. e.g. https://matrix-client.matrix.org</p> required <code>user_id</code> <code>str</code> <p>The user ID to log in as. e.g. @user:matrix.org</p> required <code>device_id</code> <code>str</code> <p>The device ID to log in as. e.g. nio-bot</p> <code>'nio-bot'</code> <code>store_path</code> <code>Optional[str]</code> <p>The path to the store file. Defaults to ./store. Must be a directory.</p> <code>None</code> <code>command_prefix</code> <code>Union[str, Pattern, Iterable[str]]</code> <p>The prefix to use for commands. e.g. <code>!</code>. Can be a string, a list of strings, or a regex pattern.</p> required <code>case_insensitive</code> <code>bool</code> <p>Whether to ignore case when checking for commands. If True, this casefold()s incoming messages for parsing.</p> <code>True</code> <code>global_message_type</code> <code>Literal['m.text', 'm.notice']</code> <p>The message type to default to. Defaults to m.notice</p> <code>'m.notice'</code> <code>ignore_old_events</code> <code>bool</code> <p>Whether to simply discard events before the bot's login.</p> <code>True</code> <code>auto_join_rooms</code> <code>bool</code> <p>Whether to automatically join rooms the bot is invited to.</p> <code>True</code> <code>auto_read_messages</code> <code>bool</code> <p>Whether to automatically update read recipts</p> <code>True</code> <code>owner_id</code> <code>Optional[str]</code> <p>The user ID of the bot owner. If set, only this user can run owner-only commands, etc.</p> <code>None</code> <code>max_message_cache</code> <code>int</code> <p>The maximum number of messages to cache. Defaults to 1000.</p> <code>1000</code> <code>ignore_self</code> <code>bool</code> <p>Whether to ignore messages sent by the bot itself. Defaults to False. Useful for self-bots.</p> <code>True</code> <code>import_keys</code> <code>Tuple[PathLike, Optional[str]]</code> <p>A key export file and password tuple. These keys will be imported at startup.</p> <code>None</code> <code>startup_presence</code> <code>Literal['online', 'unavailable', 'offline', False, None]</code> <p>The presence to set on startup. <code>False</code> disables presence altogether, and <code>None</code> is automatic based on the startup progress.</p> <code>None</code> <code>default_parse_mentions</code> <code>bool</code> <p>Whether to parse mentions in send_message by default to make them intentional.</p> <code>True</code> <code>force_initial_sync</code> <code>bool</code> <p>Forcefully perform a full initial sync at startup.</p> <code>False</code> <code>use_fallback_replies</code> <p>Whether to force the usage of deprecated fallback replies. Not recommended outside of compatibility reasons.</p> required <code>onsite_state_resolution</code> <code>bool</code> <p>Whether to resolve state changes on-site. This is slower but more accurate.</p> <code>False</code> <code>process_message_edits</code> <code>bool</code> <p>Whether to process message edits as new messages and re-invoke any applicable commands. This behaves similar to maubot and is enabled by default. Disable if you don't want message edits to [re-]trigger commands.</p> <code>True</code>"},{"location":"reference/client/#niobot.client.NioBot._commands","title":"_commands  <code>instance-attribute</code>","text":"<pre><code>_commands: Dict[str, Command] = {}\n</code></pre> <p>Internal command register.</p>"},{"location":"reference/client/#niobot.client.NioBot._modules","title":"_modules  <code>instance-attribute</code>","text":"<pre><code>_modules: Dict[Type, Module] = {}\n</code></pre> <p>Internal module register.</p>"},{"location":"reference/client/#niobot.client.NioBot._events","title":"_events  <code>instance-attribute</code>","text":"<pre><code>_events: Dict[str, List[Union[FunctionType, Callable]]] = {}\n</code></pre> <p>Internal events register.</p>"},{"location":"reference/client/#niobot.client.NioBot.supported_server_versions","title":"supported_server_versions  <code>property</code>","text":"<pre><code>supported_server_versions: List[Tuple[int, int, int]]\n</code></pre> <p>Returns the supported server versions as a list of <code>major</code>, <code>minor</code>, <code>patch</code> tuples.</p> <p>The only time <code>patch</code> is &gt;0 is when the server is using a deprecated <code>r</code> release. All stable releases (<code>v1</code>) will have <code>patch</code> as 0.</p> <p>This property returns <code>[(1, 1, 0)]</code> if no server info is available.</p>"},{"location":"reference/client/#niobot.client.NioBot.commands","title":"commands  <code>property</code>","text":"<pre><code>commands: dict[str, Command]\n</code></pre> <p>Returns the internal command register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p> <p>Note</p> <p>Aliases of commands are treated as their own command instance. You will see the same command show up as a value multiple times if it has aliases.</p> <p>You can check if two commands are identical by comparing them (<code>command1instance == command2instance</code>)</p>"},{"location":"reference/client/#niobot.client.NioBot.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[Type, Module]\n</code></pre> <p>Returns the internal module register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p>"},{"location":"reference/client/#niobot.client.NioBot.server_supports","title":"server_supports","text":"<pre><code>server_supports(\n    version: Union[Tuple[int, int], Tuple[int, int, int]],\n) -&gt; bool\n</code></pre> <p>Checks that the server supports at least this matrix version.</p>"},{"location":"reference/client/#niobot.client.NioBot.mxc_to_http","title":"mxc_to_http  <code>async</code>","text":"<pre><code>mxc_to_http(\n    mxc: str, homeserver: Optional[str] = None\n) -&gt; Optional[str]\n</code></pre> <p>Converts an <code>mxc://</code> URI to a downloadable HTTP URL.</p> <p>This function is identical the nio.AsyncClient.mxc_to_http() function, however supports matrix 1.10 and below's unauthenticated media automatically.</p> <p>Parameters:</p> Name Type Description Default <code>mxc</code> <code>str</code> <p>The mxc URI</p> required <code>homeserver</code> <code>Optional[str]</code> <p>The homeserver to download this through (defaults to the bot's homeserver)</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>an MXC URL, if applicable</p>"},{"location":"reference/client/#niobot.client.NioBot._auto_join_room_callback","title":"_auto_join_room_callback  <code>async</code>","text":"<pre><code>_auto_join_room_callback(\n    room: MatrixRoom, event: InviteMemberEvent\n)\n</code></pre> <p>Callback for auto-joining rooms</p>"},{"location":"reference/client/#niobot.client.NioBot._auto_join_room_backlog_callback","title":"_auto_join_room_backlog_callback  <code>async</code>","text":"<pre><code>_auto_join_room_backlog_callback(\n    room: MatrixRoom, event: InviteMemberEvent\n)\n</code></pre> <p>Callback for auto-joining rooms that are backlogged on startup</p>"},{"location":"reference/client/#niobot.client.NioBot.global_command_check","title":"global_command_check  <code>async</code>","text":"<pre><code>global_command_check(ctx: Context) -&gt; bool\n</code></pre> <p>A global check that runs before every command.</p> <p>This is a no-op by default, but can be overridden to provide global checks. If this function returns False or raises an error, the check is considered failed, and the command will not run.</p>"},{"location":"reference/client/#niobot.client.NioBot.latency","title":"latency  <code>staticmethod</code>","text":"<pre><code>latency(\n    event: Event, *, received_at: Optional[float] = None\n) -&gt; float\n</code></pre> <p>Returns the latency for a given event in milliseconds</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event to measure latency with</p> required <code>received_at</code> <code>Optional[float]</code> <p>The optional time the event was received at. If not given, uses the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The latency in milliseconds</p>"},{"location":"reference/client/#niobot.client.NioBot.dispatch","title":"dispatch","text":"<pre><code>dispatch(event_name: Union[str, Event], *args, **kwargs)\n</code></pre> <p>Dispatches an event to listeners</p>"},{"location":"reference/client/#niobot.client.NioBot.is_old","title":"is_old","text":"<pre><code>is_old(event: Event) -&gt; bool\n</code></pre> <p>Checks if an event was sent before the bot started. Always returns False when ignore_old_events is False</p>"},{"location":"reference/client/#niobot.client.NioBot.update_read_receipts","title":"update_read_receipts  <code>async</code>","text":"<pre><code>update_read_receipts(\n    room: Union[str, MatrixRoom], event: Event\n)\n</code></pre> <p>Moves the read indicator to the given event in the room.</p> <p>This is automatically done for you.</p> <p>Whenever a message is received, this is automatically called for you. As such, your read receipt will always be the most recent message. You rarely need to call this function.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[str, MatrixRoom]</code> <p>The room to update the read receipt in.</p> required <code>event</code> <code>Event</code> <p>The event to move the read receipt to.</p> required <p>Returns:</p> Type Description <p>Nothing</p>"},{"location":"reference/client/#niobot.client.NioBot.process_message","title":"process_message  <code>async</code>","text":"<pre><code>process_message(\n    room: MatrixRoom, event: RoomMessage\n) -&gt; None\n</code></pre> <p>Processes a message and runs the command it is trying to invoke if any.</p>"},{"location":"reference/client/#niobot.client.NioBot.is_owner","title":"is_owner","text":"<pre><code>is_owner(user_id: str) -&gt; bool\n</code></pre> <p>Checks whether a user is the owner of the bot.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The user ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user is the owner.</p>"},{"location":"reference/client/#niobot.client.NioBot.mount_module","title":"mount_module","text":"<pre><code>mount_module(import_path: str) -&gt; Optional[list[Command]]\n</code></pre> <p>Mounts a module including all of its commands.</p> <p>Must be a subclass of niobot.commands.Module, or else this function will not work.</p> There may not be an event loop running when this function is called. <p>If you are calling this function before you call <code>bot.run()</code>, it is entirely possible that you don't have a running asyncio event loop. If you use the event loop in <code>Module.__init__</code>, you will get an error, and the module will fail the mount.</p> <p>You can get around this by deferring mounting your modules until the <code>ready</code> event is fired, at which point not only will the first full sync have completed (meaning the bot has all of its caches populated), but the event loop will be running.</p> <p>Parameters:</p> Name Type Description Default <code>import_path</code> <code>str</code> <p>The import path (such as modules.file), which would be ./modules/file.py in a file tree.</p> required <p>Returns:</p> Type Description <code>Optional[list[Command]]</code> <p>Optional[list[Command]] - A list of commands mounted. None if the module's setup() was called.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>The module path is incorrect of there was another error while importing</p> <code>TypeError</code> <p>The module was not a subclass of Module.</p> <code>ValueError</code> <p>There was an error registering a command (e.g. name conflict)</p>"},{"location":"reference/client/#niobot.client.NioBot.unmount_module","title":"unmount_module","text":"<pre><code>unmount_module(module: Module) -&gt; None\n</code></pre> <p>Does the opposite of mounting the module. This will remove any commands that have been added to the bot from the given module.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Module</code> <p>The module to unmount</p> required"},{"location":"reference/client/#niobot.client.NioBot.get_command","title":"get_command","text":"<pre><code>get_command(name: str) -&gt; Optional[Command]\n</code></pre> <p>Attempts to retrieve an internal command</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command to retrieve</p> required <p>Returns:</p> Type Description <code>Optional[Command]</code> <p>The command, if found. None otherwise.</p>"},{"location":"reference/client/#niobot.client.NioBot.add_command","title":"add_command","text":"<pre><code>add_command(command: Command) -&gt; None\n</code></pre> <p>Adds a command to the internal register</p> <p>if a name or alias is already registered, this throws a ValueError. Otherwise, it returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.remove_command","title":"remove_command","text":"<pre><code>remove_command(command: Command) -&gt; None\n</code></pre> <p>Removes a command from the internal register.</p> <p>If the command is not registered, this is a no-op.</p>"},{"location":"reference/client/#niobot.client.NioBot.command","title":"command","text":"<pre><code>command(name: Optional[str] = None, **kwargs)\n</code></pre> <p>Registers a command with the bot.</p>"},{"location":"reference/client/#niobot.client.NioBot.on_event","title":"on_event","text":"<pre><code>on_event(\n    event_type: Optional[Union[str, Type[Event]]] = None,\n)\n</code></pre> <p>Wrapper that allows you to register an event handler.</p> <p>Event handlers must be async.</p> <p>if event_type is None, the function name is used as the event type.</p> <p>Please note that if you pass a Event, you are responsible for capturing errors.</p>"},{"location":"reference/client/#niobot.client.NioBot.remove_event_listener","title":"remove_event_listener","text":"<pre><code>remove_event_listener(function)\n</code></pre> <p>Removes an event listener from the bot. Must be the exact function passed to add_event_listener.</p>"},{"location":"reference/client/#niobot.client.NioBot.set_room_nickname","title":"set_room_nickname  <code>async</code>","text":"<pre><code>set_room_nickname(\n    room: Union[str, MatrixRoom],\n    new_nickname: str = None,\n    user: Optional[Union[str, MatrixUser]] = None,\n) -&gt; RoomPutStateResponse\n</code></pre> <p>Changes the user's nickname in the given room.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[str, MatrixRoom]</code> <p>The room to change the nickname in.</p> required <code>new_nickname</code> <code>str</code> <p>The new nickname. If None, defaults to the user's display name.</p> <code>None</code> <code>user</code> <code>Optional[Union[str, MatrixUser]]</code> <p>The user to update. Defaults to the bot's user.</p> <code>None</code> <p>Returns:</p> Type Description <code>RoomPutStateResponse</code> <p>The response from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.get_cached_message","title":"get_cached_message","text":"<pre><code>get_cached_message(\n    event_id: str,\n) -&gt; Optional[Tuple[MatrixRoom, RoomMessage]]\n</code></pre> <p>Fetches a message from the cache.</p> <p>This returns both the room the message was sent in, and the event itself.</p> <p>If the message is not in the cache, this returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.fetch_message","title":"fetch_message  <code>async</code>","text":"<pre><code>fetch_message(room_id: str, event_id: str)\n</code></pre> <p>Fetches a message from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.wait_for_message","title":"wait_for_message  <code>async</code>","text":"<pre><code>wait_for_message(\n    room_id: Optional[str] = None,\n    sender: Optional[str] = None,\n    check: Optional[\n        Callable[[MatrixRoom, RoomMessageText], Any]\n    ] = None,\n    *,\n    timeout: Optional[float] = None,\n    msg_type: Type[RoomMessage] = RoomMessageText\n) -&gt; Optional[Tuple[MatrixRoom, RoomMessage]]\n</code></pre> <p>Alias for niobot.NioBot.wait_for_event with a message type filter.</p>"},{"location":"reference/client/#niobot.client.NioBot.wait_for_event","title":"wait_for_event  <code>async</code>","text":"<pre><code>wait_for_event(\n    event_type: Union[str, Type[Event]],\n    room_id: Optional[str] = None,\n    sender: Optional[str] = None,\n    check: Optional[\n        Callable[[MatrixRoom, RoomMessageText], Any]\n    ] = None,\n    *,\n    timeout: Optional[float] = None\n) -&gt; Optional[Tuple[MatrixRoom, RoomMessage]]\n</code></pre> <p>Waits for an event, optionally with a filter.</p> <p>If this function times out, asyncio.TimeoutError is raised.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>Union[str, Type[Event]]</code> <p>The type of event to wait for.</p> required <code>room_id</code> <code>Optional[str]</code> <p>The room ID to wait for a message in. If None, waits for any room.</p> <code>None</code> <code>sender</code> <code>Optional[str]</code> <p>The user ID to wait for a message from. If None, waits for any sender.</p> <code>None</code> <code>check</code> <code>Optional[Callable[[MatrixRoom, RoomMessageText], Any]]</code> <p>A function to check the message with. If the function returns False, the message is ignored.</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>The maximum time to wait for a message. If None, waits indefinitely.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Tuple[MatrixRoom, RoomMessage]]</code> <p>The room and message that was received.</p>"},{"location":"reference/client/#niobot.client.NioBot.markdown_to_html","title":"markdown_to_html  <code>async</code> <code>staticmethod</code>","text":"<pre><code>markdown_to_html(text: str) -&gt; str\n</code></pre> <p>Converts markdown to HTML.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The markdown to render as HTML</p> required <p>Returns:</p> Type Description <code>str</code> <p>the rendered HTML</p>"},{"location":"reference/client/#niobot.client.NioBot._get_id","title":"_get_id  <code>staticmethod</code>","text":"<pre><code>_get_id(\n    obj: Union[Event, MatrixRoom, MatrixUser, str, Any],\n) -&gt; str\n</code></pre> <p>Gets the id of most objects as a string.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Union[Event, MatrixRoom, MatrixUser, str, Any]</code> <p>The object whose ID to get, or the ID itself.</p> required <p>Returns:</p> Type Description <code>str</code> <p>the ID of the object</p>"},{"location":"reference/client/#niobot.client.NioBot.get_dm_rooms","title":"get_dm_rooms  <code>async</code>","text":"<pre><code>get_dm_rooms() -&gt; Dict[str, List[str]]\n</code></pre><pre><code>get_dm_rooms(user: Union[MatrixUser, str]) -&gt; List[str]\n</code></pre> <pre><code>get_dm_rooms(\n    user: Optional[Union[MatrixUser, str]] = None,\n) -&gt; Union[Dict[str, List[str]], List[str]]\n</code></pre> <p>Gets DM rooms, optionally for a specific user.</p> <p>If no user is given, this returns a dictionary of user IDs to lists of rooms.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Optional[Union[MatrixUser, str]]</code> <p>The user ID or object to get DM rooms for.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict[str, List[str]], List[str]]</code> <p>A dictionary of user IDs to lists of rooms, or a list of rooms.</p>"},{"location":"reference/client/#niobot.client.NioBot.create_dm_room","title":"create_dm_room  <code>async</code>","text":"<pre><code>create_dm_room(\n    user: Union[MatrixUser, str],\n) -&gt; RoomCreateResponse\n</code></pre> <p>Creates a DM room with a given user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[MatrixUser, str]</code> <p>The user to create a DM room with.</p> required <p>Returns:</p> Type Description <code>RoomCreateResponse</code> <p>The response from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(\n    room: Union[MatrixRoom, MatrixUser, str],\n    content: Optional[str] = None,\n    file: Optional[BaseAttachment] = None,\n    reply_to: Optional[Union[RoomMessage, str]] = None,\n    message_type: Optional[str] = None,\n    *,\n    content_type: Literal[\n        \"plain\", \"markdown\", \"html\", \"html.raw\"\n    ] = \"markdown\",\n    override: Optional[dict] = None,\n    mentions: Union[Mentions, Literal[False], None] = None\n) -&gt; RoomSendResponse\n</code></pre> <p>Sends a message. Doesn't get any more simple than this.</p> DMs <p>As of v1.1.0, you can now send messages to users (either a nio.MatrixUser or a user ID string), and a direct message room will automatically be created for you if one does not exist, using an existing one if it does.</p> <p>Content Type</p> <p>Separate to <code>message_type</code>, <code>content_type</code> controls what sort of parsing and formatting will be applied to the provided content. This is useful for sending messages that are not markdown, or for sending HTML. Before, all content was assumed to be markdown, and was parsed as such. However, this may cause undesirable effects if you are sending messages that are not markdown.</p> <ul> <li><code>plain</code> - No parsing or formatting is applied, and the content is sent as-is.</li> <li><code>markdown</code> - The content is parsed as markdown and rendered as HTML, with a fallback plain text body. This is the default.</li> <li><code>html</code> - The content is sent as HTML, with no fallback to plain text. If BeautifulSoup is installed, the provided content will be sanitised and pretty-printed before sending. ** <code>html.raw</code> - The content is sent as HTML, with no fallback to plain text, nor sanitising or formatting.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[MatrixRoom, MatrixUser, str]</code> <p>The room or to send this message to</p> required <code>content</code> <code>Optional[str]</code> <p>The content to send. Cannot be used with file.</p> <code>None</code> <code>file</code> <code>Optional[BaseAttachment]</code> <p>A file to send, if any. Cannot be used with content.</p> <code>None</code> <code>reply_to</code> <code>Optional[Union[RoomMessage, str]]</code> <p>A message to reply to.</p> <code>None</code> <code>message_type</code> <code>Optional[str]</code> <p>The message type to send. If none, defaults to NioBot.global_message_type, which itself is <code>m.notice</code> by default.</p> <code>None</code> <code>override</code> <code>Optional[dict]</code> <p>A dictionary containing additional properties to pass to the body. Overrides existing properties.</p> <code>None</code> <code>content_type</code> <code>Literal['plain', 'markdown', 'html', 'html.raw']</code> <p>The type of content to send. Defaults to \"markdown\".</p> <code>'markdown'</code> <code>mentions</code> <code>Union[Mentions, Literal[False], None]</code> <p>Intentional mentions to send with the message. If not provided, or <code>False</code>, then auto-detected.</p> <code>None</code> <p>Returns:</p> Type Description <code>RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to send, or if the file fails to upload.</p> <code>ValueError</code> <p>You specified neither file nor content.</p> <code>RuntimeError</code> <p>An internal error occured. A room was created, but is not in the bot room list.</p>"},{"location":"reference/client/#niobot.client.NioBot.edit_message","title":"edit_message  <code>async</code>","text":"<pre><code>edit_message(\n    room: Union[MatrixRoom, str],\n    message: Union[Event, str],\n    content: str,\n    *,\n    message_type: Optional[str] = None,\n    content_type: Literal[\n        \"plain\", \"markdown\", \"html\", \"html.raw\"\n    ] = \"markdown\",\n    mentions: Optional[Mentions] = None,\n    override: Optional[dict] = None\n) -&gt; RoomSendResponse\n</code></pre> <p>Edit an existing message. You must be the sender of the message.</p> <p>You also cannot edit messages that are attachments.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[MatrixRoom, str]</code> <p>The room the message is in.</p> required <code>message</code> <code>Union[Event, str]</code> <p>The message to edit.</p> required <code>content</code> <code>str</code> <p>The new content of the message.</p> required <code>message_type</code> <code>Optional[str]</code> <p>The new type of the message (i.e. m.text, m.notice. Defaults to client.global_message_type)</p> <code>None</code> <code>override</code> <code>Optional[dict]</code> <p>A dictionary containing additional properties to pass to the body. Overrides existing properties.</p> <code>None</code> <code>content_type</code> <code>Literal['plain', 'markdown', 'html', 'html.raw']</code> <p>The type of content to send. Defaults to \"markdown\".</p> <code>'markdown'</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>TypeError</code> <p>If the message is not text.</p>"},{"location":"reference/client/#niobot.client.NioBot.delete_message","title":"delete_message  <code>async</code>","text":"<pre><code>delete_message(\n    room: Union[MatrixRoom, str],\n    message_id: Union[RoomMessage, str],\n    reason: Optional[str] = None,\n) -&gt; RoomRedactResponse\n</code></pre> <p>Delete an existing message. You must be the sender of the message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[MatrixRoom, str]</code> <p>The room the message is in.</p> required <code>message_id</code> <code>Union[RoomMessage, str]</code> <p>The message to delete.</p> required <code>reason</code> <code>Optional[str]</code> <p>The reason for deleting the message.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>MessageException</code> <p>If the message fails to delete.</p>"},{"location":"reference/client/#niobot.client.NioBot.add_reaction","title":"add_reaction  <code>async</code>","text":"<pre><code>add_reaction(\n    room: Union[MatrixRoom, str],\n    message: Union[RoomMessage, str],\n    emoji: str,\n) -&gt; RoomSendResponse\n</code></pre> <p>Adds an emoji \"reaction\" to a message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[MatrixRoom, str]</code> <p>The room the message is in.</p> required <code>message</code> <code>Union[RoomMessage, str]</code> <p>The event ID or message object to react to.</p> required <code>emoji</code> <code>str</code> <p>The emoji to react with (e.g. <code>\u274c</code> = \u274c)</p> required <p>Returns:</p> Type Description <code>RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to react.</p>"},{"location":"reference/client/#niobot.client.NioBot.redact_reaction","title":"redact_reaction  <code>async</code>","text":"<pre><code>redact_reaction(\n    room: Union[MatrixRoom, str],\n    reaction: Union[RoomSendResponse, str],\n)\n</code></pre> <p>Alias for NioBot.delete_message, but more appropriately named for reactions.</p>"},{"location":"reference/client/#niobot.client.NioBot.start","title":"start  <code>async</code>","text":"<pre><code>start(\n    password: Optional[str] = None,\n    access_token: Optional[str] = None,\n    sso_token: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Starts the bot, running the sync loop.</p>"},{"location":"reference/client/#niobot.client.NioBot.run","title":"run","text":"<pre><code>run(\n    *,\n    password: Optional[str] = None,\n    access_token: Optional[str] = None,\n    sso_token: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Runs the bot, blocking the program until the event loop exists. This should be the last function to be called in your script, as once it exits, the bot will stop running.</p> <p>Note:     This function is literally just asyncio.run(NioBot.start(...)), so you won't have much control over the     asyncio event loop. If you want more control, you should use await NioBot.start(...) instead.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>Optional[str]</code> <p>The password to log in with.</p> <code>None</code> <code>access_token</code> <code>Optional[str]</code> <p>An existing login token.</p> <code>None</code> <code>sso_token</code> <code>Optional[str]</code> <p>An SSO token to sign in with.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/client/#niobot.client.NioBot._resolve_room_or_user_id","title":"_resolve_room_or_user_id  <code>async</code>","text":"<pre><code>_resolve_room_or_user_id(\n    target: Union[MatrixUser, MatrixRoom, str],\n) -&gt; str\n</code></pre> <p>Returns either a user ID (@example:example.example) or room ID (!123ABC:example.example)</p>"},{"location":"reference/client/#niobot.client.NioBot.get_account_data","title":"get_account_data  <code>async</code>","text":"<pre><code>get_account_data(\n    key: str, *, room_id: str = None\n) -&gt; Union[dict, list, None]\n</code></pre> <p>Gets account data for the currently logged in account</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key to get</p> required <code>room_id</code> <code>str</code> <p>The room ID to get account data from. If not provided, defaults to user-level.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[dict, list, None]</code> <p>The account data, or None if it doesn't exist</p>"},{"location":"reference/client/#niobot.client.NioBot.set_account_data","title":"set_account_data  <code>async</code>","text":"<pre><code>set_account_data(\n    key: str, data: dict, *, room_id: str = None\n) -&gt; None\n</code></pre> <p>Sets account data for the currently logged in account</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>the key to set</p> required <code>data</code> <code>dict</code> <p>the data to set</p> required <code>room_id</code> <code>str</code> <p>The room ID to set account data in. If not provided, defaults to user-level.</p> <code>None</code>"},{"location":"reference/client/#niobot.client.NioBot.join","title":"join  <code>async</code>","text":"<pre><code>join(\n    room_id: str, reason: str = None, is_dm: bool = False\n) -&gt; Union[JoinResponse, JoinError]\n</code></pre> <p>Joins a room. room_id must be a room ID, not alias</p> <p>Parameters:</p> Name Type Description Default <code>room_id</code> <code>str</code> <p>The room ID or alias to join</p> required <code>reason</code> <code>str</code> <p>The reason for joining the room, if any</p> <code>None</code> <code>is_dm</code> <code>bool</code> <p>Manually marks this room as a direct message.</p> <code>False</code>"},{"location":"reference/client/#niobot.client.NioBot.room_leave","title":"room_leave  <code>async</code>","text":"<pre><code>room_leave(\n    room_id: str, reason: str = None, *, forget: bool = True\n) -&gt; Union[RoomLeaveError, RoomLeaveResponse]\n</code></pre> <p>Leaves a room. room_id must be an ID, not alias</p>"},{"location":"reference/client/#niobot.client.SimpleNioBot","title":"SimpleNioBot","text":"<p>               Bases: <code>NioBot</code></p> <p>A subclass of [NioBot][] that provides a simpler interface to NioBot.</p> <p>This class is meant to be a bridge between simplicity and customisability.</p>"},{"location":"reference/commands/","title":"Commands","text":"<p>Using commands and events is the main way to interact with the bot.</p>"},{"location":"reference/commands/#command-argument-detection","title":"Command argument detection","text":"<p>One of the most powerful features of NioBot is the command argument interpretation system. When you create a niobot command, the arguments are automatically detected, and their desired type is inferred from the type hints in the function signature.</p> <p>This means that <code>foo: str</code> will always give you a string, <code>bar: int</code> will try to give you an integer, or throw an error if it cannot convert the user-given argument.</p> <p>As of v1.2.0, you can take advantage of the keyword-only and positional args in Python. Normally, when you specify a function like <code>async def mycommand(ctx, x: str)</code>, niobot will see that you want an argument, x, and will do just that. It will take the user's input, and give you the value for x. However, if the user specifies multiple words for <code>x</code>, it will only give the first one to the function, unless the user warps the argument in \"quotes\".</p> <p><pre><code>import niobot\nbot = niobot.NioBot()\n\n@bot.command()\nasync def mycommand(ctx, x: str):\n    await ctx.respond(f\"Your argument was: {x}\")\n</code></pre> If you ran <code>!mycommand hello world</code>, the bot would respond with <code>Your argument was: hello</code>.</p> <p>With keyword-only arguments, you can make use of \"greedy\" arguments. While you could previously do this by manually constructing the niobot.Argument type, you can now do this with the <code>*</code> syntax in Python.</p> <p><pre><code>import niobot\nbot = niobot.NioBot()\n\n@bot.command()\nasync def mycommand(ctx, *, x: str):\n    await ctx.respond(f\"Your argument was: {x}\")\n</code></pre> If you ran <code>!mycommand hello world</code>, the bot would respond with <code>Your argument was: hello world</code>.</p> <p>And, as for positional args, if you want to fetch a set of arguments, you can do so by specifying <code>*args</code>. This will give you a tuple containing every whitespace-delimited argument after the command.</p> <p><pre><code>import niobot\nbot = niobot.NioBot()\n\n@bot.command()\nasync def mycommand(ctx, *args: str):\n    await ctx.respond(f\"Your arguments were: {args}\")\n</code></pre> If you ran <code>!mycommand hello world</code>, the bot would respond with <code>Your arguments were: ('hello', 'world')</code>.</p> <p>Position &amp; KW-Only args are final and strings!</p> <p>If you specify a keyword or positional argument, you cannot have any arguments afterwards. Furthermore, (currently) both of these arguments are always strings. Trying to specify another type will throw an error.</p>"},{"location":"reference/commands/#reference","title":"Reference","text":""},{"location":"reference/commands/#niobot.commands.Argument","title":"Argument","text":"<p>Represents a command argument.</p> Example <pre><code>from niobot import NioBot, command, Argument\n\nbot = NioBot(...)\n\n@bot.command(\"echo\")\ndef echo(ctx: niobot.Context, message: str):\n    await ctx.respond(message)\n\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument. Will be used to know which argument to pass to the command callback.</p> required <code>arg_type</code> <code>_T</code> <p>The type of the argument (e.g. str, int, etc. or a custom type)</p> required <code>description</code> <code>Optional[str]</code> <p>The description of the argument. Will be shown in the auto-generated help command.</p> <code>None</code> <code>default</code> <code>Any</code> <p>The default value of the argument</p> <code>...</code> <code>required</code> <code>bool</code> <p>Whether the argument is required or not. Defaults to True if default is ..., False otherwise.</p> <code>...</code> <code>parser</code> <code>Callable[[Context, Argument, str], Optional[_T]]</code> <p>A function that will parse the argument. Defaults to the default parser.</p> <code>...</code> <code>greedy</code> <code>bool</code> <p>When enabled, will attempt to match as many arguments as possible, without raising an error. If no arguments can be parsed, is merely empty, otherwise is a list of parsed arguments.</p> <code>False</code>"},{"location":"reference/commands/#niobot.commands.Argument.internal_parser","title":"internal_parser  <code>staticmethod</code>","text":"<pre><code>internal_parser(\n    _: Context, arg: Argument, value: str\n) -&gt; Optional[_T]\n</code></pre> <p>The default parser for the argument. Will try to convert the value to the argument type.</p>"},{"location":"reference/commands/#niobot.commands.Command","title":"Command","text":"<p>Represents a command.</p> Example <p>Note</p> <p>This example uses the <code>command</code> decorator, but you can also use the <code>Command</code> class directly, but you likely won't need to, unless you want to pass a custom command class.</p> <p>All that the <code>@command</code> decorator does is create a <code>Command</code> instance and add it to the bot's commands, while wrapping the function its decorating.</p> <pre><code>from niobot import NioBot, command\n\nbot = NioBot(...)\n\n@bot.command(\"hello\")\ndef hello(ctx: niobot.Context):\n    await ctx.respond(\"Hello, %s!\" % ctx.message.sender)\n\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Will be used to invoke the command.</p> required <code>callback</code> <code>Callable</code> <p>The callback to call when the command is invoked.</p> required <code>aliases</code> <code>Optional[list[str]]</code> <p>The aliases of the command. Will also be used to invoke the command.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description of the command. Will be shown in the auto-generated help command.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the command is disabled or not. If disabled, the command will be hidden on the auto-generated help command, and will not be able to be invoked.</p> <code>False</code> <code>arguments</code> <code>Optional[list[Argument]]</code> <p>A list of <code>Argument</code> instances. Will be used to parse the arguments given to the command. <code>ctx</code> is always the first argument, regardless of what you put here.</p> <code>None</code> <code>usage</code> <code>Optional[str]</code> <p>A string representing how to use this command's arguments. Will be shown in the auto-generated help. Do not include the command name or your bot's prefix here, only arguments. For example: <code>usage=\"&lt;message&gt; [times]\"</code> will show up as <code>[p][command] &lt;message&gt; [times]</code> in the help command.</p> <code>None</code> <code>hidden</code> <code>bool</code> <p>Whether the command is hidden or not. If hidden, the command will be always hidden on the auto-generated help.</p> <code>False</code> <code>greedy</code> <code>bool</code> <p>When enabled, <code>CommandArgumentsError</code> will not be raised if too many arguments are given to the command. This is useful for commands that take a variable amount of arguments, and retrieve them via <code>Context.args</code>.</p> <code>False</code>"},{"location":"reference/commands/#niobot.commands.Command.display_usage","title":"display_usage  <code>property</code>","text":"<pre><code>display_usage: str\n</code></pre> <p>Returns the usage string for this command, auto-resolved if not pre-defined</p>"},{"location":"reference/commands/#niobot.commands.Command.autodetect_args","title":"autodetect_args  <code>classmethod</code>","text":"<pre><code>autodetect_args(callback) -&gt; List[Argument]\n</code></pre> <p>Attempts to automatically detect arguments, their types, and their default values for the command, based on the function signature.</p> <p>This is usually quite reliable, however, also quite inflexible. If you need more control over the arguments, consider manually passing them to the Command constructor.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <p>The function to inspect</p> required <p>Returns:</p> Type Description <code>List[Argument]</code> <p>A list of arguments. <code>self</code>, and <code>ctx</code> are skipped.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the parameter kind is not supported, or there was another issue with introspection.</p> <code>ValueError</code> <p>If there are multiple greedy arguments in the command.</p>"},{"location":"reference/commands/#niobot.commands.Command.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if another command's runtime ID is the same as this one's</p>"},{"location":"reference/commands/#niobot.commands.Command.can_run","title":"can_run  <code>async</code>","text":"<pre><code>can_run(ctx: Context) -&gt; bool\n</code></pre> <p>Checks if the current user passes all the checks on the command.</p> <p>If the user fails a check, CheckFailure is raised. Otherwise, True is returned.</p>"},{"location":"reference/commands/#niobot.commands.Command.parse_args","title":"parse_args  <code>async</code>","text":"<pre><code>parse_args(\n    ctx: Context,\n) -&gt; Dict[Argument, Union[Any, List[Any]]]\n</code></pre> <p>Parses the arguments for the current command.</p>"},{"location":"reference/commands/#niobot.commands.Command.invoke","title":"invoke  <code>async</code>","text":"<pre><code>invoke(ctx: Context) -&gt; Coroutine\n</code></pre> <p>Invokes the current command with the given context</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The current context</p> required <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>Too many/few arguments, or an error parsing an argument.</p> <code>CheckFailure</code> <p>A check failed</p>"},{"location":"reference/commands/#niobot.commands.Command.construct_context","title":"construct_context","text":"<pre><code>construct_context(\n    client: NioBot,\n    room: MatrixRoom,\n    src_event: RoomMessageText,\n    invoking_prefix: str,\n    meta: str,\n    cls: type = Context,\n) -&gt; Context\n</code></pre> <p>Constructs the context for the current command.</p> <p>You will rarely need to do this, the library automatically gives you a Context when a command is run.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The current instance of the client.</p> required <code>room</code> <code>MatrixRoom</code> <p>The room the command was invoked in.</p> required <code>src_event</code> <code>RoomMessageText</code> <p>The source event that triggered the command. Must be <code>nio.RoomMessageText</code>.</p> required <code>invoking_prefix</code> <code>str</code> <p>The prefix that triggered the command.</p> required <code>meta</code> <code>str</code> <p>The invoking string (usually the command name, however may be an alias instead)</p> required <code>cls</code> <code>type</code> <p>The class to construct the context with. Defaults to <code>Context</code>.</p> <code>Context</code> <p>Returns:</p> Type Description <code>Context</code> <p>The constructed Context.</p>"},{"location":"reference/commands/#niobot.commands.Module","title":"Module","text":"<p>Represents a module.</p> <p>A module houses a set of commands and events, and can be used to modularise your bot, and organise commands and their respective code into multiple files and classes for ease of use, development, and maintenance.</p> <p>Attributes:</p> Name Type Description <code>bot</code> <p>The bot instance this module is mounted to.</p>"},{"location":"reference/commands/#niobot.commands.Module.list_events","title":"list_events","text":"<pre><code>list_events() -&gt; Generator[dict, None, None]\n</code></pre> <p>Lists all the @event listeners registered in this module.</p> <p>This returns the functions themselves. You can get the event name via <code>result.__nio_event__[\"name\"]</code>.</p>"},{"location":"reference/commands/#niobot.commands.Module.__setup__","title":"__setup__","text":"<pre><code>__setup__()\n</code></pre> <p>Setup function called once by NioBot.mount_module(). Mounts every command discovered.</p> <p>.. warning:     If you override this function, you should ensure that you call super().setup() to ensure that     commands are properly registered.</p>"},{"location":"reference/commands/#niobot.commands.Module.__teardown__","title":"__teardown__","text":"<pre><code>__teardown__()\n</code></pre> <p>Teardown function called once by NioBot.unmount_module(). Removes any command that was mounted.</p> <p>.. warning:     If you override this function, you should ensure that you call super().teardown() to ensure that     commands are properly unregistered.</p>"},{"location":"reference/commands/#niobot.commands.command","title":"command","text":"<pre><code>command(name: Optional[str] = None, **kwargs) -&gt; Callable\n</code></pre> <p>Allows you to register commands later on, by loading modules.</p> <p>This differs from NioBot.command() in that commands are not automatically added, you need to load them with bot.mount_module</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the command. Defaults to function.name</p> <code>None</code> <code>kwargs</code> <p>Any key-words to pass to Command</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable</code>"},{"location":"reference/commands/#niobot.commands.check","title":"check","text":"<pre><code>check(\n    function: Callable[\n        [Context], Union[bool, Coroutine[None, None, bool]]\n    ],\n) -&gt; Callable\n</code></pre> <p>Allows you to register checks in modules.</p> <pre><code>@niobot.command()\n@niobot.check(my_check_func)\nasync def my_command(ctx: niobot.Context):\n    pass\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[Context], Union[bool, Coroutine[None, None, bool]]]</code> <p>The function to register as a check</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function.</p>"},{"location":"reference/commands/#niobot.commands.event","title":"event","text":"<pre><code>event(\n    name: Optional[Union[str, Type[Event]]] = None,\n) -&gt; Callable\n</code></pre> <p>Allows you to register event listeners in modules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[Union[str, Type[Event]]]</code> <p>the name of the event (no <code>on_</code> prefix)</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code>"},{"location":"reference/context/","title":"Context","text":"<p>For each command invoked, the first argument is always a <code>Context</code> instance, which holds a lot of metadata, and a few utility functions to help you write commands.</p> <p>A lot of the time, these are the three main attributes you'll be using:</p> <ul> <li><code>Context.room</code> (<code>nio.MatrixRoom</code>) - the room the command was invoked in.</li> <li><code>Context.message</code> (<code>nio.RoomMessageText</code>) - the message that invoked this command.</li> <li><code>Context.respond</code> - a utility class to help you respond to the command.</li> </ul>"},{"location":"reference/context/#command-context","title":"Command Context","text":"<p>Event-based context for a command callback</p>"},{"location":"reference/context/#niobot.context.Context.room","title":"room  <code>property</code>","text":"<pre><code>room: MatrixRoom\n</code></pre> <p>The room that the event was dispatched in</p>"},{"location":"reference/context/#niobot.context.Context.client","title":"client  <code>property</code>","text":"<pre><code>client: NioBot\n</code></pre> <p>The current instance of the client</p>"},{"location":"reference/context/#niobot.context.Context.command","title":"command  <code>property</code>","text":"<pre><code>command: Command\n</code></pre> <p>The current command being invoked</p>"},{"location":"reference/context/#niobot.context.Context.args","title":"args  <code>property</code>","text":"<pre><code>args: list[str]\n</code></pre> <p>Each argument given to this command</p>"},{"location":"reference/context/#niobot.context.Context.message","title":"message  <code>property</code>","text":"<pre><code>message: RoomMessageText\n</code></pre> <p>The current message</p>"},{"location":"reference/context/#niobot.context.Context.original_response","title":"original_response  <code>property</code>","text":"<pre><code>original_response: Optional[RoomSendResponse]\n</code></pre> <p>The result of Context.reply(), if it exists.</p>"},{"location":"reference/context/#niobot.context.Context.latency","title":"latency  <code>property</code>","text":"<pre><code>latency: float\n</code></pre> <p>Returns the current event's latency in milliseconds.</p>"},{"location":"reference/context/#niobot.context.Context.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(*args, **kwargs) -&gt; ContextualResponse\n</code></pre> <p>Responds to the current event.</p> <p>See niobot.NioBot.send_message for more information.</p>"},{"location":"reference/context/#contextual-response","title":"Contextual Response","text":"<p>Context class for managing replies.</p> <p>Usage of this function is not required, however it is a useful utility.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.original_event","title":"original_event  <code>async</code>","text":"<pre><code>original_event() -&gt; Optional[RoomMessage]\n</code></pre> <p>Fetches the current event for this response</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.reply","title":"reply  <code>async</code>","text":"<pre><code>reply(*args, **kwargs) -&gt; ContextualResponse\n</code></pre> <p>Replies to the current response.</p> <p>This does NOT reply to the original invoking message.</p> <p>See niobot.NioBot.send_message for more information. You do not need to provide the room.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(*args, **kwargs) -&gt; Self\n</code></pre> <p>Edits the current response.</p> <p>See niobot.NioBot.edit_message for more information. You do not need to provide the room or event_id.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(reason: Optional[str] = None) -&gt; None\n</code></pre> <p>Redacts the current response.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Optional[str]</code> <p>An optional reason for the redaction</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None, as there will be no more response.</p>"},{"location":"reference/events/","title":"Event Reference","text":""},{"location":"reference/events/#a-little-note-about-event-names","title":"A little note about event names","text":"<p>Event names are never prefixed with <code>on_</code>, so make sure you're listening to events like <code>message</code>, not <code>on_message</code>!</p> <p>While trying to listen for an <code>on_</code> prefixed event will still work, it will throw warnings in the console, and may be deprecated in the future.</p>"},{"location":"reference/events/#niobot-specific-events","title":"NioBot-specific events","text":"<p>There are two types of events in niobot: those that are dispatched by niobot itself, and those that're dispatched by <code>matrix-nio</code>. In order to keep backwards compatability, as well as high flexibility and extensibility, niobot's NioBot class actually subclasses nio.AsyncClient. This means that anything you can do with <code>matrix-nio</code>, you can do with niobot.</p> <p>However, for simplicity, niobot dispatches its own events independently of <code>matrix-nio</code>. These events are listed below.</p> <p>You can listen to these events with niobot.NioBot.on_event.</p> Example <pre><code>import niobot\n\nbot = niobot.NioBot(...)\n\n\n@bot.on_event(\"ready\")\nasync def on_ready(result):\n    print(\"Bot is ready!\")\n    print(\"Logged in as:\", bot.user_id)\n\n\nbot.run(...)\n</code></pre>"},{"location":"reference/events/#niobot._event_stubs.event_loop_running","title":"event_loop_running  <code>async</code>","text":"<pre><code>event_loop_running() -&gt; Optional[Any]\n</code></pre> <p>An event that is fired once the event loop is running.</p> <p>You should use this event to perform any startup tasks.</p> <p>This event is fired before the bot logs in, and before the first <code>sync()</code> is performed.</p> <p>This means that if, for example, you wanted to initialise a database, or make some HTTP request in a module, You can @[nio]bot.event(\"event_loop_running\") do it here.</p> Initialising a database in a module <pre><code>import niobot\nimport aiosqlite\n\nclass MyModule(niobot.Module):\n    def __init__(self, bot):\n        super().__init__(bot)\n        self.db = None\n\n    @niobot.event(\"event_loop_running\")\n    async def event_loop_running(self):\n        self.db = await aiosqlite.connect(\"mydb.db\")\n        await self.db.execute(...)\n        await self.db.commit\n</code></pre>"},{"location":"reference/events/#niobot._event_stubs.ready","title":"ready  <code>async</code>","text":"<pre><code>ready(result: SyncResponse) -&gt; Optional[Any]\n</code></pre> <p>An event that is fired when the bot's first <code>sync()</code> is completed.</p> <p>This indicates that the bot successfully logged in, synchronised with the server, and is ready to receive events.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>SyncResponse</code> <p>The response from the sync.</p> required"},{"location":"reference/events/#niobot._event_stubs.message","title":"message  <code>async</code>","text":"<pre><code>message(\n    room: MatrixRoom, event: RoomMessage\n) -&gt; Optional[Any]\n</code></pre> <p>An event that is fired when the bot receives a message in a room that it is in.</p> <p>This event is dispatched before commands are processed, and as such the convenient niobot.Context is unavailable.</p> <p>Not every message is a text message</p> <p>As of v1.2.0, the <code>message</code> event is dispatched for every decrypted message type, as such including videos, images, audio, and text. Prior for v1.2.0, this was only dispatched for text messages.</p> <p>Please check either the type of the event (i.e. <code>isinstance(event, niobot.RoomMessageText)</code>) or the <code>event.source[\"content\"][\"msgtype\"]</code> to determine the type of the message.</p> <p>Tip</p> <p>If you want to be able to use the niobot.Context in your event handlers, you should use the <code>command</code> event instead.</p> <p>Furthermore, if you want more fine-grained control over how commands are parsed and handled, you should override niobot.NioBot.process_message instead of using the <code>message</code> event.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>MatrixRoom</code> <p>The room that the message was received in.</p> required <code>event</code> <code>RoomMessage</code> <p>The raw event that triggered the message.</p> required"},{"location":"reference/events/#niobot._event_stubs.command","title":"command  <code>async</code>","text":"<pre><code>command(ctx: Context) -&gt; Optional[Any]\n</code></pre> <p>This event is dispatched once a command is finished being prepared, and is about to be invoked.</p> <p>This event is dispatched after the <code>message</code> event, but before <code>command_complete</code> and <code>command_error</code>.</p> <p>This event features the original context, which can be used to access the message, the command, and the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context of the command.</p> required"},{"location":"reference/events/#niobot._event_stubs.command_complete","title":"command_complete  <code>async</code>","text":"<pre><code>command_complete(\n    ctx: Context, result: Any\n) -&gt; Optional[Any]\n</code></pre> <p>This event is dispatched after a command has been invoked, and has completed successfully.</p> <p>This event features the context, which can be used to access the message, the command, and the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context of the command.</p> required <code>result</code> <code>Any</code> <p>The result of the command (the returned value of the callback)</p> required"},{"location":"reference/events/#niobot._event_stubs.command_error","title":"command_error  <code>async</code>","text":"<pre><code>command_error(\n    ctx: Context, error: CommandError\n) -&gt; Optional[Any]\n</code></pre> <p>This event is dispatched after a command has been invoked, and has completed with an error.</p> <p>This event features the context, which can be used to access the message, the command, and the arguments.</p> Getting the original error <p>As the error is wrapped in a niobot.CommandError, you can access the original error by accessing the <code>CommandError.original</code> attribute.</p> <pre><code>@bot.event(\"command_error\")\nasync def on_command_error(ctx, error):\n    original_error = error.original\n    print(\"Error:\", original_error)\n</code></pre> <p>It is encouraged that you inform the end user about an error that has occurred, as by default the error is simply logged to the console. Don't forget, you've got the whole <code>Context</code> instance - use it!</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context of the command.</p> required <code>error</code> <code>CommandError</code> <p>The error that was raised.</p> required"},{"location":"reference/events/#niobot._event_stubs.raw","title":"raw  <code>async</code>","text":"<pre><code>raw(room: MatrixRoom, event: Event) -&gt; Optional[Any]\n</code></pre> <p>This is a special event that is handled when you directly pass a <code>niobot.Event</code> to <code>on_event</code>.</p> <p>You cannot listen to this in the traditional sense of \"on_event('name')\" as it is not a named event. But, this extensibility allows you to listen directly for events not covered by the library.</p> Example <p>The below code will listen directly for the redaction event and will print out the redaction details.</p> <p>See the nio events documentation for more details and a list of available events.x</p> <pre><code>import niobot\n\n@bot.on_event(niobot.RedactionEvent)  # listen for redactions\nasync def on_redaction(room, event):\n    print(f\"{event.sender} redacted {event.redacts} for {event.reason!r} in {room.display_name}\")\n</code></pre>"},{"location":"reference/events/#matrix-nio-events","title":"<code>matrix-nio</code> events","text":"<p>See the <code>matrix-nio</code> documentation for the base-library set of events.</p> <p>Remember, you'll need to use nio.Client.add_event_callback in order to listen to these!</p> <p>New in v1.2.0</p> <p>You can now listen to <code>matrix-nio</code> events with niobot.NioBot.on_event! Just pass the raw event type to the decorator, rather than a string.</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#niobot.exceptions.NioBotException","title":"NioBotException","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for NioBot.</p> <p>Warning</p> <p>In some rare cases, all of <code>exception</code>, <code>response</code> and <code>original</code> may be None.</p> <p>All other exceptions raised by this library will subclass this exception, so at least all the below are always available:</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>Optional[str]</code> <p>A simple humanised explanation of the issue, if available.</p> <code>response</code> <code>Optional[ErrorResponse]</code> <p>The response object from the server, if available.</p> <code>exception</code> <code>Optional[Union[ErrorResponse, BaseException]]</code> <p>The exception that was raised, if available.</p> <code>original</code> <code>Union[ErrorResponse, BaseException, None]</code> <p>The original response, or exception if response was not available.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.bottom_of_chain","title":"bottom_of_chain","text":"<pre><code>bottom_of_chain(\n    other: Optional[Union[Exception, ErrorResponse]] = None,\n) -&gt; Union[BaseException, ErrorResponse]\n</code></pre> <p>Recursively checks the <code>original</code> attribute of the exception until it reaches the bottom of the chain.</p> <p>This function finds you the absolute first exception that was raised.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[Union[Exception, ErrorResponse]]</code> <p>The other exception to recurse down. If None, defaults to the exception this method is called on.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[BaseException, ErrorResponse]</code> <p>The bottom of the chain exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a human-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Returns a developer-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.GenericMatrixError","title":"GenericMatrixError","text":"<p>               Bases: <code>NioBotException</code></p> <p>Exception for generic matrix errors where a valid response was expected, but got an ErrorResponse instead.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MessageException","title":"MessageException","text":"<p>               Bases: <code>NioBotException</code></p> <p>Exception for message-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.LoginException","title":"LoginException","text":"<p>               Bases: <code>NioBotException</code></p> <p>Exception for login-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaException","title":"MediaException","text":"<p>               Bases: <code>MessageException</code></p> <p>Exception for media-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaUploadException","title":"MediaUploadException","text":"<p>               Bases: <code>MediaException</code></p> <p>Exception for media-uploading related errors</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaDownloadException","title":"MediaDownloadException","text":"<p>               Bases: <code>MediaException</code></p> <p>Exception for media-downloading related errors</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaCodecWarning","title":"MediaCodecWarning","text":"<p>               Bases: <code>ResourceWarning</code></p> <p>Warning that is dispatched when a media file is not in a supported codec.</p> <p>You can filter this warning by using <code>warnings.filterwarnings(\"ignore\", category=niobot.MediaCodecWarning)</code></p> <p>Often times, matrix clients are web-based, so they're limited to what the browser can display. This is usually:</p> <ul> <li>h264/vp8/vp9/av1/theora video</li> <li>aac/opus/vorbis/mp3/pcm_* audio</li> <li>jpg/png/webp/avif/gif images</li> </ul>"},{"location":"reference/exceptions/#niobot.exceptions.MetadataDetectionException","title":"MetadataDetectionException","text":"<p>               Bases: <code>MediaException</code></p> <p>Exception raised when metadata detection fails. Most of the time, this is an ffmpeg-related error</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandError","title":"CommandError","text":"<p>               Bases: <code>NioBotException</code></p> <p>Exception subclass for all command invocation related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandNotFoundError","title":"CommandNotFoundError","text":"<p>               Bases: <code>CommandError</code></p> <p>Exception raised when a command is not found.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandPreparationError","title":"CommandPreparationError","text":"<p>               Bases: <code>CommandError</code></p> <p>Exception subclass for errors raised while preparing a command for execution.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandDisabledError","title":"CommandDisabledError","text":"<p>               Bases: <code>CommandPreparationError</code></p> <p>Exception raised when a command is disabled.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandArgumentsError","title":"CommandArgumentsError","text":"<p>               Bases: <code>CommandPreparationError</code></p> <p>Exception subclass for command argument related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandParserError","title":"CommandParserError","text":"<p>               Bases: <code>CommandArgumentsError</code></p> <p>Exception raised when there is an error parsing arguments.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CheckFailure","title":"CheckFailure","text":"<p>               Bases: <code>CommandPreparationError</code></p> <p>Exception raised when a generic check call fails.</p> <p>You should prefer one of the subclass errors over this generic one, or a custom subclass.</p> <p><code>CheckFailure</code> is often raised by the built-in checker when a check returns a falsy value without raising an error.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NotOwner","title":"NotOwner","text":"<p>               Bases: <code>CheckFailure</code></p> <p>Exception raised when the command invoker is not the owner of the bot.</p>"},{"location":"reference/exceptions/#niobot.exceptions.InsufficientPower","title":"InsufficientPower","text":"<p>               Bases: <code>CheckFailure</code></p> <p>Exception raised when the command invoker does not have enough power to run the command.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NotADirectRoom","title":"NotADirectRoom","text":"<p>               Bases: <code>CheckFailure</code></p> <p>Exception raised when the current room is not <code>m.direct</code> (a DM room)</p>"},{"location":"reference/utils/checks/","title":"Checks","text":"<p>There are a few built in checks that you can make use of:</p>"},{"location":"reference/utils/checks/#niobot.utils.checks.is_owner","title":"is_owner","text":"<pre><code>is_owner(*extra_owner_ids)\n</code></pre> <p>Requires the sender owns the bot (<code>[NioBot.owner_id][]</code>), or is in <code>extra_owner_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>extra_owner_ids</code> <p>A set of <code>@localpart:homeserver.tld</code> strings to check against.</p> <code>()</code> <p>Returns:</p> Type Description <p>True - the check passed.</p> <p>Raises:</p> Type Description <code>NotOwner</code> <p>The sender is not the owner of the bot and is not in the given IDs.</p>"},{"location":"reference/utils/checks/#niobot.utils.checks.is_dm","title":"is_dm","text":"<pre><code>is_dm(allow_dual_membership: bool = False)\n</code></pre> <p>Requires that the current room is a DM with the sender.</p> <p>Parameters:</p> Name Type Description Default <code>allow_dual_membership</code> <code>bool</code> <p>Whether to allow regular rooms, but only with the client and sender as members.</p> <code>False</code> <p>Returns:</p> Type Description"},{"location":"reference/utils/checks/#niobot.utils.checks.sender_has_power","title":"sender_has_power","text":"<pre><code>sender_has_power(\n    level: int, room_creator_bypass: bool = False\n)\n</code></pre> <p>Requires that the sender has a certain power level in the current room before running the command.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The minimum power level</p> required <code>room_creator_bypass</code> <code>bool</code> <p>If the room creator should bypass the check and always be allowed, regardless of level.</p> <code>False</code> <p>Returns:</p> Type Description"},{"location":"reference/utils/checks/#niobot.utils.checks.client_has_power","title":"client_has_power","text":"<pre><code>client_has_power(level: int)\n</code></pre> <p>Requires that the bot has a certain power level in the current room before running the command.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The minimum power level</p> required <p>Returns:</p> Type Description"},{"location":"reference/utils/checks/#niobot.utils.checks.from_homeserver","title":"from_homeserver","text":"<pre><code>from_homeserver(*homeservers: str)\n</code></pre> <p>Requires that the sender is from one of the given homeservers.</p> <p>Parameters:</p> Name Type Description Default <code>homeservers</code> <code>str</code> <p>The homeservers to allowlist.</p> <code>()</code> <p>Returns:</p> Type Description"},{"location":"reference/utils/federation/","title":"Federation","text":"<p>There isn't a lot here aside from a homeserver resolver. A lot of the federation is already handled by matrix-nio itself, so there isn't a lot of need for federation-specific utilities.</p>"},{"location":"reference/utils/federation/#niobot.utils.federation.resolve_homeserver","title":"resolve_homeserver  <code>async</code>","text":"<pre><code>resolve_homeserver(domain: str) -&gt; str\n</code></pre> <p>Resolves a given homeserver part to the actual homeserver</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain to crawl</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resolved homeserver</p>"},{"location":"reference/utils/help_command/","title":"The help command","text":"<p><code>NioBot</code> comes with a built-in help command, which can be used to display information about other commands.</p> <p>This built-in command is simple, slick, and most importantly, helpful. It takes one optional argument, <code>command</code>, which changes the output to display information about a specific command.</p>"},{"location":"reference/utils/help_command/#the-command-list","title":"The command list","text":"<p>If a command name is not passed to the help command, it will instead display a list of all available commands. The information that will be displayed will be:</p> <ul> <li>The command's name</li> <li>Any aliases the command has</li> <li>The command's short description (usually first 100 characters of first line of the command's callback docstring)</li> <li>Any arguments that're required or optional (required are encased in <code>&lt;brackets&gt;</code>, optional in <code>[brackets]</code>)</li> </ul> <p>The command is only listed if:</p> <ul> <li>The command is not disabled (i.e. <code>disabled=True</code> is passed, or omitted entirely)</li> <li>The command is not hidden (i.e. <code>hidden=True</code> is not passed (or is ommitted entirely))</li> <li>The user passes all of the checks for the command</li> </ul> <p>The command list is sorted alphabetically by command name, and is not paginated or seperated at all. If you want a pretty help command, you should write your own - the default one is just meant to be a happy middle ground between pretty and functional. See the next section for more information on how to do this.</p>"},{"location":"reference/utils/help_command/#registering-your-own-help-command","title":"Registering your own help command","text":"<p>If you would like to register your own help command, you need to be aware of the following:</p> <ul> <li>The help command is a command, much like any other command, and is registered as such. You should be aware of  aliases, case sensitivity, command states (e.g. disabled/enabled) and visibility (hidden/shown), checks, etc.</li> <li>A help command is almost always a user's first impression of your bot. You should make sure that it works 100% of the time, is insanely simple to use, and is very helpful. A help command that just says \"You can use command like ?info\" is not helpful at all, and will likely turn many users away.</li> </ul> <p>As of v1.2.0, the help command is now a class that you can easily subclass. This is the recommended way of doing this.</p> <p>The only function that you NEED to change is <code>respond</code>, which is the function that is called when the help command is run. The rest is, quite literally, just dectoration.</p> <p>Here's an example of a custom help command:</p> <pre><code>from niobot import DefaultHelpCommand, NioBot\n\n\nclass MyHelpCommand(DefaultHelpCommand):\n    async def respond(self, ctx, command=None):\n        if command is None:\n            # No argument was given to !help\n            await ctx.respond(\"This is a custom help command!\")\n        else:\n            # a command name was given to !help\n            await ctx.respond(f\"Help for command {command} goes here!\")\n\n\nclient = NioBot(help_command=MyHelpCommand().respond)\n</code></pre> <p>Now, when someone runs <code>!help</code>, they will get a custom response from the <code>MyHelpCommand</code> class.</p> <code>help_command</code> should be a full Command instance. <p>While the above code gives the <code>response</code> function to the <code>help_command</code> parameter, it is not the ideal way to do this. You should pass a niobot.Command instance to the help command instead, as this gives you a more consistent experience, with fine-grained control over the command's state, aliases, etc.</p> <p>For the sake of berevity, the above code is used to demonstrate the concept of a custom help command.</p>"},{"location":"reference/utils/help_command/#the-defaulthelpcommand-class","title":"The DefaultHelpCommand class","text":"<p>The default help command for NioBot.</p> <p>This is a very basic help command which lists available commands, their arguments, and a short descrption, and allows for further information by specifying the command name as an argument.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.DefaultHelpCommand.clean_output","title":"clean_output  <code>staticmethod</code>","text":"<pre><code>clean_output(\n    text: str,\n    *,\n    escape_user_mentions: bool = True,\n    escape_room_mentions: bool = True,\n    escape_room_references: bool = False,\n    escape_all_periods: bool = False,\n    escape_all_at_signs: bool = False,\n    escape_method: Optional[Callable[[str], str]] = None\n) -&gt; str\n</code></pre> <p>Escapes given text and sanitises it, ready for outputting to the user.</p> <p>This should always be used when echoing any sort of user-provided content, as we all know there will be some annoying troll who will just go <code>@room</code> for no apparent reason every 30 seconds.</p> <p>Do not rely on this!</p> <p>This function is not guaranteed to escape all possible mentions, and should not be relied upon to do so. It is only meant to be used as a convenience function for simple commands.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to sanitise</p> required <code>escape_user_mentions</code> <code>bool</code> <p>Escape all @user:homeserver.tld mentions</p> <code>True</code> <code>escape_room_mentions</code> <code>bool</code> <p>Escape all @room mentions</p> <code>True</code> <code>escape_room_references</code> <code>bool</code> <p>Escape all #room:homeserver.tld references</p> <code>False</code> <code>escape_all_periods</code> <code>bool</code> <p>Escape all literal <code>.</code> characters (can be used to escape all links)</p> <code>False</code> <code>escape_all_at_signs</code> <code>bool</code> <p>Escape all literal <code>@</code> characters (can be used to escape all mentions)</p> <code>False</code> <code>escape_method</code> <code>Optional[Callable[[str], str]]</code> <p>A custom escape method to use instead of the built-in one (which just wraps characters in <code>\\u200b</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The cleaned text</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.DefaultHelpCommand.format_command_name","title":"format_command_name  <code>staticmethod</code>","text":"<pre><code>format_command_name(command: Command) -&gt; str\n</code></pre> <p>Formats the command name with its aliases if applicable</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.DefaultHelpCommand.format_command_line","title":"format_command_line","text":"<pre><code>format_command_line(prefix: str, command: Command) -&gt; str\n</code></pre> <p>Formats a command line, including name(s) &amp; usage.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.DefaultHelpCommand.get_short_description","title":"get_short_description  <code>staticmethod</code>","text":"<pre><code>get_short_description(command: Command) -&gt; str\n</code></pre> <p>Generates a short (&lt;100 characters) help description for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.DefaultHelpCommand.get_long_description","title":"get_long_description  <code>staticmethod</code>","text":"<pre><code>get_long_description(command: Command) -&gt; str\n</code></pre> <p>Gets the full help text for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.DefaultHelpCommand.get_default_help","title":"get_default_help  <code>async</code>","text":"<pre><code>get_default_help(\n    ctx: Context, command_name: str = None\n) -&gt; str\n</code></pre> <p>Gets the default help text</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.DefaultHelpCommand.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(ctx: Context, command_name: str = None) -&gt; None\n</code></pre> <p>Displays help information about available commands</p>"},{"location":"reference/utils/html_table/","title":"Table Builder","text":""},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable","title":"HTMLTable","text":"<p>Helper utility to create HTML (and plain text) tables.</p> <p>This class is iterable</p> <p>Iterating over this class will return an iterable, where the first element is the list of headers, and then the rest are the individual rows. Changing values in this iteration will NOT update the original entries.</p> <p>Example:</p> <pre><code>table = HTMLTable(caption=\"My Table\")\ntable.add_columns(\"number\", \"value\")\ntable.add_rows(\"0\", \"hello world\")\ntable.add_rows(\"1\", \"foo bar\")\n\nawait bot.room_send(\n    \"!example:example.example\",\n    {\n        \"msgtype\": \"m.notice\",\n        \"body\": table.render(\"text\"),\n        \"format\": \"org.matrix.custom.html\",\n        \"formatted_body\": table.render(\"html\"),\n    }\n)\n</code></pre>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.add_column","title":"add_column","text":"<pre><code>add_column(column_name: str) -&gt; Self\n</code></pre> <p>Add a column (header name) to the table.</p>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.add_columns","title":"add_columns","text":"<pre><code>add_columns(*column_names: str) -&gt; Self\n</code></pre> <p>Add multiple columns (header names) to the table.</p>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.add_row","title":"add_row","text":"<pre><code>add_row(*values: str) -&gt; Self\n</code></pre> <p>Add a row to the table.</p> <p>If the number of values is not equal to the number of columns, blank values will be added to pad the row.</p>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.add_rows","title":"add_rows","text":"<pre><code>add_rows(*rows: List[str]) -&gt; Self\n</code></pre> <p>Add multiple rows to the table.</p>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.render_html","title":"render_html","text":"<pre><code>render_html() -&gt; str\n</code></pre> <p>Render the table as an HTML string.</p>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.render_text","title":"render_text","text":"<pre><code>render_text() -&gt; str\n</code></pre> <p>Render the table as a simple textual table</p> <p>Example:</p> <pre><code>number | value\n-------+------\n0      | a\n1      | b\n2      | c\n3      | d\n4      | e\n</code></pre>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.render","title":"render","text":"<pre><code>render(\n    output_format: Literal[\"html\", \"text\"] = \"html\",\n) -&gt; str\n</code></pre> <p>Render the table in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>output_format</code> <code>Literal['html', 'text']</code> <p>The output format. Either \"html\" or \"text\".</p> <code>'html'</code>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.remove_row","title":"remove_row","text":"<pre><code>remove_row(index: int) -&gt; Self\n</code></pre> <p>Remove a row from the table.</p>"},{"location":"reference/utils/html_table/#niobot.utils.html_table.HTMLTable.insert_row","title":"insert_row","text":"<pre><code>insert_row(index: int, *values: str) -&gt; Self\n</code></pre> <p>Insert a row at a specific index.</p> <p>Note that the index will become the values. For example, inserting at index 0 will insert the row at the top, and inserting at index 2 will make this row 3.</p>"},{"location":"reference/utils/mentions/","title":"Mentions","text":"<p>New in v1.2.0</p> <p>This module was added in v1.2.0, so you will not be able to use this if you are using an older version of <code>nio-bot</code>.</p> <p>See the changelog for more information.</p> <p>Starting in v1.2.0, <code>nio-bot</code> now has the added functionality of intentional mentions, which allows you to even more finely tune who is mentioned by your messages.</p> <p>Previously just including <code>@mxid:homeserver.example</code> or <code>@room</code> would create mentions, but sometimes this was undesirable (for example, echoing user input (WHICH YOU SHOULD NOT DO)).</p> <p>Using <code>Mentions</code>, you can now control exactly how you want mentions to be created.</p>"},{"location":"reference/utils/mentions/#niobot.utils.mentions.Mentions","title":"Mentions","text":"<p>Controls the mentions of a sent event.</p> <p>See: https://spec.matrix.org/v1.11/client-server-api/#user-and-room-mentions</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>bool</code> <p>Whether this event mentions the entire room</p> <code>False</code> <code>user_ids</code> <code>str</code> <p>List of user IDs mentioned in the event</p> <code>()</code>"},{"location":"reference/utils/mentions/#niobot.utils.mentions.Mentions.room","title":"room  <code>instance-attribute</code>","text":"<pre><code>room: bool = room\n</code></pre> <p>Whether this event mentions the entire room</p>"},{"location":"reference/utils/mentions/#niobot.utils.mentions.Mentions.user_ids","title":"user_ids  <code>instance-attribute</code>","text":"<pre><code>user_ids: List[str] = list(user_ids)\n</code></pre> <p>List of user IDs mentioned in the event</p>"},{"location":"reference/utils/mentions/#niobot.utils.mentions.Mentions.as_body","title":"as_body","text":"<pre><code>as_body() -&gt; Dict[str, Dict[str, Union[bool, List[str]]]]\n</code></pre> <p>Returns the mentions object as a body dict (e.g. <code>{m.mentions: {room: true, user_ids: []}}</code>)</p>"},{"location":"reference/utils/mentions/#niobot.utils.mentions.Mentions.from_body","title":"from_body  <code>classmethod</code>","text":"<pre><code>from_body(body: dict) -&gt; Mentions\n</code></pre> <p>Creates a mentions object from a body dict</p>"},{"location":"reference/utils/mentions/#niobot.utils.mentions.Mentions.add_user","title":"add_user","text":"<pre><code>add_user(mxid: str) -&gt; Mentions\n</code></pre> <p>Adds a user to the mentions list</p>"},{"location":"reference/utils/mentions/#example","title":"Example","text":"<pre><code>from niobot import NioBot, Context, Mentions\n\n\nbot = NioBot(\n    homeserver=\"https://matrix-client.matrix.org\",\n    user_id=\"@my_user:matrix.org\",\n    command_prefix=\"!\"\n)\n\n@bot.command(\"mention\")\nasync def mention_command(ctx: Context, ping_room: bool = False):\n    \"\"\"Mentions a user.\"\"\"\n    mentions = Mentions()\n    mentions.add_user(ctx.message.sender)\n    if ping_room:\n        mentions.room = True\n    # can also be constructed as `mentions = Mentions(true, ctx.message.sender)\n    content = f\"Hello {ctx.message.sender}, from @room!\"\n    await ctx.respond(\"Hello, \" + ctx.message.sender, mentions=mentions)\n    # This message will ping ctx.message.sender. If `ping_room` is `True`, it will also ping the room, otherwise,\n    # it will only render it.\n</code></pre>"},{"location":"reference/utils/mentions/#how-automatic-parsing-works","title":"How automatic parsing works","text":"<p>As this is a feature that may be unexpected to some users, <code>nio-bot</code> will automatically parse mentions if:</p> <ol> <li><code>NioBot.default_parse_mentions</code> is <code>True</code> (default) AND</li> <li><code>NioBot.send_message</code> is not given an explicit <code>mentions=</code> argument AND</li> <li>The message has a <code>content</code> that is not empty.</li> </ol> <p>In this case, niobot will scan through the message, enable the <code>@room</code> ping if that string is detected in the string, and will attempt to match any user mentions in the message. This is not foolproof, and the best way to ensure mentions are parsed correctly is to manually pass the mentions you want to the <code>Mentions</code> object.</p>"},{"location":"reference/utils/mentions/#disabling-mentions","title":"Disabling mentions","text":"<p>If you want to send a message that contains @mentions, but don't want them to actually mention anyone, you can pass <code>mentions=niobot.Mentions()</code> in <code>send_message</code>. This will still render the mentions on the client (usually), but rest assured it did not actually mention them (i.e. they will not have received a notification).</p> <p>You cannot create a mention that is not also rendered</p> <p>To mention someone, you must include that in your textual body too, not just in the mentions object. If you only mention someone via the <code>Mentions</code> object, it will not work.</p>"},{"location":"reference/utils/parsers/","title":"Parsers","text":"<p>These are a handful of built-in parsers that you can use with <code>niobot.Argument</code>.</p> How do I use these? <p>To use a parser, you simply pass <code>parser=&lt;function&gt;</code> when creating <code>Argument()</code>. For example:</p> <pre><code>from niobot import Argument, command, NioBot\nfrom niobot.utils.parsers import float_parser\n\nbot = NioBot(...)\n\n@bot.command(\n    name=\"sum\", \n    arguments=[\n        Argument(\"num1\", parser=float_parser),\n        Argument(\"num2\", parser=float_parser)\n    ]\n)\nasync def add_numbers(ctx: Context, num1: float, num2: float):\n    await ctx.respond(\"{!s} + {!s} = {!s}\".format(num1, num2, num1 + num2))\n\nbot.run(...)\n</code></pre> <p>While this is roughly equivalent to <code>Argument(\"num1\", type=float)</code>, it can be helpful in cases like  json_parser where you need to parse complex types.</p> <p>Tip</p> <p>You can also create your own parsers! See Creating Parsers for more information.</p> <p>This utility modules contains a handful of simple off-the-shelf parser for some basic python types.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.Parser","title":"Parser","text":"<p>               Bases: <code>ABC</code></p> <p>A base model class for parsers.</p> <p>This ABC defines one uniform method, which is <code>__call__</code>, which takes a Context instance, Argument instance, and the user-provided string value.</p> <p>This parser is designed to be instantiated, and then called with the above arguments. If you want to make a simple parser that does not take additional configuration, it is recommended to use StatelessParser instead.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.StatelessParser","title":"StatelessParser","text":"<p>               Bases: <code>Parser</code>, <code>ABC</code></p> <p>A parser base that will not be instantiated, but rather called directly.</p> <p>This is useful for parsers that do not take any configuration (such as the simple BooleanParser), where a simple one-off call is enough.</p> <p>Traditionally, you'd call a Parser like this:</p> <pre><code>parser = Parser(my_argument=True)\nresult = parser(ctx, arg, value)\n# or, in one line\nresult = Parser(my_argument=True)(ctx, arg, value)\n</code></pre> <p>However, for some simple parsers, there's no need to instantiate them. Instead, you can call them directly. The <code>StatelessParser</code> ABC adds the <code>parse</code> classmethod, meaning you can simply do the following:</p> <p><pre><code>result = Parser.parse(ctx, arg, value)\n</code></pre> Which is just a shortand for the above one-liner. This offers little to no performance benefit, however can make code look cleaner.</p> <p>As this ABC subclasses the regular Parser, you can still use the traditional instantiation+call method.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.StatelessParser.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(\n    ctx: Context, arg: Argument, value: str\n) -&gt; Optional[Any]\n</code></pre> <p>Parses the given value using this parser without needing to call __init__() first.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context instance</p> required <code>arg</code> <code>Argument</code> <p>The argument instance</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>typing.Optional[typing.Any]</code> <p>The parsed value</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.BooleanParser","title":"BooleanParser","text":"<p>               Bases: <code>StatelessParser</code></p> <p>Converts a given string into a boolean. Value is casefolded before being parsed.</p> <p>The following resolves to true: * 1, y, yes, true, on</p> <p>The following resolves to false: * 0, n, no, false, off</p> <p>The following will raise a command argument error: anything else</p> <p>Returns:</p> Type Description <code>bool</code> <p>A parsed boolean</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.FloatParser","title":"FloatParser","text":"<p>               Bases: <code>StatelessParser</code></p> <p>Converts a given string into a floating point number.</p> <p>Returns:</p> Type Description <code>float</code> <p>A parsed floating point number</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.IntegerParser","title":"IntegerParser","text":"<p>               Bases: <code>Parser</code></p> <p>Parses an integer, or optionally a real number.</p> <p>Parameters:</p> Name Type Description Default <code>allow_floats</code> <code>bool</code> <p>Whether to simply defer non-explicit-integer values to the float parser. This results in the return type being float</p> <code>False</code> <code>base</code> <code>int</code> <p>The base to parse the integer in. Defaults to 10 (denary). 2 is Binary, and 16 is Hexadecimal.</p> <code>10</code> <p>Returns:</p> Type Description <code>Union[int, float]</code> <p>A parsed integer or float, depending on input &amp; allow_floats</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.JSONParser","title":"JSONParser","text":"<p>               Bases: <code>StatelessParser</code></p> <p>Converts a given string into a JSON object.</p> <p>Performance boost</p> <p>If you want this to be fast, you should install orjson. It is a drop-in replacement for the standard library. While the parser will still work without it, it may be slower, especially for larger payloads.</p> <p>Returns:</p> Type Description <code>Union[dict, list, str, int, float, None, bool]</code> <p>The parsed JSON object</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid JSON object.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.RoomParser","title":"RoomParser","text":"<p>               Bases: <code>StatelessParser</code></p> <p>Parses a room ID, alias, or matrix.to link into a MatrixRoom object.</p> This parser is async <p>This parser is async, and should be awaited when used manually.</p> <p>Returns:</p> Type Description <code>nio.MatrixRoom</code> <p>The parsed room instance</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.EventParser","title":"EventParser","text":"<p>               Bases: <code>Parser</code></p> <p>Parses an event reference from either its ID, or matrix.to link.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>Optional[str]</code> <p>The event type to expect (such as m.room.message). If None, any event type is allowed.</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Coroutine</code> <p>The actual internal (async) parser.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.MatrixDotToParser","title":"MatrixDotToParser","text":"<p>               Bases: <code>Parser</code></p> <p>Converts a matrix.to link into a MatrixRoomLink namedtuple, which consists of the room, event, and any query passed to the URL.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain to check for. Defaults to matrix.to, consistent with average client behaviour.</p> <code>'matrix.to'</code> <code>require_room</code> <code>bool</code> <p>Whether to require the room part of this url to be present</p> <code>True</code> <code>require_event</code> <code>bool</code> <p>Whether to require the event part of this url to be present</p> <code>False</code> <code>allow_user_as_room</code> <code>bool</code> <p>Whether to allow user links as room links</p> <code>True</code> <code>stateless</code> <code>bool</code> <p>If true, the link will only be parsed, not resolved. This means rooms will stay as their IDs, etc.</p> <code>False</code> <p>Returns:</p> Type Description <code>typing.Coroutine</code> <p>The actual internal (async) parser.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.MXCParser","title":"MXCParser","text":"<p>               Bases: <code>StatelessParser</code></p> <p>Parses an MXC URL into a MatrixMXCUrl namedtuple, which consists of the server and media ID.</p> <p>Returns:</p> Type Description <code>MatrixMXCUrl (namedtuple)</code> <p>The parsed MXC URL</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.MatrixUserParser","title":"MatrixUserParser","text":"<p>               Bases: <code>StatelessParser</code></p> <p>Parses a string into a MatrixUser instance from matrix-nio.</p>"},{"location":"reference/utils/parsers/#creating-parsers","title":"Creating Parsers","text":"The old way (pre-1.1.0) <p>Creating your own parser is actually really easy. All the library needs from you is a function that:</p> <ul> <li>Takes <code>niobot.Context</code> as its first argument</li> <li>Takes <code>niobot.Argument</code> as its second argument</li> <li>Takes a <code>str</code>ing (the user's input) as its third argument</li> <li>Returns a sensible value</li> <li>Or, raises CommandArgumentsError with a helpful error message.</li> </ul> <p>Do all of this, and you can very easily just pass this to <code>Argument</code>!</p> <p>For example, if you wanted to take a <code>datetime</code>, you could write your own parser like this:</p> <pre><code>from datetime import datetime\nfrom niobot import Argument, command, NioBot\n\n\ndef datetime_parser(ctx: Context, arg: Argument, user_input: str):\n    try:\n        return datetime.strptime(user_input, \"%Y-%m-%d %H:%M:%S\")\n    except ValueError:\n        raise CommandArgumentsError(\"Invalid datetime format. Expected YYYY-MM-DD HH:MM:SS\")\n\nbot = NioBot(...)\n\n\n@bot.command(name=\"remindme\", arguments=[Argument(\"time\", arg_type=datetime, parser=datetime_parser)])\nasync def remind_me(ctx: Context, time: datetime):\n    await ctx.respond(\"I'll remind you at {}!\".format(time.strftime(\"%c\")))\n\nbot.run(...)\n</code></pre> <p>Creating custom parsers for nio-bot is really simple. All you need to do is subclass either  Parser or StatelessParser and implement the <code>parse</code> method.</p> <p>However, if you want some detailed information, seek the guide</p>"},{"location":"reference/utils/string_view/","title":"String View","text":"<p>This is mostly an internal utility.</p> <p>The ArgumentView is mostly used by the internal command parser to parse arguments. While you will be able to use this yourself, its very unlikely that you'll ever actually need it.</p> <p>This is a work in progress.</p> <p>The string view does a lot of complicated maths and logic to determine arguments. It's not as simple as just splitting the string on every whitespace and calling it an argument, the ArgumentView parser has to check for quotes, escape characters, and more.</p> <p>Due to the complexity of the parser, it's very likely that there are still bugs in the parser. Fixes welcome!</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView","title":"ArgumentView","text":"<p>A parser designed to allow for multi-word arguments and quotes</p> <p>For example, the arguments <code>1 \"2 3\" 4</code> would result in three items in the internal list: <code>1</code>, <code>2 3</code>, and <code>4</code></p> <p>This is most useful when parsing arguments from a command, as it allows for multi-word arguments.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse</p> required"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.eof","title":"eof  <code>property</code>","text":"<pre><code>eof: bool\n</code></pre> <p>Returns whether the parser has reached the end of the string</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether the parser has reached the end of the string (cursor is greater than or equal to the length of the string)</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.add_arg","title":"add_arg","text":"<pre><code>add_arg(argument: str) -&gt; None\n</code></pre> <p>Adds an argument to the argument list</p> <p>Parameters:</p> Name Type Description Default <code>argument</code> <code>str</code> <p>The argument to add</p> required <p>Returns:</p> Type Description <code>None</code> <p>none</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.parse_arguments","title":"parse_arguments","text":"<pre><code>parse_arguments() -&gt; ArgumentView\n</code></pre> <p>Main parsing engine.</p> <p>Returns:</p> Type Description <code>ArgumentView</code> <p>self</p>"},{"location":"reference/utils/typing/","title":"Typing helper","text":"<p>This utility module contains one tool: the <code>Typing</code> class. It is internally used in the <code>&lt;send/edit/delete&gt;_message</code> functions of <code>NioBot</code>, but you can use it at any point to send typing events to the chat.</p>"},{"location":"reference/utils/typing/#usage","title":"Usage","text":"<p>Context manager to manage typing notifications.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The <code>NioBot</code> instance</p> required <code>room_id</code> <code>str</code> <p>The room id to send the typing notification to</p> required <code>timeout</code> <code>int</code> <p>The timeout in seconds</p> <code>30</code> <code>persistent</code> <code>bool</code> <p>Whether to send a typing notification every <code>timeout</code> seconds, to keep the typing status active</p> <code>True</code> <p>Warning</p> <p>Nesting <code>Typing</code> instances for one specific room is a bad idea, as when each instance is exited, it stops typing for the given room. For example, the below will not work as expected:</p> <pre><code>from niobot import NioBot, utils\n\nbot = NioBot(...)\n\n@bot.command()\nasync def ping(ctx):\n    async with utils.Typing(ctx.client, ctx.room.room_id):\n        await ctx.respond(\"Pong!\")\n\nbot.run(...)\n</code></pre> <p>This will not work because <code>Context.respond</code> calls <code>NioBot.send_message</code>, and <code>NioBot.send_message</code> creates its own <code>Typing</code> instance. Once <code>ctx.respond</code> returns, the internal <code>Typing</code> instance is destroyed, and the typing event is stopped, as is the behaviour of exiting the context manager. This means that either if on the loop, the upper-most <code>utils.Typing</code> instance will simply just create a new typing notification, or will not (especially if <code>persistent</code> was set to <code>False</code>). This breaks the whole persistence of typing.</p> If you want to use <code>Typing</code> to show that you're processing something: <p>If you want to use <code>Typing</code> to show a user that your bot is \"thinking\", or similar, you should make sure you exit the instance before responding. For example:</p> <pre><code>from niobot import NioBot, Typing\nimport httpx\n\nbot = NioBot(...)\n\n@bot.command()\nasync def process(ctx):\n    \"\"\"Spends a worryingly long time making a network request.\"\"\"\n    async with Typing(ctx.client, ctx.room.room_id):\n        await httpx.get(\"https://example.com\")\n    await ctx.respond(\"Done!\")\n</code></pre> <p>Be aware that this will cause a momentary blip in the <code>xyz is typing</code> status, but this is unavoidable, simply due to the semi-stateless nature of this context wrapper</p> <p>A potential future solution would be to implement some funky internal lock mechanism and/or just prevent nested <code>Typing</code> instances, but this is not a priority at the moment.</p>"},{"location":"reference/utils/typing/#niobot.utils.Typing.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Starts the typing notification loop, or sends a single typing notification if not persistent.</p>"},{"location":"reference/utils/typing/#niobot.utils.Typing.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc, tb)\n</code></pre> <p>Cancels any existing typing loop under this instance and sends a typing notification to stop typing.</p>"},{"location":"reference/utils/unblock/","title":"Unblock","text":"<p>A common problem developers encounter when working with an asyncio event loop is long blocking code. This can be caused by a number of things, but the most common is a call to a library that is not async-aware, and has many blocking operations (such as <code>requests</code>, or even the built-in <code>open()</code> + <code>read()</code> functions).</p> <p>To alleviate this, NioBot provides an \"unblock\" utility, which is a simple async function that will run any blocking code in the event loop executor, and returns the result, without pausing the event loop. This is equivalent to <code>loop.run_in_executor(None, func, *args, **kwargs)</code>.</p> A good example <p><pre><code>from niobot import NioBot, command\nfrom niobot.utils import run_blocking\n\nbot = NioBot(...)\n\n\n@bot.command(name=\"read\")\nasync def read_file(ctx: Context, filename: str):\n    with open(filename, \"r\") as f:\n        contents = await run_blocking(f.read)\n    await ctx.respond(contents)\n\nbot.run(...)\n</code></pre> This will read the contents of a file, without blocking the event loop, unlike the following code:</p> A bad example <p><pre><code>    from niobot import NioBot, command\n    from niobot.utils import run_blocking\n\n    bot = NioBot(...)\n\n\n    @bot.command(name=\"read\")\n    async def read_file(ctx: Context, filename: str):\n        with open(filename, \"r\") as f:\n            contents = f.read()\n        await ctx.respond(contents)\n\n    bot.run(...)\n</code></pre> This example is bad because it will prevent any other event processing until <code>f.read()</code> finishes, which is really bad if the file is large, or the disk is slow. For example, if you read at 1mb/s, and you have a 10 megabyte file, you will block the event loop for approximately 10 seconds, which means your program cannot do anything in those ten seconds, and as such your bot will appear to be non-functional!</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.run_blocking","title":"run_blocking  <code>async</code>","text":"<pre><code>run_blocking(\n    function: Callable[..., T], *args: Any, **kwargs: Any\n) -&gt; T\n</code></pre> <p>Takes a blocking function and runs it in a thread, returning the result.</p> <p>You should use this for any long-running functions that may take a long time to respond that are not coroutines that you can await. For example, running a subprocess.</p> Example <pre><code>import asyncio\nimport subprocess\nfrom niobot.utils import run_blocking\n\nasync def main():\n    result = await run_blocking(subprocess.run, [\"find\", \"*.py\", \"-type\", \"f\"], capture_output=True)\n    print(result)\n\nasyncio.run(main())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[..., T]</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>The result of the function.</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.force_await","title":"force_await  <code>async</code>","text":"<pre><code>force_await(\n    function: Union[Callable, Coroutine],\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>Takes a function, and if it needs awaiting, it will be awaited. If it is a synchronous function, it runs it in the event loop, preventing it from blocking.</p> <p>This is equivalent to (pseudo): <pre><code>if can_await(x):\n    await x\nelse:\n    await run_blocking(x)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Union[Callable, Coroutine]</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the function.</p>"}]}