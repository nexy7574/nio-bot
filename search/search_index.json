{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Welcome to the Nio-Bot Documentation</p>"},{"location":"#what-is-niobot","title":"What is NioBot?","text":"<p>NioBot (also referred to as nio-bot, or niobot) is a python library built on the  matrix-nio matrix sdk library (guess where we got our name from), which builds on an already powerful, extensive framework, to provide a super simple, easy-to-use matrix bot client.</p> <p>Traditionally, making bots with <code>matrix-nio</code> isn't massively difficult - it was just time consuming, with a lot of boiler plate, and often times a rushed lack of redundancy. In turn, making your own bot in base nio would end up with you making your own little in-house specialised framework, which not only is a lot of work to make and maintain, but usually ends up not being very flexible.</p> <p>NioBot aims to solve this problem by providing a framework that is both easy to use, and flexible enough to be used in a variety of situations.</p> <p>Also, Matrix and Matrix clients can be daunting to new users, and NioBot aims to make it easier for new users to get into Matrix, and to make it easier for them to make their own bots.</p> Creation background and motivations <p>I (nex) personally come from a discord bot development background, and am used to using discord.py (now py-cord), and jumping over to matrix gave me a strong whiplash feeling. In fact, it felt so different that I gave up twice making bots. This is actually my second public matrix bot framework, with the predecessor being called <code>matrix.py</code> (which is no longer available, and was never really finished).</p> <p>I decided to make this framework because I wanted to be able to have a single central framework that I could use for automating my account and also making some bots in, and thus NioBot was born.</p> <p>NioBot actually first started off as a fork of my now dead in-house framework I made ad-hoc for a bot at the time, borrowing a lot of code from it. However, as time has gone on, I've added so much more, including encryption support, images, and more.</p> <p>NioBot is designed to have a similar feel to <code>py-cord</code>, while still being true to the `matrix-nio`` library.</p> <p>As a matter of fact, I've personally contributed to both <code>py-cord</code> and <code>matrix-nio</code>, so you can rest assured that I know how both of these libraries work, and can get the most out of their feature set.</p> <p>Interested? Carry on reading!</p>"},{"location":"#features","title":"Features","text":"<ul> <li>A powerful commands framework (Modules, aliases, checks, easy extensibility)</li> <li>A flexible event system</li> <li>Simple end-to-end encryption</li> <li>Automatic markdown rendering when sending/editing messages</li> <li>Super simple to use Attachments system</li> <li>Very customisable monolithic client instance</li> <li>A simple, easy-to-use CLI tool for some on-the-go tasks</li> <li>And more to come</li> </ul>"},{"location":"#support","title":"Support","text":"<p>You can join our Matrix room for support if  you are unable to find your answer in these docs.</p> <p>Don't forget to look at the guides!</p>"},{"location":"#installing","title":"Installing","text":""},{"location":"#from-pypi","title":"From PyPi","text":"<p>The package is nio-bot, and can be installed with <code>pip install nio-bot[e2ee,cli]</code>.</p>"},{"location":"#from-github-releases","title":"From github releases","text":"<p>If you are unable to use PyPi for whatever reason, python wheels and source distributions are available in all github releases.</p> <p>Just go to the releases page, and download the latest release.</p> <p>You can then <code>pip install &lt;wheel file&gt;</code>.</p>"},{"location":"#from-source","title":"From source","text":"<p>If you want to get bleeding edge features, or simply build from source, you can use git. For example:</p> <pre><code>pip install git+https://github.com/nexy7574/niobot.git@master#egg=nio-bot[e2ee,cli]\n</code></pre> <p>(replace @master with @branch-name or @tag-name for a specific branch or tag.)</p>"},{"location":"#cli","title":"CLI","text":"<p>The <code>niobot</code> package comes with a CLI tool, which can be used to create templates, get access tokens, resolve homeservers, and more (in the future).</p> <p>You can install the cli tool with the <code>cli</code> extra. The command itself is <code>niocli</code>.</p>"},{"location":"#version-information","title":"Version information","text":"<p>Version information is found in the <code>__version__.py</code> file, which is created while installing the package.</p> <pre><code>from niobot.__version__ import __version__\nprint(__version__)\n</code></pre>"},{"location":"#logging","title":"Logging","text":"<p>Logging is done using the <code>logging</code> module. The logger is named <code>niobot.&lt;module&gt;</code>. For example:</p> <pre><code>import logging\nimport niobot\n\nlogging.basicConfig(level=logging.INFO)\nbot = niobot.NioBot(...)\n\nbot.run(...)\n</code></pre> <p>This will now output a bunch of logs to your console, which you can use to debug your bot.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This changelog is new</p> <p>Previously, all changelogs were only available in the GitHub releases. Now, they will be additionally available in the documentation.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":"These changes are not in any released version. <p>You can only get these changes by installing the library from GitHub. This is not recommended in production, as these changes are often not properly tested.</p> <p>However, if you encounter an issue with these changes, you should open an issue on GitHub so that we can release them sooner!</p> <ul> <li>Added <code>CHANGELOG.md</code> (and consequently, this page) to documentation. (2024-02-08)</li> <li><code>NioBot._get_id</code> now tells you what object it couldn't identify in the raised exception. (2024-02-11)</li> <li><code>NioBot.mount_module</code> now warns you if you define a custom <code>setup()</code> that doesn't update the command or event register. (2024-02-11)</li> </ul>"},{"location":"changelog/#v110post2-2024-02-08","title":"v1.1.0.post2 (2024-02-08)","text":""},{"location":"changelog/#new-features","title":"New features","text":"<ul> <li>Added <code>auto_read_messages</code> key word argument to <code>NioBot</code> to automatically read messages from rooms. Defaults to <code>True</code>. Disabling this (<code>False</code>) will prevent read reciepts from automatically being sent.</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug fixes","text":"<ul> <li>Fixed <code>NioBot.get_dm_rooms</code> raising a 401 Unauthorised error regardless of any state.</li> <li>Fixed <code>NioBot.get_dm_rooms</code> raising a <code>GenericMatrixError</code> whenever there were no DM rooms, instead of gracefully returning an empty object.</li> <li>Fixed <code>NioBot.get_dm_rooms</code> using outdated code from before <code>matrix-nio==0.24.0</code>.</li> </ul>"},{"location":"changelog/#v110-2024-01-30","title":"v1.1.0 (2024-01-30)","text":"<p>The license changed in this release.</p> <p>With release v1.1.0 (specifically commit 421414d), the license for nio-bot was changed from GPLv3 to LGPLv3. In short, this means you do not have to open source your code, and you are able to commercialise your project if you use nio-bot.</p> This version's changelog includes changes made in its pre-release versions <p>This changelog includes all changes made since the last stable release, including those made in pre-release versions. If you scroll down, you will see duplicate feature changelogs where the feature was changed in a pre-release version.</p>"},{"location":"changelog/#new-features_1","title":"New features","text":"<ul> <li>Added <code>niobot.Context.invoking_prefix</code>.</li> <li>Python 3.12 is now supported.</li> <li>Added <code>niobot.NioBot.is_ready</code>, which is an <code>asyncio.Event</code>.</li> <li>Added command-level checks (<code>@niobot.check</code>)</li> <li>Added sparse DM room support.</li> <li>Added additional exception types, such as <code>GenericMatrixError</code>.</li> <li>Additional type-hinting for the entire library.</li> </ul>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>License changed from <code>GPLv3</code> to <code>LGPLv3</code>.</li> <li>Improved existing type-hinting.</li> <li><code>event_id</code> is prioritised over <code>room_id</code> in <code>niobot.NioBot._get_id</code>.</li> <li><code>niobot</code> was changed to <code>nio-bot</code> (for consistency) throughout documentation and the pip installation guide.</li> </ul>"},{"location":"changelog/#v110b1post1-and-v110b1-2023-10-16","title":"v1.1.0b1.post1 (and v1.1.0b1) (2023-10-16)","text":""},{"location":"changelog/#new-features_2","title":"New features","text":"<ul> <li>Added CI testing to the library.</li> <li>Rewrote argument parsers to use a class-based ABC system, rather than a function-based system. See documentation.</li> <li>Added the <code>ignore_self</code> flag to <code>niobot.NioBot</code>, allowing you to choose whether the client will ignore its own messages.</li> <li>Added support for <code>typing.Annotated</code> in commands.</li> </ul>"},{"location":"changelog/#deprecations-removals","title":"Deprecations &amp; Removals","text":"<ul> <li>The property <code>niobot.Module.log</code> was fully removed - it was never fully functional and often tripped up users as it was unsettable.</li> <li>The property <code>niobot.Module.client</code> was deprecated - you should use <code>niobot.Module.client</code> instead.</li> </ul>"},{"location":"changelog/#v110a3-2023-10-06","title":"v1.1.0a3 (2023-10-06)","text":""},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>Prioritise <code>event_id</code> over <code>room_id</code> for the <code>_get_id</code> function</li> <li>Add <code>Context.invoking_prefix</code></li> <li>Type hinting and code refactor</li> </ul>"},{"location":"changelog/#v110a2-2023-08-21","title":"v1.1.0a2 (2023-08-21)","text":""},{"location":"changelog/#new-features_3","title":"New features","text":"<ul> <li>Backported support to Python 3.9 and Python 3.10.</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug fixes","text":"<ul> <li>Fixed a bug where disabled commands could crash the command parser.</li> </ul>"},{"location":"changelog/#documentation-changes","title":"Documentation changes","text":"<ul> <li>Replaced <code>niobot</code> with <code>nio-bot</code> for pip install guide.</li> <li>Fixed PyPi link in README.</li> <li>Cleaned up documentation issues.</li> <li>Removed the examples on GitHub (until the package is more stable in terms of design).</li> </ul>"},{"location":"changelog/#v110a1-2023-07-31","title":"v1.1.0a1 (2023-07-31)","text":""},{"location":"changelog/#new-features_4","title":"New features","text":"<ul> <li>Added documentation for events.</li> <li>Added <code>niobot.attachments.which</code> function.</li> <li>Added very early DM room support.</li> <li>Added easier ways to customise the help command.</li> <li>Added more specific exception types.</li> <li>Added <code>event_parser</code> and <code>room_parser</code></li> </ul>"},{"location":"changelog/#changes_2","title":"Changes","text":"<ul> <li><code>force_await</code> now just awaits coroutines rather than casting them to a task</li> <li>Command arguments now properly raise the correct errors</li> </ul>"},{"location":"changelog/#v102-2023-07-16","title":"v1.0.2 (2023-07-16)","text":"<p>This is an urgent security release - denial of service vulnerability.</p> <p>This release fixes a vulnerability where a potentially accidentally crafted message payload could cause the bot to completely crash. If you had disabled ignoring old messages, this could cause a crash loop if your bot automatically restarted.</p> <p>If you cannot update to v1.0.2 from a previous release, you should implement the following workaround:</p> <pre><code>import niobot\n\n\nclass PatchedClient(niobot.NioBot):\n    async def process_message(self, *args):\n        try:\n            await super().process_message(*args)\n        except IndexError:  # IndexError is the only error thrown during parsing\n            pass  # or print, whatever\n\n# bot = niobot.NioBot(...)\nbot = PatchedClient(...)  # use your patched version\n</code></pre>"},{"location":"changelog/#new-features_5","title":"New features","text":"<ul> <li>Added <code>niobot.attachments.get_image_metadata</code> (depends on <code>imagemagick</code>)</li> <li><code>niocli version</code> now shows the OS and CPU architecture.</li> <li><code>niobot.attachment.*</code> now always imports all attachment types into the <code>niobot</code> namespace, regardless of installed external dependencies.</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>Fixed <code>niobot.ImageAttachment</code> being unable to detect image streams.</li> <li>Fixed <code>niobot.BaseAttachment</code> setting incorrect file properties</li> <li><code>niobot.ImageAttachment</code> no longer explicitly fails upon encountering an unknown format, it simply emits a warning, in line with <code>niobot.VideoAttachment</code>.</li> <li>Fixed an unexpected input causing the entire process to crash.</li> </ul>"},{"location":"changelog/#v101-2023-07-12","title":"v1.0.1 (2023-07-12)","text":"<ul> <li>Added stub <code>setup.py</code> for really old pip versions.</li> <li>Updated the README.</li> </ul>"},{"location":"changelog/#v100-2023-07-12","title":"v1.0.0 (2023-07-12)","text":"<p>The first stable release! This version has many breaking changes since v0.1.0, and as such is not very backwards compatible.</p> <ul> <li><code>MediaAttachment</code> and <code>Thumbnail</code> were split up into <code>ImageAttachment</code>, <code>VideoAttachment</code>, <code>AudioAttachment</code>, and <code>FileAttachment</code>.</li> <li>Attachments now automatically detect metadata.</li> <li>Thumbnailing was massively improved.</li> <li>Blurhashes are automatically generated for images.</li> <li>Attachments now fully support end-to-end encryption.</li> <li>Attachments will now emit warnings when a non web-safe codec is used.</li> <li>Automatic command parameter parsing, so you no longer have to manually specify <code>Command(arguments=[...])</code>.</li> <li>Automatic help command sanitisation.</li> <li>Added additional requirements.</li> <li>Added the ability to add and remove reactions.</li> <li>Added <code>__repr__</code> to most objects in the library.</li> <li>Added more helper/utility functions.</li> <li>Added documentation (tada!).</li> <li>Added more customisation options to <code>niobot.NioBot</code>.</li> </ul> <p>You've reached the end! There are no previously documented releases before the big 1.0.0. If you want to expand this list, you can contribute on GitHub! Open issues, or even better, make some pull requests. We love new contributors!</p>"},{"location":"guides/001-getting-started/","title":"Getting started / quick start","text":"<p>Unfinished guide</p> <p>This guide is not yet finished.</p> <p>So, you've joined matrix, had a look around, and now you want to make your own little bot? Guess what, you can do just that with nio-bot!</p>"},{"location":"guides/001-getting-started/#prerequisites","title":"Prerequisites","text":"<p>You will need the following in general:</p> <ul> <li>A matrix account you can log into (username and password initially)</li> </ul> <p>And the following installed on the machine you want to run the bot on:</p> <ul> <li>Python with sqlite support</li> <li><code>libolm</code> (use your system package manager, like apt or pacman) in order to use end-to-end encryption.</li> <li>A decent network connection (at least a few megabits a second, preferably more)</li> <li>At least 100mb free storage space (for the database and other files)</li> </ul>"},{"location":"guides/001-getting-started/#installation","title":"Installation","text":"<p>After you've installed and acquired the above, you can install nio-bot with the following command: <pre><code>python3 -m pip install nio-bot[cli]\n# Note that we install the extras for `cli` here - the niobot CLI comes with a bunch of useful tools we'll use.\n</code></pre> If you would like to install support for end-to-end encryption, you can install the following instead: <pre><code>python3 -m pip install nio-bot[cli,e2ee]\n</code></pre></p> <p>After you've done that, verify everything installed fine by running <code>niocli version</code>: <pre><code>(venv) [me@host test-niobot]$ niocli version\n\nNioBot version: 1.1.0b1.post2.dev18 (v1.1.0, build 18, pre b2, commit g38dc914)\nmatrix-nio version: 0.22.1\nPython version: 3.11.5\nPython implementation: CPython\nOperating System: Linux-6.6.1-arch1-1-x86_64-with-glibc2.38 (Arch Linux/Unknown - Arch Linux)\nArchitecture: x86_64\nOLM Installed: Yes\nFree Disk Space: / (38.3%) /boot (66.02%)\n</code></pre></p> <p>Info</p> <p>Yes, this output is long and verbose. It is intentionally long and verbose in order to provide as much information as possible for bug reports. All you need to do is make sure there aren't too many red flags.</p> <p>For example, if you want end to end encryption, but <code>OLM Installed</code> is a red <code>No</code>, then you need to install <code>libolm</code>.</p> My architecture is red! <p>You will notice any sort of other architecture outside of <code>x86_64</code> is red - this does not mean that nio-bot won't work! Currently, nio-bot is mainly developed on an AMD64 architecture, so support is only officially for that arch. However, several people have run nio-bot on ARM64 (raspberry pi, at least), and it works fine.</p> <p>You can safely ignore this warning if you are running on a different architecture.</p> <p>If anything else is red though, you should look into it.</p>"},{"location":"guides/001-getting-started/#creating-the-start-of-your-bot","title":"Creating the start of your bot","text":"<p>In our instance here, we'll create a few files:</p> <ol> <li>A <code>config.py</code> file to store our configuration.</li> <li>A <code>main.py</code> file to store our bot code.</li> <li>A <code>fun.py</code> file to store a module (later on).</li> </ol> <p>And you'll need a directory:</p> <ol> <li><code>store</code> - this is where nio-bot will store its database and other files.</li> </ol>"},{"location":"guides/001-getting-started/#file-structure","title":"File structure","text":"<p>And as such, our directory structure will look like this: <pre><code>test-niobot/\n\u251c\u2500\u2500 config.py\n\u251c\u2500\u2500 fun.py\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 store/\n\u2514\u2500\u2500 main.py\n</code></pre></p> <p>Danger</p> <p>Make sure, if you are using version control, to add <code>config.py</code> to your <code>.gitignore</code> file! This file contains all of your personal information, such as your password, and should not be shared with anyone.</p> <p>While you're at it, you should add the <code>store</code> directory to your <code>.gitignore</code> file as well, as that will contain encryption keys later on.</p>"},{"location":"guides/001-getting-started/#setting-up-configpy","title":"Setting up config.py","text":"<p>In our <code>config.py</code> file, we'll add the following: <pre><code>HOMESERVER = \"https://matrix.org\"\nUSER_ID = \"@my-username:matrix.org\"\nPASSWORD = \"my-password\"\n</code></pre></p> <p>Warning</p> <p>Make sure to replace the above with your own homeserver, user ID, and password!</p>"},{"location":"guides/001-getting-started/#making-the-bot-runtime-file","title":"Making the bot runtime file","text":"<p>And, to make a simple bot, you can just copy the below template into your <code>main.py</code> file: <pre><code>import niobot\nimport config\n\nbot = niobot.NioBot(\n    homeserver=config.HOMESERVER,\n    user_id=config.USER_ID,\n    device_id='my-device-id',\n    store_path='./store',\n    command_prefix=\"!\",\n    owner_id=\"@my-matrix-username:matrix.org\"\n)\n# We also want to load `fun.py`'s commands before starting:\nbot.mount_module(\"fun\")  # looks at ./fun.py\n\n@bot.on_event(\"ready\")\nasync def on_ready(_):\n    # That first argument is needed as the first result of the sync loop is passed to ready. Without it, this event\n    # will fail to fire, and will cause a potentially catasrophic failure.\n    print(\"Bot is ready!\")\n\n\n@bot.command()\nasync def ping(ctx):  # can be invoked with \"!ping\"\n    await ctx.reply(\"Pong!\")\n\nbot.run(password=config.PASSWORD)\n</code></pre></p> About <code>owner_id</code> <p><code>owner_id</code> is intended to tell nio-bot who owns the current instance. Do not set this to be the same thing as <code>config.USER_ID</code> (your bot's ID)! The only time you should do that is if you want to run the bot on the same account you use.</p> <p>Otherwise, set this to be your own user ID, so that you can use any \"owner only\" commands.</p> <p>It is not necessary to set this though, so it can be omitted or set to <code>None</code>. Just note that <code>NioBot.is_owner(...)</code> will raise an error when used.</p>"},{"location":"guides/001-getting-started/#enabling-logging","title":"Enabling logging","text":"<p>You'll probably find that it's useful to enable debug logging while you're developing your bot. To do that, you can add the following to your <code>main.py</code> file: <pre><code>import logging\nimport niobot\n\nlogging.basicConfig(level=logging.DEBUG)\n# or to save to a file (uncomment):\n# logging.basicConfig(level=logging.DEBUG, filename=\"bot.log\")\n\nbot = niobot.NioBot(...)\n...\n</code></pre></p>"},{"location":"guides/001-getting-started/#making-funpy","title":"Making fun.py","text":"<p>Now, fun.py is going to be a module.</p> <p>Modules are a great way to organize your code, and make it easier to manage. They also allow you to easily add new commands to your bot without having to edit the main file, which means you can split your code up, and make it... modular!</p> <p>To start, we need to make the fun.py python file, and add the following: <pre><code>import niobot\n\n\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\n    def __init__(self, bot):\n        self.bot = bot  # bot is the NioBot instance you made in main.py!\n</code></pre> And that's it! You made your module!</p>"},{"location":"guides/001-getting-started/#but-wait-theres-more","title":"But wait, there's more!","text":"<p>You may notice that with this being a separate module, you can't use <code>@bot.command</code>, or <code>@bot.on_event</code>, or reference <code>bot</code> at all!</p> <p>You'd initially assume \"Oh, I'll just import bot from main.\" - but that's not going to work. The reason for this is every time <code>main.py</code> is imported, it creates a new <code>NioBot</code>, and then... calls bot.run() at the end, meaning not only would your import never finish, but it would also cause a massive recursion bug!</p> <p>The way you get around this is instead with <code>@niobot.command()</code>. This is a decorator that will register the command with the bot, however is designed specifically with modules in mind.</p> <p>Let's compare the two, for simplicity:</p> <code>@niobot.NioBot.command()</code> <code>@niobot.command()</code> Adds commands to the register immediately Adds commands to the register once the module is loaded Can only be used at runtime, or wherever <code>bot</code> can be imported from Can only be used in modules (has no effect outside a<code>niobot.Module</code>!) Takes priority over <code>@niobot.command()</code> due to the immediate register Lower priority than <code>NioBot.command()</code> due to the \"lazy loading\" <p>Do be aware though, both decorators will take the exact same arguments as <code>niobot.Command</code>.</p>"},{"location":"guides/001-getting-started/#adding-a-command-to-funpy","title":"Adding a command to fun.py","text":"<p>So, let's add a command to our module: <pre><code>import niobot\n\n\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\n    def __init__(self, bot):\n        self.bot = bot  # bot is the NioBot instance you made in main.py!\n\n    @niobot.command()\n    async def hello(self, ctx):\n        await ctx.reply(\"Hello %s!\" % ctx.event.sender)\n</code></pre> This will add a command, <code>!hello</code>, that will reply with \"Hello {@author}!\"</p>"},{"location":"guides/001-getting-started/#starting-the-bot","title":"Starting the bot","text":"<p>Hold your horses, you're not quite ready yet!</p> <p>Generally, it's a terrible idea to always use a password in your code. It's a security risk, and in matrix it can result in creating many sessions, which you don't want, especially if you're using encryption!</p>"},{"location":"guides/001-getting-started/#getting-an-access-token","title":"Getting an access token","text":"<p>An access token is like a server-generated long-lived password. You will probably want one in order to repeatedly use the same session, and to avoid having to use your password in your code.</p> <p>You can get your password with <code>niocli get-access-token</code>. For example: <pre><code>(venv) [me@host test-niobot]$ niocli get-access-token\nUser ID (@username:homeserver.tld): @test:matrix.org\nPassword (will not echo):\nDevice ID (a memorable display name for this login, such as 'bot-production') [host]:\nResolving homeserver... OK\nGetting access token... OK\nAccess token: syt_&lt;...&gt;\n</code></pre></p> <p>What you're going to do now, is copy the full access token string, and open <code>config.py</code> again Now, replace <code>PASSWORD=...</code> with <code>ACCESS_TOKEN=\"syt_&lt;...&gt;\"</code>. Make sure to keep the quotes!</p> <p>You will also need to go into <code>main.py</code>, down to the last line, and replace <code>password=config.PASSWORD</code> with <code>access_token=config.ACCESS_TOKEN</code>.</p> What is <code>sso_token</code>? <p>SSO token is a <code>S</code>ingle <code>S</code>ign <code>O</code>n token, employed by the likes of Mozilla, and is often used for SAML. Chances are, if you don't know what it is, you definitely don't need it. And if you do need it, you already know what it is, why you need it, and how to get it.</p>"},{"location":"guides/001-getting-started/#actually-running-the-bot","title":"Actually running the bot","text":"<p>This is the really simple part, actually. All you need to do now is run <code>main.py</code>!</p> <pre><code>(venv) [me@host test-niobot]$ python main.py\n&lt;insert log spam here&gt;\nBot is ready!\n&lt;insert log spam here&gt;\n</code></pre> <p>Its taking FOREVER to log in! is something going wrong?</p> <p>Nope. It can often take a while (upwards of five minutes in some cases!) for the bot to log in. This is because, when you first start the bot, it has to sync your entire state with the server. This often results in a LOT of IO, and a lot of network waiting, etc.</p> <p>You can speed up this process in the future by:</p> <ul> <li>Making sure you have <code>store_path</code> and a valid store in your configuration. Stores mean that the bot doesn't have   to re-sync everything every time it starts up.</li> <li>Using an access token instead of a password. This means that the bot doesn't have to log in, and can just start   syncing immediately, even from the last time it was stopped, which saves a very very large portion of the time   taken</li> </ul>"},{"location":"guides/001-getting-started/#interesting-log-output","title":"Interesting log output","text":"<p>You may notice that, if you enabled logging, you get some interesting log output.</p> <p>Some things you will want to keep an eye out for:</p> <ul> <li><code>INFO:niobot.client:Encryption support enabled automatically.</code> - This means that you have set up requirements for the   bot to use encryption, and it has detected that it can use encryption, and automatically enabled it, which is good!</li> <li><code>DEBUG:niobot.client:&lt;module '...' from '...'&gt; does not have its own setup() - auto-discovering commands and events</code> - This   means that the bot has detected a module, and is automatically loading it. This is good for most cases.   You should only worry about this message if you defined your own setup function.</li> <li><code>DEBUG:niobot.client:Registered command &lt;Command name='...' aliases=[...] disabled=...&gt; into &lt;command_name&gt;</code> - This simply   means a command has been added to the internal register.</li> <li><code>DEBUG:niobot.client:Added event listener &lt;function &lt;function_name&gt; at &lt;address&gt;&gt; for '&lt;event_name&gt;'</code> - Like the above,   this simply means an event has been added to the internal register.</li> </ul>"},{"location":"guides/001-getting-started/#and-thats-it","title":"And that's it!","text":"<p>You've successfully made a bot, and got it running!</p>"},{"location":"guides/001-getting-started/#wait-how-do-i-use-it","title":"Wait, how do I use it?","text":"<p>nio-bot has a handy dandy auto-join feature - if you just invite your bot's user to a room, assuming all is correct, within a couple seconds, your bot will automatically join your room!</p> <p>Then, you can run <code>!help</code> to get a list of commands, and <code>!help &lt;command&gt;</code> to get help on a specific command.</p>"},{"location":"guides/001-getting-started/#final-product","title":"Final product","text":"config.py <pre><code>HOMESERVER = \"https://matrix.org\"  # or your homeserver\nUSER_ID = \"@my-bot:matrix.org\"  # your bot account's user ID\nACCESS_TOKEN = \"syt_&lt;...&gt;\"  # your bot account's access token\n</code></pre> main.py <pre><code>import niobot\nimport logging\nimport config\n\nlogging.basicConfig(level=logging.INFO, filename=\"bot.log\")\n\nbot = niobot.NioBot(\n    homeserver=config.HOMESERVER,\n    user_id=config.USER_ID,\n    device_id='my-device-id',\n    store_path='./store',\n    command_prefix=\"!\",\n    owner_id=\"@my-matrix-username:matrix.org\"\n)\n# We also want to load `fun.py`'s commands before starting:\nbot.mount_module(\"fun\")\n\n@bot.on_event(\"ready\")\nasync def on_ready(_):\n    # That first argument is needed as the first result of the sync loop is passed to ready. Without it, this event\n    # will fail to fire, and will cause a potentially catasrophic failure.\n    print(\"Bot is ready!\")\n\n\n@bot.command()\nasync def ping(ctx):  # can be invoked with \"!ping\"\n    await ctx.reply(\"Pong!\")\n\nbot.run(access_token=config.ACCESS_TOKEN)\n</code></pre> fun.py <pre><code>import niobot\n\n\nclass MyFunModule(niobot.Module):  # subclassing niobot.Module is mandatory for auto-detection.\n    def __init__(self, bot):\n        self.bot = bot  # bot is the NioBot instance you made in main.py!\n\n    @niobot.command()\n    async def hello(self, ctx):\n        await ctx.reply(\"Hello %s!\" % ctx.event.sender)\n</code></pre>"},{"location":"guides/001-getting-started/#why-is-logging-in-with-a-password-so-bad","title":"Why is logging in with a password so bad?","text":"<p>You may get a notice in your console when you try to log in with a password.</p> <p>This is because logging in with a password is actually an awful idea. It will create an entirely new session, 9 times out of 10 a hard-coded password, can cause issues with e2ee, and is generally just a bad idea.</p> <p>What you should do instead is get an access token.</p> <p>If you already know how to get yours, that's great! Otherwise, <code>niocli</code> has the solution:</p> <pre><code>$ niocli get-access-token\n</code></pre> <p>This will log into the account when prompted, and will grab you an access token, spitting it out into your terminal.</p> <p>From there, you can replace <code>bot.run(password=\"...\")</code> with <code>bot.run(access_token=\"...\")</code>, and you're good to go!</p> <p>Tip</p> <p>You'll also notice that the bot starts up in a matter of seconds when using an access token. This is because the client has already logged in before, so rather than having to sync the entire state and history, it only downloads and syncs new events and data.</p> <p>In comparison to using a password, which creates a new session, meaning the client has to download and sync the entire history yet again.</p>"},{"location":"guides/002-a-simple-bot/","title":"A simple bot - example","text":"<p>Let's take the following code and break it down, so that you can better understand how niobot works:</p> Example <pre><code>import niobot\n\n\nbot = niobot.NioBot(\n    homeserver=\"https://matrix.org\",\n    user_id=\"@my_username:matrix.org\",\n    device_id=\"my_device_name\",  # defaults to the easily recognisable 'nio-bot'.\n    store_path=\"./store\",  # See the 'What is the store?' section for more info.\n    command_prefix=\"!\",\n    case_insensitive=True,  # means `!PING` and `!piNG` will both work and run `!ping`.\n    owner_id=\"@owner:matrix.org\",  # The user ID who owns this bot. Optional, but required for bot.is_owner(...).#\n    # Here, you can pass extra options that you would usually pass to `nio.AsyncClient`. Lets pass a proxy:\n    proxy=\"socks5://username:password@host:port\"\n)\n\n\n# Now, we want to register a command. NioBot uses the decorator `@NioBot.command()` for this.\n# This decorator takes a few arguments, but the only one you'll use most of the time is `name`.\n# There are also other arguments though.\n# For now we'll register a simple `ping` command.\n@bot.command(name=\"ping\")\n# We now need to define the function\nasync def ping(ctx: niobot.Context):\n    \"\"\"Shows the latency between events\"\"\"\n    # So a few things have happened here:\n    # `async def` makes this command asynchronous. This means that it can `await` other things.\n    # `ctx` is the only argument this command takes. By default, all niobot commands must take at least one argument,\n    # which is the command's context.\n    # We also then typehinted it with `niobot.Context`. This isn't critical to make the bot run, however if you're using\n    # an IDE like PyCharm, or just a workspace editor with intellisense like Visual Studio Code, it will help you\n    # to see what attributes and functions `niobot.Context` has without needing to check the documentation.\n    # Anyway, lets write the command itself.\n    # First, we need to measure the latency. NioBot has a handy function for this:\n    latency_ms = bot.latency(ctx.message)\n    # `bot.latency` measures the latency between when the event was dispatched by the server, and when the bot\n    # received it. It then returns the latency in milliseconds.\n    # `Context.message` is the event that triggered this command.\n    # Now, we need to reply to the user.\n    await ctx.respond(\"Pong! Latency: {:.2f}ms\".format(latency_ms))\n    # And that's it! We've written our first command.\n    # `Context.respond` always sends a reply to the user who sent the command.\n    # To send a message without a reply, you can use `NioBot.send_message`.\n\n\n# And while we're at it, we can add an event listener.\n# For this example, we'll add an event listener that tells the user if there's a command error.\n@bot.on_event(\"command_error\")\nasync def on_command_error(ctx: niobot.Context, error: Exception):\n    \"\"\"Called when a command raises an exception\"\"\"\n    # Take a look at the event reference for more information about events.\n    # Now, we can send a message to the user.\n    await ctx.respond(\"Error: {}\".format(error))\n\n\n# And while we're at it, we'll log when a user runs a command.\n@bot.on_event(\"command\")\nasync def on_command(ctx):\n    print(\"User {} ran command {}\".format(ctx.message.sender, ctx.command.name))\n\n\n# Now, we need to start our bot.\n# This is done by calling `NioBot.run()`.\n# In this example, we'll use an access token, rather than an insecure password.\n# You can get an access token through the niobot CLI:\n# $ niocli get-access-token\n# Copy the resulting access token, and then you can put it here:\nbot.run(access_token=\"my_access_token\")\n# Bear in mind that no code will run after `bot.run`. This function will block until the bot is stopped.\n# And even when the bot is stopped, its usually with an exception, so code after `bot.run` is not guaranteed to run.\n</code></pre>"},{"location":"guides/003-sending-attachments/","title":"Sending attachments","text":"<p>Sometimes, you want to upload attachments in your chat. Be that images, videos, or other kinds of files. NioBot supports this, and it's very easy to do.</p>"},{"location":"guides/003-sending-attachments/#before-you-start","title":"Before you start","text":"<p>In order to use the majority of the features in this guide, you will need to install <code>ffmpeg</code> and <code>imagemagick</code>. These are used for thumbnail generation, and metadata detection.</p> <p>You should use your package manager to install these, as they are not python packages.</p> Debian/UbuntuArchFedoramacOSWindows <pre><code>sudo apt install ffmpeg imagemagick\n</code></pre> <pre><code>sudo pacman -S ffmpeg imagemagick\n</code></pre> <pre><code>sudo dnf install ffmpeg imagemagick\n</code></pre> <pre><code>brew install ffmpeg imagemagick\n</code></pre> <p><pre><code>choco install ffmpeg\nchoco install imagemagick\n</code></pre> Or, install it yourself. Make sure the binaries are in your PATH:</p> <ul> <li>gyan.dev/ffmpeg/builds/ffmpeg-git-essentials.7z</li> <li>imagemagick.org/script/download.php</li> </ul>"},{"location":"guides/003-sending-attachments/#faq","title":"FAQ","text":"Why do I need to install <code>ffmpeg</code> and <code>imagemagick</code>? <p><code>imagemagick</code> is actually optional - if you trust <code>ffprobe</code> to work with all of your images (in some cases it can fail to detect newer image formats), then you can skip installing it.</p> <p>However, <code>ffmpeg</code> is required for all but file attachments. This is because in order to get some rich data, such as dimensions and duration, we need to use <code>ffprobe</code> to get this data. Furthermore, in the event <code>imagemagick</code> is not installed, the metadata fetcher falls back to <code>ffprobe</code>.</p> <p>Not having these installed will result in a <code>RuntimeError</code> being raised when you try to send an attachment when it tries to fetch metadata. This is because the metadata fetcher will not be able to find <code>ffprobe</code> or <code>imagemagick</code> in your PATH.</p> Why does it take a couple of seconds for <code>&lt;attachment&gt;.from_file()</code> to return? <p>The <code>from_file</code> method (see: niobot.VideoAttachment.from_file, niobot.ImageAttachment.from_file, etc.)  does a lot of heavy lifting in terms of preparing a file with all the bells and whistles for an upload.  This means that it has to do a lot of processing, which may take a couple of seconds to return.</p>"},{"location":"guides/003-sending-attachments/#sending","title":"Sending:","text":""},{"location":"guides/003-sending-attachments/#regular-files","title":"Regular files","text":"<p>Here, regular files can be anything that isn't a video, image, or audio file. This includes text files, PDFs, etc. You can even send binary or pre-encrypted (why?) files if you want to.</p> <p>Regular files are the simplest file type in niobot, in terms of code complexity and also features. Regular files do not support:</p> <ul> <li>Thumbnails</li> <li>Rich data</li> <li>Previews</li> </ul> <p>All you get from thumbnails is the file name, and the file size. That's it.</p> <p>Anyway, here's how you could send an example text (foo.txt) file: <pre><code>from niobot import NioBot, Context, FileAttachment\nfrom pathlib import Path\n...\n\n@bot.comand(name=\"upload.txt\")\nasync def upload_txt(ctx: Context):\n    \"\"\"Sends a text file!\"\"\"\n    await ctx.respond(file=attachment)\n</code></pre></p> <p>This results in the following: </p> <p>You can then click on the file to download it!</p>"},{"location":"guides/003-sending-attachments/#images","title":"Images","text":"<p>Images are a bit more complex than regular files. They support thumbnails, rich data, and previews.</p> Thumbnails for images <p>While you may think that thumbnails for images are useless, they are actually very useful for clients. Just beware though, having a larger or equal size image for your thumbnail is very counter productive.</p> <p>A valid use case for image thumbnails is for lower-resolution, likely compressed versions of the image you're sending. Paired with a blurhash, this can provide a very good \"placeholder\" image for people on  painfully slow connections.</p> <p>For your convenience, unless disabled, niobot will automatically generate a \"blurhash\" for your image.</p> <p>A blurhash is very good for providing a \"placeholder\" image, as it is generated by a string of around 30 characters. This means people on super slow connections can see a pretty preview of the image (without much detail), instead of having an ugly loading spinner or outright blank space in place of a loading image.</p> <p>For example:</p> <p> </p> This may slow down your image upload <p>Generating blurhashes, especially for large images, even more especially with a weak CPU, can be very slow. While this will not block your code execution, it means you must wait for the blurhash to be generated before you can do anything with the image.</p> <p>You may want to disable this behaviour. See disabling extra media features.</p> <p>And here's an example: <pre><code>from niobot import NioBot, Context, ImageAttachment\nfrom pathlib import Path\n...\n\n\n@bot.comand(name=\"upload.png\")\nasync def upload_png(ctx: Context):\n    \"\"\"Sends a png image!\"\"\"\n    attachment = await ImageAttachment.from_file(\"file.png\")\n    await ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#audio","title":"Audio","text":"<p>Audio files are actually simpler than images, however they do not support thumbnails or rich data outside of their duration.</p> Beware your codec! <p>You should aim to have your audio files as <code>opus</code>, <code>vorbis</code>, <code>aac</code>, <code>flac</code>, or <code>mp3</code> encoded files, as some clients may not be able to play other formats. Also be mindful of their containers, since some (such as <code>mkv</code>) won't play in some clients.</p> <p>Here's an example: <pre><code>from niobot import NioBot, Context, AudioAttachment\nfrom pathlib import Path\n...\n\n\n@bot.comand(name=\"upload.mp3\")\nasync def upload_mp3(ctx: Context):\n    \"\"\"Sends a mp3 audio file!\"\"\"\n    attachment = await AudioAttachment.from_file(\"file.mp3\")\n    await ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#videos","title":"Videos","text":"<p>Videos are the most complex file type in niobot. They support thumbnails, rich data, and previews.</p> <p>Again though, NioBot makes this easy. All you need to do is pass a video file to <code>VideoAttachment.from_file()</code>.</p> <p>The same warnings apply as images, except for the blurhash. Blurhashes are not generated for videos. However, thumbnails are generated by default, with their own blurhashes. For simplicity, the video's auto-generated thumbnail is simply the first frame of the video.</p> <p>Beware of your codec(s)!</p> <p>A lot of matrix clients at the moment are simple HTML5-based clients - meaning they can only play a limited set of codecs out of the box.</p> <p>You should aim to keep your video codecs as <code>h264</code>, <code>vp8</code>, or <code>vp9</code>, as these are the most widely supported. However, some native apps may not even support vp8/vp9. Use h264/avc when in doubt.</p> <p>Look at audio's warning for more information about audio codecs.</p> <p>Here's an example: <pre><code>from niobot import NioBot, Context, VideoAttachment\nfrom pathlib import Path\n...\n\n\n@bot.comand(name=\"upload.mp4\")\nasync def upload_mp4(ctx: Context):\n    \"\"\"Sends a mp4 video!\"\"\"\n    attachment = await VideoAttachment.from_file(\"file.mp4\")\n    await ctx.respond(file=attachment)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#disabling-extra-media-features","title":"Disabling extra media features","text":""},{"location":"guides/003-sending-attachments/#disabling-blurhash-generation","title":"Disabling blurhash generation","text":"This will harm the user experience <p>Disabling blurhash generation is a terrible idea - unless you make sure your uploads are a matter of kilobytes, you will always see blank spots while at least a thumbnail is loaded. Please consider alternative options.</p> <p>for niobot.VideoAttachment and niobot.ImageAttachment: <pre><code>from niobot import NioBot, Context, ImageAttachment, VideoAttachment\n...\n\nasync def foo():\n    attachment = await ImageAttachment.from_file(\"file.png\", generate_blurhash=False)\n    # or for Videos\n    attachment = await VideoAttachment.from_file(\"file.mp4\", generate_blurhash=False)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#disabling-thumbnail-generation","title":"Disabling thumbnail generation","text":"This will harm the user experience <p>If you intend to disable thumbnail generation, you should provide your own thumbnail, or at the very least leave blurhash generation enabled.</p> <p>Otherwise, while your video loads, clients will most likely just show a completely transparent box, with a loading spinner at a stretch. This leaves a massive chunk of the UI completely blank while your video loads.</p> <p>for niobot.VideoAttachment only: <pre><code>from niobot import NioBot, Context, ImageAttachment, VideoAttachment\n...\n\nasync def foo():\n    attachment = await VideoAttachment.from_file(\"file.mp4\", thumbnail=False)\n</code></pre></p>"},{"location":"guides/003-sending-attachments/#disabling-rich-data","title":"Disabling rich data","text":"<p>A lot of rich data fields will still require values for clients to properly render the media!</p> <p>In this case, \"rich data\" refers to some \"optional\" fields in media uploads, such as <code>height</code>, <code>width</code>, <code>duration</code>, etc. These fields are not required for the server to accept the upload, but they are often used by clients to figure out how to properly display the media.</p> <p>\"Rich data\" is gathered from the get_metadata function, which itself calls <code>ffprobe</code>/imagemagick as a subprocess. If, for whatever reason, this is undesirable, you can avoid it.</p> <p>Disabling rich data is not 100% possible, but you can avoid it by passing minimal values where it would automatically be filled in:</p>"},{"location":"guides/003-sending-attachments/#images_1","title":"Images","text":"<pre><code>from niobot import ImageAttachment\n\nasync def foo():\n    attachment = await ImageAttachment.from_file(\"file.png\", width=0, height=0, unsafe=True)\n</code></pre>"},{"location":"guides/003-sending-attachments/#videos_1","title":"Videos","text":"<p><pre><code>from niobot import VideoAttachment\n\nasync def foo():\n    attachment = await VideoAttachment.from_file(\"file.mp4\", width=0, height=0, duration=0)\n</code></pre> You may also want to consider either manually passing a thumbnail, or disabling thumbnail auto generation, as otherwise you'll still have ffmpeg/imagemagick called.</p>"},{"location":"guides/003-sending-attachments/#audio_1","title":"Audio","text":"<pre><code>from niobot import AudioAttachment\n\nasync def foo():\n    attachment = await AudioAttachment.from_file(\"file.mp3\", duration=0)\n</code></pre>"},{"location":"guides/004-creating-custom-parsers/","title":"Creating custom parsers","text":"<p>New in version 1.1.0b1</p> <p>This feature was added in version 1.1.0b1 - <code>pip install niobot&gt;=1.1.0b1</code></p> <p>NioBot is loaded with some sane defaults for basic types. If you were to pass the following function as a command: <pre><code>async def my_command(ctx: Context, arg1: int, arg2: float, arg3: str):\n    ...\n</code></pre> NioBot would intelligently detect <code>ctx</code> as the context (and realise it's not intended to be something the user provides) and <code>arg1</code> as an integer, <code>arg2</code> as a float, and <code>arg3</code> as a string. Then, when my_command is run, the first argument would be converted to an integer from the message, the second as a  float, and so on.</p> <p>However, these built-in types only go so far - they're limited to a subset of python built-in types, and a couple matrix-specific things (i.e. rooms and events and matrix.to links).</p> <p>This looks worryingly complicated</p> <p>Pre <code>1.1.0b1</code>, parsers were far too flexible and inconsistent. The old structure only required you had a singular synchronous function that took three arguments: <code>ctx</code>, <code>arg</code>, and <code>user_input</code>.</p> <p>This was a problem for a couple reasons:</p> <ol> <li>The flexibility meant that it was difficult to get a uniform experience across all parsers.</li> <li>This was still not very flexible for customising the parsers, and often required wrappers.</li> </ol> <p>However, since 1.1.0b1, the parser structure now uses two new ABC classes, <code>Parser</code> and <code>StatelessParser</code>, to ensure that all parsers are consistent and easy to use, while still being flexible and configurable. As a result of using classes though, some parsers can still feel a little bit bulky. But that's okay!</p>"},{"location":"guides/004-creating-custom-parsers/#creating-a-parser","title":"Creating a parser","text":"<p>Creating a parser is actually really easy. All the library needs from you is a class that subclasses either of the parser ABCs (see below), and implements the <code>__call__</code> dunder method!</p> <p>For example: <pre><code>from niobot.utils.parsers import StatelessParser\nfrom niobot import CommandParserError\n\n\nclass UserParser(StatelessParser):\n    def __call__(self, ctx: Context, arg: Argument, value: str):\n        # Do some stuff here\n        if \"@\" not in value:\n            # Always raise CommandParserError when its an invalid value - this allows for proper error handling.\n            raise CommandParserError(\"Invalid user ID. Expected @user:example.com\")\n        return value[1:]  # Remove the @ from the user ID\n</code></pre></p> <p>You can then use this parser in your commands like so: <pre><code>import niobot\nimport typing\nfrom my_parsers import UserParser\n\n\nbot = niobot.NioBot(...)\n\n\n@bot.command()\nasync def my_command(ctx: niobot.Context, user: typing.Annotated[str, UserParser]):\n    # typing.Annotated[real_type, parser] is a special type that allows you to specify a parser for a type.\n    # In your linter, `user` will be `str`, not `UserParser`.\n    await ctx.respond(\"User ID: {!s}\".format(user))\n</code></pre></p>"},{"location":"guides/004-creating-custom-parsers/#what-if-i-need-to-await-in-my-parser","title":"What if I need to <code>await</code> in my parser?","text":"<p>If you need to use asynchronous functions in your parser, you can simply return the coroutine in __call__, like below:</p> <p><pre><code>class MyParser(Parser):\n    async def internal_caller(self, ctx: Context, arg: Argument, value: str):\n        # Do some stuff here\n        await asyncio.sleep(1)  # or whatever async function you need to call\n        return value\n\n    def __call__(self, *args, **kwargs):\n        return self.internal_caller(*args, **kwargs)  # this returns a coroutine.\n</code></pre> By returning the unawaited coroutine, the library will intelligently detect it needs to be awaited, and will do so.</p> <p>If you want to use a parser like this in your code manually, you can always use niobot.utils.force_await, which will await a coroutine if it needs awaiting, or simply returns the input if it's not a coroutine.</p> <pre><code>from niobot.utils import force_await\ncoro = MyParser()(...)\n# If you're not sure if coro is a coroutine or not, you can use force_await\nparsed = await force_await()\n# Otherwise, simply await the result\ncoro = await MyParser()(...)\n</code></pre>"},{"location":"guides/004-creating-custom-parsers/#whats-the-difference-between-parser-and-statelessparser","title":"What's the difference between Parser and StatelessParser?","text":"<p>Great question!</p> <p>With parsers, there's often a split between complicated/customisable, and fixed parsers. For example,  IntegerParser is a customisable parser - You can pass options to it while initialising it, and it will use those options to parse the input. However, on the contrary, BooleanParser is a fixed parser - it does not take any options, and will always convert the input to a boolean.</p> <p>Basically, <code>StatelessParser</code> never needs to access <code>self</code> while parsing. <code>Parser</code> can.</p>"},{"location":"guides/004-creating-custom-parsers/#which-should-i-choose","title":"Which should I choose?","text":"<p>If you're writing a parser that needs to be customisable and takes options, then you should use <code>Parser</code>. Otherwise, if you don't need <code>self</code>, then you should use <code>StatelessParser</code>.</p>"},{"location":"guides/005-direct-messages/","title":"Direct Messages","text":"<p>New in version 1.1.0b2</p> <p>This feature was added in version 1.1.0b2 - <code>pip install niobot&gt;=1.1.0b2</code></p> <p>In Matrix,  Direct Messages are a bit of a loose concept. In short, a \"direct message\" in Matrix is more of a room, except with initially only two members, and a special flag, <code>is_direct</code>, set to <code>true</code> in the <code>invite</code> event.</p> <p>However, when you join a direct room, or flag a room as direct in a client, this information is stored in account data, on the homeserver. This means that your homeserver will keep track of rooms that you're in that're flagged as \"direct\".</p> <p>Direct does not mean one-to-one!</p> <p>Direct rooms are not necessarily one-to-one. They can have more than two members, and they can be group chats.</p> <p>The only thing that makes a room \"direct\" is the <code>is_direct</code> flag in the <code>invite</code> event.</p> <p>This means that if you want to send a message to a user, you should check if the direct room you've chosen contains only two members. If not, look for another, or create one.</p>"},{"location":"guides/005-direct-messages/#how-do-i-send-dms-in-niobot","title":"How do I send DMs in NioBot?","text":"<p>NioBot handles DMs mostly transparently.</p> <p>In base <code>matrix-nio</code>, trying to use <code>AsyncClient.room_send</code> and passing a user as the <code>room_id</code> will result in an error. You'd probably expect it to send a message to that user, so NioBot does just that!</p> <p>With a bit of magic, NioBot will automatically create a direct room with the user, and send the message there. In addition, if there's already a direct room stored in account data, NioBot will use the first one it finds.</p> <p>Take this example:</p> <pre><code>import niobot\n\nbot = niobot.NioBot(...)\n\n\n@bot.command(\"dm\")\nasync def send_dm(ctx: niobot.Context):\n    \"\"\"Sends you a direct message!\"\"\"\n    await bot.send_message(ctx.message.sender, \"Hello, world!\")\n</code></pre> <p>First, NioBot checks to see if there's a direct room stored in account data. If there is, it'll use that. If not, however, it will create one, and invite the user.</p> <p>And that's it! Its really that simple!</p>"},{"location":"guides/005-direct-messages/#getting-and-creating-direct-rooms","title":"Getting and creating direct rooms","text":"<p>If you want to use direct rooms outside of sending messages, you can use niobot.NioBot.get_dm_rooms, and niobot.NioBot.create_dm_room.</p> <p>For example: <pre><code>import niobot\n\nbot = niobot.NioBot(...)\n\n\n@bot.command(\"get-dm-rooms\")\nasync def get_dm_room(ctx: niobot.Context):\n    \"\"\"Gets the direct room with the user.\"\"\"\n    rooms = await bot.get_dm_rooms(ctx.message.sender)\n\n    if not rooms:\n        await ctx.respond(\"You don't have any direct rooms!\")\n        return\n\n    rooms_text = \"\\n\".join([f\"* https://matrix.to/#/{room_id}\" for room_id in rooms])\n    await ctx.respond(f\"Your {len(rooms):,} direct rooms:\\n\\n{rooms_text}\")\n\n\n@bpt.command(\"create-dm-room\")\nasync def create_dm_room(ctx: niobot.Context):\n    \"\"\"Creates a direct room with the user.\"\"\"\n    response = await bot.create_dm_room(ctx.message.sender)\n    await ctx.respond(f\"Created direct room: https://matrix.to/#/{response.room_id}\")\n</code></pre></p> <p>In this example, <code>get-dm-rooms</code> would return a count, alongside a list, of every DM room the client shares with the user. <code>create-dm-room</code> would create a new direct room with the user, and return the room link.</p> <p>The user would've already been automatically invited to the room when it was created, so there's no need to send an invitation separately.</p>"},{"location":"reference/attachment/","title":"Attachments","text":"<p>Matrix file attachments. Full e2ee support is implemented.</p>"},{"location":"reference/attachment/#niobot.attachment.AttachmentType","title":"AttachmentType","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration containing the different types of media.</p> <p>Attributes:</p> Name Type Description <code>FILE</code> <code>AttachmentType</code> <p>A generic file.</p> <code>AUDIO</code> <code>AttachmentType</code> <p>An audio file.</p> <code>VIDEO</code> <code>AttachmentType</code> <p>A video file.</p> <code>IMAGE</code> <code>AttachmentType</code> <p>An image file.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment","title":"BaseAttachment","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for attachments</p> <p>Note</p> <p>If you pass a custom <code>file_name</code>, this is only actually used if you pass a io.BytesIO to <code>file</code>. If you pass a pathlib.Path or a string, the file name will be resolved from the path, overriding the <code>file_name</code> parameter.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file path or BytesIO object to upload.</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file. Must be specified if uploading a BytesIO object.</p> <code>None</code> <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file. If not specified, it will be detected.</p> <code>None</code> <code>size_bytes</code> <code>Optional[int]</code> <p>The size of the file in bytes. If not specified, it will be detected.</p> <code>None</code> <code>attachment_type</code> <code>AttachmentType</code> <p>The type of attachment. Defaults to <code>AttachmentType.FILE</code>.</p> <code>FILE</code> <p>Attributes:</p> Name Type Description <code>file</code> <code>Union[Path, BytesIO]</code> <p>The file path or BytesIO object to upload. Resolved to a pathlib.Path object if a string is passed to <code>__init__</code>.</p> <code>file_name</code> <code>str</code> <p>The name of the file. If <code>file</code> was a string or <code>Path</code>, this will be the name of the file.</p> <code>mime_type</code> <code>str</code> <p>The mime type of the file.</p> <code>size</code> <code>int</code> <p>The size of the file in bytes.</p> <code>type</code> <code>AttachmentType</code> <p>The type of attachment.</p> <code>url</code> <code>Optional[str]</code> <p>The URL of the uploaded file. This is set after the file is uploaded.</p> <code>keys</code> <code>Optional[dict[str, str]]</code> <p>The encryption keys for the file. This is set after the file is uploaded.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.size_bytes","title":"size_bytes  <code>property</code>","text":"<pre><code>size_bytes: int\n</code></pre> <p>Returns the size of this attachment in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.as_body","title":"as_body","text":"<pre><code>as_body(body: Optional[str] = None) -&gt; dict\n</code></pre> <p>Generates the body for the attachment for sending. The attachment must've been uploaded first.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Optional[str]</code> <p>The body to use (should be a textual description). Defaults to the file name.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\n    file: Union[str, BytesIO, Path],\n    file_name: Optional[str] = None,\n) -&gt; BaseAttachment\n</code></pre> <p>Creates an attachment from a file.</p> <p>You should use this method instead of the constructor, as it will automatically detect all other values</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file or BytesIO to attach</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the BytesIO file, if applicable</p> <code>None</code> <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>Loaded attachment.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.from_mxc","title":"from_mxc  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_mxc(\n    client: NioBot,\n    url: str,\n    *,\n    force_write: Union[bool, Path] = False\n) -&gt; BaseAttachment\n</code></pre> <p>Creates an attachment from an MXC URL.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The current client instance (used to download the attachment)</p> required <code>url</code> <code>str</code> <p>The MXC:// url to download</p> required <code>force_write</code> <code>Union[bool, Path]</code> <p>Whether to force writing downloaded attachments to a temporary file.</p> <code>False</code> <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>The downloaded and probed attachment.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.from_http","title":"from_http  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_http(\n    url: str,\n    client_session: Optional[ClientSession] = None,\n    *,\n    force_write: Union[bool, Path] = False\n) -&gt; BaseAttachment\n</code></pre> <p>Creates an attachment from an HTTP URL.</p> <p>This is not necessarily just for images, video, or other media - it can be used for any HTTP resource.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The http/s URL to download</p> required <code>client_session</code> <code>Optional[ClientSession]</code> <p>The aiohttp client session to use. If not specified, a new one will be created.</p> <code>None</code> <code>force_write</code> <code>Union[bool, Path]</code> <p>Whether to force stream the download to the file system, instead of into memory. See: niobot.BaseAttachment.from_mxc</p> <code>False</code> <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>The downloaded and probed attachment.</p> <p>Raises:</p> Type Description <code>niobot.MediaDownloadException</code> <p>if the download failed.</p> <code>aiohttp.ClientError</code> <p>if the download failed.</p> <code>niobot.MediaDetectionException</code> <p>if the MIME type could not be detected.</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.size_as","title":"size_as","text":"<pre><code>size_as(\n    unit: Literal[\n        \"b\", \"kb\", \"kib\", \"mb\", \"mib\", \"gb\", \"gib\"\n    ]\n) -&gt; Union[int, float]\n</code></pre> <p>Helper function to convert the size of this attachment into a different unit.</p> Example <p><pre><code>&gt;&gt;&gt; import niobot\n&gt;&gt;&gt; attachment = niobot.FileAttachment(\"background.png\", \"image/png\")\n&gt;&gt;&gt; attachment.size_bytes\n329945\n&gt;&gt;&gt; attachment.size_as(\"kb\")\n329.945\n&gt;&gt;&gt; attachment.size_as(\"kib\")\n322.2119140625\n&gt;&gt;&gt; attachment.size_as(\"mb\")\n0.329945\n&gt;&gt;&gt; attachment.size_as(\"mib\")\n0.31466007232666016\n</code></pre> Note that due to the nature of floats, precision may be lost, especially the larger in units you go.</p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Literal['b', 'kb', 'kib', 'mb', 'mib', 'gb', 'gib']</code> <p>The unit to convert into</p> required <p>Returns:</p> Type Description <code>Union[int, float]</code> <p>The converted size</p>"},{"location":"reference/attachment/#niobot.attachment.BaseAttachment.upload","title":"upload  <code>async</code>","text":"<pre><code>upload(\n    client: NioBot, encrypted: bool = False\n) -&gt; BaseAttachment\n</code></pre> <p>Uploads the file to matrix.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The client to upload</p> required <code>encrypted</code> <code>bool</code> <p>Whether to encrypt the attachment or not</p> <code>False</code> <p>Returns:</p> Type Description <code>BaseAttachment</code> <p>The attachment</p>"},{"location":"reference/attachment/#niobot.attachment.SupportXYZAmorganBlurHash","title":"SupportXYZAmorganBlurHash","text":"<p>             Bases: <code>BaseAttachment</code></p> <p>Represents an attachment that supports blurhashes.</p> <p>Parameters:</p> Name Type Description Default <code>xyz_amorgan_blurhash</code> <code>Optional[str]</code> <p>The blurhash of the attachment</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>xyz_amorgan_blurhash</code> <code>str</code> <p>The blurhash of the attachment</p>"},{"location":"reference/attachment/#niobot.attachment.SupportXYZAmorganBlurHash.thumbnailify_image","title":"thumbnailify_image  <code>staticmethod</code>","text":"<pre><code>thumbnailify_image(\n    image: Union[Image, BytesIO, str, Path],\n    size: Tuple[int, int] = (320, 240),\n    resampling: Resampling = PIL.Image.Resampling.BICUBIC,\n) -&gt; Image\n</code></pre> <p>Helper function to thumbnail an image.</p> <p>This function is blocking - you should use niobot.utils.run_blocking to run it.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Union[Image, BytesIO, str, Path]</code> <p>The image to thumbnail</p> required <code>size</code> <code>Tuple[int, int]</code> <p>The size to thumbnail to. Defaults to 320x240, a standard thumbnail size.</p> <code>(320, 240)</code> <code>resampling</code> <code>Resampling</code> <p>The resampling filter to use. Defaults to <code>PIL.Image.BICUBIC</code>, a high-quality but fast resampling method. For the highest quality, use <code>PIL.Image.LANCZOS</code>.</p> <code>BICUBIC</code> <p>Returns:</p> Type Description <code>Image</code> <p>The thumbnail</p>"},{"location":"reference/attachment/#niobot.attachment.SupportXYZAmorganBlurHash.get_blurhash","title":"get_blurhash  <code>async</code>","text":"<pre><code>get_blurhash(\n    quality: Tuple[int, int] = (4, 3),\n    file: Optional[Union[str, Path, BytesIO, Image]] = None,\n    disable_auto_crop: bool = False,\n) -&gt; str\n</code></pre> <p>Gets the blurhash of the attachment. See: woltapp/blurhash</p> <p>You should crop-down your blurhash images.</p> <p>Generating blurhashes can take a long time, especially on large images. You should crop-down your images to a reasonable size before generating the blurhash.</p> <p>Remember, most image quality is lost - there's very little point in generating a blurhash for a 4K image. Anything over 800x600 is definitely overkill.</p> <p>You can easily resize images with SupportXYZAmorganBlurHash.thumbnailify_image:</p> <pre><code>attachment = await niobot.ImageAttachment.from_file(my_image, generate_blurhash=False)\nawait attachment.get_blurhash(file=attachment.thumbnailify_image(attachment.file))\n</code></pre> <p>This will generate a roughly 320x240 thumbnail image, and generate the blurhash from that.</p> <p>New!</p> <p>Unless you pass <code>disable_auto_crop=True</code>, this function will automatically crop the image down to a reasonable size, before generating a blurhash.</p> <p>Parameters:</p> Name Type Description Default <code>quality</code> <code>Tuple[int, int]</code> <p>A tuple of the quality to generate the blurhash at. Defaults to (4, 3).</p> <code>(4, 3)</code> <code>file</code> <code>Optional[Union[str, Path, BytesIO, Image]]</code> <p>The file to generate the blurhash from. Defaults to the file passed in the constructor.</p> <code>None</code> <code>disable_auto_crop</code> <code>bool</code> <p>Whether to disable automatic cropping of the image. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The blurhash</p>"},{"location":"reference/attachment/#niobot.attachment.FileAttachment","title":"FileAttachment","text":"<p>             Bases: <code>BaseAttachment</code></p> <p>Represents a generic file attachment.</p> <p>You should use VideoAttachment for videos, AudioAttachment for audio, and ImageAttachment for images. This is for everything else.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>Optional[int]</code> <p>The size of the file in bytes</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment","title":"ImageAttachment","text":"<p>             Bases: <code>SupportXYZAmorganBlurHash</code></p> <p>Represents an image attachment.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>Optional[int]</code> <p>The size of the file in bytes</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height of the image in pixels (e.g. 1080)</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width of the image in pixels (e.g. 1920)</p> <code>None</code> <code>thumbnail</code> <code>Optional[ImageAttachment]</code> <p>A thumbnail of the image. NOT a blurhash.</p> <code>None</code> <code>xyz_amorgan_blurhash</code> <code>Optional[str]</code> <p>The blurhash of the image</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>info</code> <p>A dict of info about the image. Contains <code>h</code>, <code>w</code>, <code>mimetype</code>, and <code>size</code> keys.</p> <code>thumbnail</code> <p>A thumbnail of the image. NOT a blurhash.</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.height","title":"height  <code>property</code> <code>writable</code>","text":"<pre><code>height: Optional[int]\n</code></pre> <p>The height of this image in pixels</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.width","title":"width  <code>property</code> <code>writable</code>","text":"<pre><code>width: Optional[int]\n</code></pre> <p>The width of this image in pixels</p>"},{"location":"reference/attachment/#niobot.attachment.ImageAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\n    file: Union[str, BytesIO, Path],\n    file_name: Optional[str] = None,\n    height: Optional[int] = None,\n    width: Optional[int] = None,\n    thumbnail: Optional[ImageAttachment] = None,\n    generate_blurhash: bool = True,\n    *,\n    unsafe: bool = False\n) -&gt; ImageAttachment\n</code></pre> <p>Generates an image attachment</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height, in pixels, of this image</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width, in pixels, of this image</p> <code>None</code> <code>thumbnail</code> <code>Optional[ImageAttachment]</code> <p>A thumbnail for this image</p> <code>None</code> <code>generate_blurhash</code> <code>bool</code> <p>Whether to generate a blurhash for this image</p> <code>True</code> <code>unsafe</code> <code>bool</code> <p>Whether to allow uploading of images with unsupported codecs. May break metadata detection.</p> <code>False</code> <p>Returns:</p> Type Description <code>ImageAttachment</code> <p>An image attachment</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment","title":"VideoAttachment","text":"<p>             Bases: <code>BaseAttachment</code></p> <p>Represents a video attachment.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file</p> <code>None</code> <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file</p> <code>None</code> <code>size_bytes</code> <code>Optional[int]</code> <p>The size of the file in bytes</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height of the video in pixels (e.g. 1080)</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width of the video in pixels (e.g. 1920)</p> <code>None</code> <code>duration</code> <code>Optional[int]</code> <p>The duration of the video in seconds</p> <code>None</code> <code>thumbnail</code> <code>Optional[ImageAttachment]</code> <p>A thumbnail of the video. NOT a blurhash.</p> <code>None</code>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.duration","title":"duration  <code>property</code> <code>writable</code>","text":"<pre><code>duration: Optional[int]\n</code></pre> <p>The duration of this video in milliseconds</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.height","title":"height  <code>property</code> <code>writable</code>","text":"<pre><code>height: Optional[int]\n</code></pre> <p>The height of this image in pixels</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.width","title":"width  <code>property</code> <code>writable</code>","text":"<pre><code>width: Optional[int]\n</code></pre> <p>The width of this image in pixels</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\n    file: Union[str, BytesIO, Path],\n    file_name: Optional[str] = None,\n    duration: Optional[int] = None,\n    height: Optional[int] = None,\n    width: Optional[int] = None,\n    thumbnail: Optional[\n        Union[ImageAttachment, Literal[False]]\n    ] = None,\n    generate_blurhash: bool = True,\n) -&gt; VideoAttachment\n</code></pre> <p>Generates a video attachment</p> <p>This function auto-generates a thumbnail!</p> <p>As thumbnails greatly improve user experience, even with blurhashes enabled, this function will by default create a thumbnail of the first frame of the given video if you do not provide one yourself. This may increase your initialisation time by a couple seconds, give or take!</p> <p>If this is undesirable, pass <code>thumbnail=False</code> to disable generating a thumbnail. This is independent of <code>generate_blurhash</code>.</p> <p>Generated thumbnails are always WebP images, so they will always be miniature, so you shouldn't notice a significant increase in upload time, especially considering your video will likely be several megabytes.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>duration</code> <code>Optional[int]</code> <p>The duration of the video, in seconds</p> <code>None</code> <code>height</code> <code>Optional[int]</code> <p>The height, in pixels, of this video</p> <code>None</code> <code>width</code> <code>Optional[int]</code> <p>The width, in pixels, of this video</p> <code>None</code> <code>thumbnail</code> <code>Optional[Union[ImageAttachment, Literal[False]]]</code> <p>A thumbnail for this image</p> <code>None</code> <code>generate_blurhash</code> <code>bool</code> <p>Whether to generate a blurhash for this image</p> <code>True</code> <p>Returns:</p> Type Description <code>VideoAttachment</code> <p>An image attachment</p>"},{"location":"reference/attachment/#niobot.attachment.VideoAttachment.generate_thumbnail","title":"generate_thumbnail  <code>async</code> <code>staticmethod</code>","text":"<pre><code>generate_thumbnail(\n    video: Union[str, Path, VideoAttachment]\n) -&gt; ImageAttachment\n</code></pre> <p>Generates a thumbnail for a video.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>Union[str, Path, VideoAttachment]</code> <p>The video to generate a thumbnail for</p> required <p>Returns:</p> Type Description <code>ImageAttachment</code> <p>The path to the generated thumbnail</p>"},{"location":"reference/attachment/#niobot.attachment.AudioAttachment","title":"AudioAttachment","text":"<p>             Bases: <code>BaseAttachment</code></p> <p>Represents an audio attachment.</p>"},{"location":"reference/attachment/#niobot.attachment.AudioAttachment.duration","title":"duration  <code>property</code> <code>writable</code>","text":"<pre><code>duration: Optional[int]\n</code></pre> <p>The duration of this audio in milliseconds</p>"},{"location":"reference/attachment/#niobot.attachment.AudioAttachment.from_file","title":"from_file  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_file(\n    file: Union[str, BytesIO, Path],\n    file_name: Optional[str] = None,\n    duration: Optional[int] = None,\n) -&gt; AudioAttachment\n</code></pre> <p>Generates an audio attachment</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to upload</p> required <code>file_name</code> <code>Optional[str]</code> <p>The name of the file (only used if file is a <code>BytesIO</code>)</p> <code>None</code> <code>duration</code> <code>Optional[int]</code> <p>The duration of the audio, in seconds</p> <code>None</code> <p>Returns:</p> Type Description <code>AudioAttachment</code> <p>An audio attachment</p>"},{"location":"reference/attachment/#niobot.attachment.detect_mime_type","title":"detect_mime_type","text":"<pre><code>detect_mime_type(file: Union[str, BytesIO, Path]) -&gt; str\n</code></pre> <p>Detect the mime type of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, BytesIO, Path]</code> <p>The file to detect the mime type of. Can be a BytesIO.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The mime type of the file (e.g. <code>text/plain</code>, <code>image/png</code>, <code>application/pdf</code>, <code>video/webp</code> etc.)</p>"},{"location":"reference/attachment/#niobot.attachment.get_metadata_ffmpeg","title":"get_metadata_ffmpeg","text":"<pre><code>get_metadata_ffmpeg(\n    file: Union[str, Path]\n) -&gt; dict[str, Any]\n</code></pre> <p>Gets metadata for a file via ffprobe.</p> <p>example output (JSON)</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>The file to get metadata for. Must be a path-like object</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the metadata.</p>"},{"location":"reference/attachment/#niobot.attachment.get_metadata_imagemagick","title":"get_metadata_imagemagick","text":"<pre><code>get_metadata_imagemagick(file: Path) -&gt; dict[str, Any]\n</code></pre> <p>The same as <code>get_metadata_ffmpeg</code> but for ImageMagick.</p> <p>Only returns a limited subset of the data, such as one stream, which contains the format, and size, and the format, which contains the filename, format, and size.</p> <p>example output (JSON)</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path</code> <p>The file to get metadata for. Must be a path object</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A slimmed-down dictionary containing the metadata.</p>"},{"location":"reference/attachment/#niobot.attachment.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata(\n    file: Union[str, Path], mime_type: Optional[str] = None\n) -&gt; dict[str, Any]\n</code></pre> <p>Gets metadata for a file.</p> <p>This will use imagemagick (<code>identify</code>) for images where available, falling back to ffmpeg (<code>ffprobe</code>) for everything else.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>The file to get metadata for.</p> required <code>mime_type</code> <code>Optional[str]</code> <p>The mime type of the file. If not provided, it will be detected.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The metadata for the file. See niobot.get_metadata_ffmpeg and niobot.get_metadata_imagemagick for more information.</p>"},{"location":"reference/attachment/#niobot.attachment.first_frame","title":"first_frame","text":"<pre><code>first_frame(\n    file: Union[str, Path], file_format: str = \"webp\"\n) -&gt; bytes\n</code></pre> <p>Gets the first frame of a video file.</p> <p>This function creates a file on disk</p> <p>In order to extract the frame, this function creates a temporary file on disk (or memdisk depending on where your tempdir is). While this file is deleted after the function is done, it is still something to be aware of. For example, if you're (worryingly) low on space, this function may fail to extract the frame due to a lack of space. Or, someone could temporarily access and read the file before it is deleted.</p> <p>This also means that this function may be slow.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path]</code> <p>The file to get the first frame of. Must be a path-like object</p> required <code>file_format</code> <code>str</code> <p>The format to save the frame as. Defaults to webp.</p> <code>'webp'</code> <p>Returns:</p> Type Description <code>bytes</code> <p>The first frame of the video in bytes.</p>"},{"location":"reference/attachment/#niobot.attachment.generate_blur_hash","title":"generate_blur_hash","text":"<pre><code>generate_blur_hash(\n    file: Union[str, Path, BytesIO, Image], *parts: int\n) -&gt; str\n</code></pre> <p>Creates a blurhash</p> <p>This function may be resource intensive</p> <p>This function may be resource intensive, especially for large images. You should run this in a thread or process pool.</p> <p>You should also scale any images down in order to increase performance.</p> <p>See: woltapp/blurhash</p>"},{"location":"reference/attachment/#niobot.attachment.which","title":"which","text":"<pre><code>which(\n    file: Union[BytesIO, Path, str],\n    mime_type: Optional[str] = None,\n) -&gt; Union[\n    Type[FileAttachment],\n    Type[ImageAttachment],\n    Type[AudioAttachment],\n    Type[VideoAttachment],\n]\n</code></pre> <p>Gets the correct attachment type for a file.</p> <p>This function will provide either Image/Video/Audio attachment where possible, or FileAttachment otherwise.</p> <p>For example, <code>image/png</code> (from <code>my_image.png</code>) will see <code>image/</code> and will return <code>ImageAttachment</code>, and <code>video/mp4</code> (from <code>my_video.mp4</code>) will see <code>video/</code> and will return <code>VideoAttachment</code>.</p> <p>If the mime type cannot be mapped to an attachment type, this function will return <code>FileAttachment</code>.</p> Usage <pre><code>import niobot\nimport pathlib\n\nmy_file = pathlib.Path(\"/tmp/foo.bar\")\nattachment = await niobot.which(my_file).from_file(my_file)\n# or\nattachment_type = niobot.which(my_file)  # one of the BaseAttachment subclasses\nattachment = await attachment_type.from_file(my_file)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[BytesIO, Path, str]</code> <p>The file or BytesIO to investigate</p> required <code>mime_type</code> <code>Optional[str]</code> <p>The optional pre-detected mime type. If this is not provided, it will be detected.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Type[FileAttachment], Type[ImageAttachment], Type[AudioAttachment], Type[VideoAttachment]]</code> <p>The correct type for this attachment (not instantiated)</p>"},{"location":"reference/client/","title":"Client","text":""},{"location":"reference/client/#niobot.client.NioBot","title":"NioBot","text":"<p>             Bases: <code>AsyncClient</code></p> <p>The main client for NioBot.</p> <p>Parameters:</p> Name Type Description Default <code>homeserver</code> <code>str</code> <p>The homeserver to connect to. e.g. https://matrix-client.matrix.org</p> required <code>user_id</code> <code>str</code> <p>The user ID to log in as. e.g. @user:matrix.org</p> required <code>device_id</code> <code>str</code> <p>The device ID to log in as. e.g. nio-bot</p> <code>'nio-bot'</code> <code>store_path</code> <code>Optional[str]</code> <p>The path to the store file. Defaults to ./store. Must be a directory.</p> <code>None</code> <code>command_prefix</code> <code>Union[str, Pattern]</code> <p>The prefix to use for commands. e.g. !</p> required <code>case_insensitive</code> <code>bool</code> <p>Whether to ignore case when checking for commands. If True, this casefold()s incoming messages for parsing.</p> <code>True</code> <code>global_message_type</code> <code>Literal['m.text', 'm.notice']</code> <p>The message type to default to. Defaults to m.notice</p> <code>'m.notice'</code> <code>ignore_old_events</code> <code>bool</code> <p>Whether to simply discard events before the bot's login.</p> <code>True</code> <code>auto_join_rooms</code> <code>bool</code> <p>Whether to automatically join rooms the bot is invited to.</p> <code>True</code> <code>auto_read_messages</code> <code>bool</code> <p>Whether to automatically update read recipts</p> <code>True</code> <code>automatic_markdown_renderer</code> <code>bool</code> <p>Whether to automatically render markdown in messages when sending/editing.</p> <code>True</code> <code>owner_id</code> <code>Optional[str]</code> <p>The user ID of the bot owner. If set, only this user can run owner-only commands, etc.</p> <code>None</code> <code>max_message_cache</code> <code>int</code> <p>The maximum number of messages to cache. Defaults to 1000.</p> <code>1000</code> <code>ignore_self</code> <code>bool</code> <p>Whether to ignore messages sent by the bot itself. Defaults to False. Useful for self-bots.</p> <code>True</code> <code>import_keys</code> <code>Tuple[PathLike, Optional[str]]</code> <p>A key export file and password tuple. These keys will be imported at startup.</p> <code>None</code>"},{"location":"reference/client/#niobot.client.NioBot.commands","title":"commands  <code>property</code>","text":"<pre><code>commands: dict[str, Command]\n</code></pre> <p>Returns the internal command register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p> <p>Note</p> <p>Aliases of commands are treated as their own command instance. You will see the same command show up as a value multiple times if it has aliases.</p> <p>You can check if two commands are identical by comparing them (<code>command1instance == command2instance</code>)</p>"},{"location":"reference/client/#niobot.client.NioBot.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[Type[Module], Module]\n</code></pre> <p>Returns the internal module register.</p> <p>Warning</p> <p>Modifying any values here will update the internal register too.</p>"},{"location":"reference/client/#niobot.client.NioBot.latency","title":"latency  <code>staticmethod</code>","text":"<pre><code>latency(\n    event: Event, *, received_at: Optional[float] = None\n) -&gt; float\n</code></pre> <p>Returns the latency for a given event in milliseconds</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The event to measure latency with</p> required <code>received_at</code> <code>Optional[float]</code> <p>The optional time the event was received at. If not given, uses the current time.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>The latency in milliseconds</p>"},{"location":"reference/client/#niobot.client.NioBot.dispatch","title":"dispatch","text":"<pre><code>dispatch(event_name: str, *args, **kwargs)\n</code></pre> <p>Dispatches an event to listeners</p>"},{"location":"reference/client/#niobot.client.NioBot.is_old","title":"is_old","text":"<pre><code>is_old(event: Event) -&gt; bool\n</code></pre> <p>Checks if an event was sent before the bot started. Always returns False when ignore_old_events is False</p>"},{"location":"reference/client/#niobot.client.NioBot.update_read_receipts","title":"update_read_receipts  <code>async</code>","text":"<pre><code>update_read_receipts(\n    room: Union[str, MatrixRoom], event: Event\n)\n</code></pre> <p>Moves the read indicator to the given event in the room.</p> <p>This is automatically done for you.</p> <p>Whenever a message is received, this is automatically called for you. As such, your read receipt will always be the most recent message. You rarely need to call this function.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[str, MatrixRoom]</code> <p>The room to update the read receipt in.</p> required <code>event</code> <code>Event</code> <p>The event to move the read receipt to.</p> required <p>Returns:</p> Type Description <p>Nothing</p>"},{"location":"reference/client/#niobot.client.NioBot.process_message","title":"process_message  <code>async</code>","text":"<pre><code>process_message(\n    room: MatrixRoom, event: RoomMessageText\n) -&gt; None\n</code></pre> <p>Processes a message and runs the command it is trying to invoke if any.</p>"},{"location":"reference/client/#niobot.client.NioBot.is_owner","title":"is_owner","text":"<pre><code>is_owner(user_id: str) -&gt; bool\n</code></pre> <p>Checks whether a user is the owner of the bot.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>The user ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Whether the user is the owner.</p>"},{"location":"reference/client/#niobot.client.NioBot.mount_module","title":"mount_module","text":"<pre><code>mount_module(import_path: str) -&gt; Optional[list[Command]]\n</code></pre> <p>Mounts a module including all of its commands.</p> <p>Must be a subclass of niobot.commands.Module, or else this function will not work.</p> There may not be an event loop running when this function is called. <p>If you are calling this function before you call <code>bot.run()</code>, it is entirely possible that you don't have a running asyncio event loop. If you use the event loop in <code>Module.__init__</code>, you will get an error, and the module will fail the mount.</p> <p>You can get around this by deferring mounting your modules until the <code>bot.on_ready</code> event is fired, at which point not only will the first full sync have completed (meaning the bot has all of its caches populated), but the event loop will be running.</p> <p>Parameters:</p> Name Type Description Default <code>import_path</code> <code>str</code> <p>The import path (such as modules.file), which would be ./modules/file.py in a file tree.</p> required <p>Returns:</p> Type Description <code>Optional[list[Command]]</code> <p>Optional[list[Command]] - A list of commands mounted. None if the module's setup() was called.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>The module path is incorrect of there was another error while importing</p> <code>TypeError</code> <p>The module was not a subclass of Module.</p> <code>ValueError</code> <p>There was an error registering a command (e.g. name conflict)</p>"},{"location":"reference/client/#niobot.client.NioBot.unmount_module","title":"unmount_module","text":"<pre><code>unmount_module(module: Module) -&gt; None\n</code></pre> <p>Does the opposite of mounting the module. This will remove any commands that have been added to the bot from the given module.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Module</code> <p>The module to unmount</p> required"},{"location":"reference/client/#niobot.client.NioBot.get_command","title":"get_command","text":"<pre><code>get_command(name: str) -&gt; Optional[Command]\n</code></pre> <p>Attempts to retrieve an internal command</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command to retrieve</p> required <p>Returns:</p> Type Description <code>Optional[Command]</code> <p>The command, if found. None otherwise.</p>"},{"location":"reference/client/#niobot.client.NioBot.add_command","title":"add_command","text":"<pre><code>add_command(command: Command) -&gt; None\n</code></pre> <p>Adds a command to the internal register</p> <p>if a name or alias is already registered, this throws a ValueError. Otherwise, it returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.remove_command","title":"remove_command","text":"<pre><code>remove_command(command: Command) -&gt; None\n</code></pre> <p>Removes a command from the internal register.</p> <p>If the command is not registered, this is a no-op.</p>"},{"location":"reference/client/#niobot.client.NioBot.command","title":"command","text":"<pre><code>command(name: Optional[str] = None, **kwargs)\n</code></pre> <p>Registers a command with the bot.</p>"},{"location":"reference/client/#niobot.client.NioBot.on_event","title":"on_event","text":"<pre><code>on_event(event_type: Optional[str] = None)\n</code></pre> <p>Wrapper that allows you to register an event handler</p>"},{"location":"reference/client/#niobot.client.NioBot.set_room_nickname","title":"set_room_nickname  <code>async</code>","text":"<pre><code>set_room_nickname(\n    room: Union[str, MatrixRoom],\n    new_nickname: str = None,\n    user: Optional[Union[str, MatrixUser]] = None,\n) -&gt; RoomPutStateResponse\n</code></pre> <p>Changes the user's nickname in the given room.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[str, MatrixRoom]</code> <p>The room to change the nickname in.</p> required <code>new_nickname</code> <code>str</code> <p>The new nickname. If None, defaults to the user's display name.</p> <code>None</code> <code>user</code> <code>Optional[Union[str, MatrixUser]]</code> <p>The user to update. Defaults to the bot's user.</p> <code>None</code> <p>Returns:</p> Type Description <code>RoomPutStateResponse</code> <p>The response from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.get_cached_message","title":"get_cached_message","text":"<pre><code>get_cached_message(\n    event_id: str,\n) -&gt; Optional[Tuple[MatrixRoom, RoomMessageText]]\n</code></pre> <p>Fetches a message from the cache.</p> <p>This returns both the room the message was sent in, and the event itself.</p> <p>If the message is not in the cache, this returns None.</p>"},{"location":"reference/client/#niobot.client.NioBot.fetch_message","title":"fetch_message  <code>async</code>","text":"<pre><code>fetch_message(room_id: str, event_id: str)\n</code></pre> <p>Fetches a message from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.wait_for_message","title":"wait_for_message  <code>async</code>","text":"<pre><code>wait_for_message(\n    room_id: Optional[str] = None,\n    sender: Optional[str] = None,\n    check: Optional[\n        Callable[[MatrixRoom, RoomMessageText], Any]\n    ] = None,\n    *,\n    timeout: Optional[float] = None\n) -&gt; Optional[Tuple[MatrixRoom, RoomMessageText]]\n</code></pre> <p>Waits for a message, optionally with a filter.</p> <p>If this function times out, asyncio.TimeoutError is raised.</p>"},{"location":"reference/client/#niobot.client.NioBot.generate_mx_reply","title":"generate_mx_reply  <code>staticmethod</code>","text":"<pre><code>generate_mx_reply(\n    room: MatrixRoom, event: RoomMessageText\n) -&gt; str\n</code></pre> <p>Generates a reply string for a given event.</p>"},{"location":"reference/client/#niobot.client.NioBot.get_dm_rooms","title":"get_dm_rooms  <code>async</code>","text":"<pre><code>get_dm_rooms(\n    user: Optional[Union[MatrixUser, str]] = None\n) -&gt; Union[Dict[str, List[str]], List[str]]\n</code></pre> <p>Gets DM rooms, optionally for a specific user.</p> <p>If no user is given, this returns a dictionary of user IDs to lists of rooms.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Optional[Union[MatrixUser, str]]</code> <p>The user ID or object to get DM rooms for.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[Dict[str, List[str]], List[str]]</code> <p>A dictionary of user IDs to lists of rooms, or a list of rooms.</p>"},{"location":"reference/client/#niobot.client.NioBot.create_dm_room","title":"create_dm_room  <code>async</code>","text":"<pre><code>create_dm_room(\n    user: Union[MatrixUser, str]\n) -&gt; RoomCreateResponse\n</code></pre> <p>Creates a DM room with a given user.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>Union[MatrixUser, str]</code> <p>The user to create a DM room with.</p> required <p>Returns:</p> Type Description <code>RoomCreateResponse</code> <p>The response from the server.</p>"},{"location":"reference/client/#niobot.client.NioBot.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(\n    room: Union[MatrixRoom, MatrixUser, str],\n    content: Optional[str] = None,\n    file: Optional[BaseAttachment] = None,\n    reply_to: Optional[Union[RoomMessageText, str]] = None,\n    message_type: Optional[str] = None,\n    clean_mentions: Optional[bool] = False,\n    *,\n    content_type: Literal[\n        \"plain\", \"markdown\", \"html\", \"html.raw\"\n    ] = \"markdown\",\n    override: Optional[dict] = None\n) -&gt; RoomSendResponse\n</code></pre> <p>Sends a message.</p> DMs <p>As of v1.1.0, you can now send messages to users (either a nio.MatrixUser or a user ID string), and a direct message room will automatically be created for you if one does not exist, using an existing one if it does.</p> <p>Content Type</p> <p>Separate to <code>message_type</code>, <code>content_type</code> controls what sort of parsing and formatting will be applied to the provided content. This is useful for sending messages that are not markdown, or for sending HTML. Before, all content was assumed to be markdown, and was parsed as such. However, this may cause undesirable effects if you are sending messages that are not markdown.</p> <ul> <li><code>plain</code> - No parsing or formatting is applied, and the content is sent as-is.</li> <li><code>markdown</code> - The content is parsed as markdown and rendered as HTML, with a fallback plain text body. This is the default.</li> <li><code>html</code> - The content is sent as HTML, with no fallback to plain text. If BeautifulSoup is installed, the provided content will be sanitised and pretty-printed before sending. ** <code>html.raw</code> - The content is sent as HTML, with no fallback to plain text, nor sanitising or formatting.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[MatrixRoom, MatrixUser, str]</code> <p>The room or to send this message to</p> required <code>content</code> <code>Optional[str]</code> <p>The content to send. Cannot be used with file.</p> <code>None</code> <code>file</code> <code>Optional[BaseAttachment]</code> <p>A file to send, if any. Cannot be used with content.</p> <code>None</code> <code>reply_to</code> <code>Optional[Union[RoomMessageText, str]]</code> <p>A message to reply to.</p> <code>None</code> <code>message_type</code> <code>Optional[str]</code> <p>The message type to send. If none, defaults to NioBot.global_message_type, which itself is <code>m.notice</code> by default.</p> <code>None</code> <code>clean_mentions</code> <code>Optional[bool]</code> <p>Whether to escape all mentions</p> <code>False</code> <code>override</code> <code>Optional[dict]</code> <p>A dictionary containing additional properties to pass to the body. Overrides existing properties.</p> <code>None</code> <code>content_type</code> <code>Literal['plain', 'markdown', 'html', 'html.raw']</code> <p>The type of content to send. Defaults to \"markdown\".</p> <code>'markdown'</code> <p>Returns:</p> Type Description <code>RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to send, or if the file fails to upload.</p> <code>ValueError</code> <p>You specified neither file nor content.</p>"},{"location":"reference/client/#niobot.client.NioBot.edit_message","title":"edit_message  <code>async</code>","text":"<pre><code>edit_message(\n    room: Union[MatrixRoom, str],\n    message: Union[Event, str],\n    content: str,\n    *,\n    message_type: Optional[str] = None,\n    content_type: Literal[\n        \"plain\", \"markdown\", \"html\", \"html.raw\"\n    ] = \"markdown\",\n    clean_mentions: bool = False,\n    override: Optional[dict] = None\n) -&gt; RoomSendResponse\n</code></pre> <p>Edit an existing message. You must be the sender of the message.</p> <p>You also cannot edit messages that are attachments.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[MatrixRoom, str]</code> <p>The room the message is in.</p> required <code>message</code> <code>Union[Event, str]</code> <p>The message to edit.</p> required <code>content</code> <code>str</code> <p>The new content of the message.</p> required <code>message_type</code> <code>Optional[str]</code> <p>The new type of the message (i.e. m.text, m.notice. Defaults to client.global_message_type)</p> <code>None</code> <code>clean_mentions</code> <code>bool</code> <p>Whether to escape all mentions</p> <code>False</code> <code>override</code> <code>Optional[dict]</code> <p>A dictionary containing additional properties to pass to the body. Overrides existing properties.</p> <code>None</code> <code>content_type</code> <code>Literal['plain', 'markdown', 'html', 'html.raw']</code> <p>The type of content to send. Defaults to \"markdown\".</p> <code>'markdown'</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>TypeError</code> <p>If the message is not text.</p>"},{"location":"reference/client/#niobot.client.NioBot.delete_message","title":"delete_message  <code>async</code>","text":"<pre><code>delete_message(\n    room: Union[MatrixRoom, str],\n    message_id: Union[RoomMessage, str],\n    reason: Optional[str] = None,\n) -&gt; RoomRedactResponse\n</code></pre> <p>Delete an existing message. You must be the sender of the message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[MatrixRoom, str]</code> <p>The room the message is in.</p> required <code>message_id</code> <code>Union[RoomMessage, str]</code> <p>The message to delete.</p> required <code>reason</code> <code>Optional[str]</code> <p>The reason for deleting the message.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If you are not the sender of the message.</p> <code>MessageException</code> <p>If the message fails to delete.</p>"},{"location":"reference/client/#niobot.client.NioBot.add_reaction","title":"add_reaction  <code>async</code>","text":"<pre><code>add_reaction(\n    room: Union[MatrixRoom, str],\n    message: Union[RoomMessage, str],\n    emoji: str,\n) -&gt; RoomSendResponse\n</code></pre> <p>Adds an emoji \"reaction\" to a message.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>Union[MatrixRoom, str]</code> <p>The room the message is in.</p> required <code>message</code> <code>Union[RoomMessage, str]</code> <p>The event ID or message object to react to.</p> required <code>emoji</code> <code>str</code> <p>The emoji to react with (e.g. <code>\u274c</code> = \u274c)</p> required <p>Returns:</p> Type Description <code>RoomSendResponse</code> <p>The response from the server.</p> <p>Raises:</p> Type Description <code>MessageException</code> <p>If the message fails to react.</p>"},{"location":"reference/client/#niobot.client.NioBot.redact_reaction","title":"redact_reaction  <code>async</code>","text":"<pre><code>redact_reaction(\n    room: Union[MatrixRoom, str],\n    reaction: Union[RoomSendResponse, str],\n)\n</code></pre> <p>Alias for NioBot.delete_message, but more appropriately named for reactions.</p>"},{"location":"reference/client/#niobot.client.NioBot.start","title":"start  <code>async</code>","text":"<pre><code>start(\n    password: Optional[str] = None,\n    access_token: Optional[str] = None,\n    sso_token: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>Starts the bot, running the sync loop.</p>"},{"location":"reference/client/#niobot.client.NioBot.run","title":"run","text":"<pre><code>run(\n    *,\n    password: Optional[str] = None,\n    access_token: Optional[str] = None,\n    sso_token: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Runs the bot, blocking the program until the event loop exists. This should be the last function to be called in your script, as once it exits, the bot will stop running.</p> <p>Note:     This function is literally just asyncio.run(NioBot.start(...)), so you won't have much control over the     asyncio event loop. If you want more control, you should use await NioBot.start(...) instead.</p> <p>Parameters:</p> Name Type Description Default <code>password</code> <code>Optional[str]</code> <p>The password to log in with.</p> <code>None</code> <code>access_token</code> <code>Optional[str]</code> <p>An existing login token.</p> <code>None</code> <code>sso_token</code> <code>Optional[str]</code> <p>An SSO token to sign in with.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code>"},{"location":"reference/commands/","title":"Commands","text":"<p>Using commands and events is the main way to interact with the bot.</p>"},{"location":"reference/commands/#niobot.commands.Argument","title":"Argument","text":"<p>Represents a command argument.</p> Example <pre><code>from niobot import NioBot, command, Argument\n\nbot = NioBot(...)\n\n@bot.command(\"echo\")\ndef echo(ctx: niobot.Context, message: str):\n    await ctx.respond(message)\n\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the argument. Will be used to know which argument to pass to the command callback.</p> required <code>arg_type</code> <code>_T</code> <p>The type of the argument (e.g. str, int, etc. or a custom type)</p> required <code>description</code> <code>Optional[str]</code> <p>The description of the argument. Will be shown in the auto-generated help command.</p> <code>None</code> <code>default</code> <code>Any</code> <p>The default value of the argument</p> <code>...</code> <code>required</code> <code>bool</code> <p>Whether the argument is required or not. Defaults to True if default is ..., False otherwise.</p> <code>...</code>"},{"location":"reference/commands/#niobot.commands.Argument.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str,\n    arg_type: _T,\n    *,\n    description: Optional[str] = None,\n    default: Any = ...,\n    required: bool = ...,\n    parser: Callable[\n        [Context, Argument, str], Optional[_T]\n    ] = ...,\n    **kwargs\n)\n</code></pre>"},{"location":"reference/commands/#niobot.commands.Argument.internal_parser","title":"internal_parser  <code>staticmethod</code>","text":"<pre><code>internal_parser(\n    _: Context, arg: Argument, value: str\n) -&gt; Optional[_T]\n</code></pre> <p>The default parser for the argument. Will try to convert the value to the argument type.</p>"},{"location":"reference/commands/#niobot.commands.Command","title":"Command","text":"<p>Represents a command.</p> Example <p>Note</p> <p>This example uses the <code>command</code> decorator, but you can also use the <code>Command</code> class directly, but you likely won't need to, unless you want to pass a custom command class.</p> <p>All that the <code>@command</code> decorator does is create a <code>Command</code> instance and add it to the bot's commands, while wrapping the function its decorating.</p> <pre><code>from niobot import NioBot, command\n\nbot = NioBot(...)\n\n@bot.command(\"hello\")\ndef hello(ctx: niobot.Context):\n    await ctx.respond(\"Hello, %s!\" % ctx.message.sender)\n\nbot.run(...)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the command. Will be used to invoke the command.</p> required <code>callback</code> <code>Callable</code> <p>The callback to call when the command is invoked.</p> required <code>aliases</code> <code>Optional[list[str]]</code> <p>The aliases of the command. Will also be used to invoke the command.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description of the command. Will be shown in the auto-generated help command.</p> <code>None</code> <code>disabled</code> <code>bool</code> <p>Whether the command is disabled or not. If disabled, the command will be hidden on the auto-generated help command, and will not be able to be invoked.</p> <code>False</code> <code>arguments</code> <code>Optional[list[Argument]]</code> <p>A list of <code>Argument</code> instances. Will be used to parse the arguments given to the command. <code>ctx</code> is always the first argument, regardless of what you put here.</p> <code>None</code> <code>usage</code> <code>Optional[str]</code> <p>A string representing how to use this command's arguments. Will be shown in the auto-generated help. Do not include the command name or your bot's prefix here, only arguments. For example: <code>usage=\"&lt;message&gt; [times]\"</code> will show up as <code>[p][command] &lt;message&gt; [times]</code> in the help command.</p> <code>None</code> <code>hidden</code> <code>bool</code> <p>Whether the command is hidden or not. If hidden, the command will be always hidden on the auto-generated help.</p> <code>False</code> <code>greedy</code> <code>bool</code> <p>When enabled, <code>CommandArgumentsError</code> will not be raised if too many arguments are given to the command. This is useful for commands that take a variable amount of arguments, and retrieve them via <code>Context.args</code>.</p> <code>False</code>"},{"location":"reference/commands/#niobot.commands.Command.display_usage","title":"display_usage  <code>property</code>","text":"<pre><code>display_usage: str\n</code></pre> <p>Returns the usage string for this command, auto-resolved if not pre-defined</p>"},{"location":"reference/commands/#niobot.commands.Command.autodetect_args","title":"autodetect_args  <code>staticmethod</code>","text":"<pre><code>autodetect_args(callback) -&gt; list[Argument]\n</code></pre> <p>Attempts to auto-detect the arguments for the command, based on the callback's signature</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <p>The function to inspect</p> required <p>Returns:</p> Type Description <code>list[Argument]</code> <p>A list of arguments. <code>self</code>, and <code>ctx</code> are skipped.</p>"},{"location":"reference/commands/#niobot.commands.Command.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Checks if another command's runtime ID is the same as this one's</p>"},{"location":"reference/commands/#niobot.commands.Command.invoke","title":"invoke  <code>async</code>","text":"<pre><code>invoke(ctx: Context) -&gt; Coroutine\n</code></pre> <p>Invokes the current command with the given context</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The current context</p> required <p>Raises:</p> Type Description <code>CommandArgumentsError</code> <p>Too many/few arguments, or an error parsing an argument.</p> <code>CheckFailure</code> <p>A check failed</p>"},{"location":"reference/commands/#niobot.commands.Command.construct_context","title":"construct_context","text":"<pre><code>construct_context(\n    client: NioBot,\n    room: MatrixRoom,\n    src_event: RoomMessageText,\n    invoking_prefix: str,\n    meta: str,\n    cls: type = Context,\n) -&gt; Context\n</code></pre> <p>Constructs the context for the current command.</p> <p>You will rarely need to do this, the library automatically gives you a Context when a command is run.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The current instance of the client.</p> required <code>room</code> <code>MatrixRoom</code> <p>The room the command was invoked in.</p> required <code>src_event</code> <code>RoomMessageText</code> <p>The source event that triggered the command. Must be <code>nio.RoomMessageText</code>.</p> required <code>invoking_prefix</code> <code>str</code> <p>The prefix that triggered the command.</p> required <code>meta</code> <code>str</code> <p>The invoking string (usually the command name, however may be an alias instead)</p> required <code>cls</code> <code>type</code> <p>The class to construct the context with. Defaults to <code>Context</code>.</p> <code>Context</code> <p>Returns:</p> Type Description <code>Context</code> <p>The constructed Context.</p>"},{"location":"reference/commands/#niobot.commands.Module","title":"Module","text":"<p>Represents a module.</p> <p>A module houses a set of commands and events, and can be used to modularise your bot, and organise commands and their respective code into multiple files and classes for ease of use, development, and maintenance.</p> <p>Attributes:</p> Name Type Description <code>bot</code> <p>The bot instance this module is mounted to.</p>"},{"location":"reference/commands/#niobot.commands.Module.__setup__","title":"__setup__","text":"<pre><code>__setup__()\n</code></pre> <p>Setup function called once by NioBot.mount_module(). Mounts every command discovered.</p>"},{"location":"reference/commands/#niobot.commands.Module.__teardown__","title":"__teardown__","text":"<pre><code>__teardown__()\n</code></pre> <p>Teardown function called once by NioBot.unmount_module(). Removes any command that was mounted.</p>"},{"location":"reference/commands/#niobot.commands.command","title":"command","text":"<pre><code>command(name: Optional[str] = None, **kwargs) -&gt; Callable\n</code></pre> <p>Allows you to register commands later on, by loading modules.</p> <p>This differs from NioBot.command() in that commands are not automatically added, you need to load them with bot.mount_module</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the command. Defaults to function.name</p> <code>None</code> <code>kwargs</code> <p>Any key-words to pass to Command</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable</code>"},{"location":"reference/commands/#niobot.commands.check","title":"check","text":"<pre><code>check(\n    function: Callable[\n        [Context], Union[bool, Coroutine[None, None, bool]]\n    ],\n    name: Optional[str] = None,\n) -&gt; Callable\n</code></pre> <p>Allows you to register checks in modules.</p> <pre><code>@niobot.command()\n@niobot.check(my_check_func, name=\"My Check\")\nasync def my_command(ctx: niobot.Context):\n    pass\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[Context], Union[bool, Coroutine[None, None, bool]]]</code> <p>The function to register as a check</p> required <code>name</code> <code>Optional[str]</code> <p>A human-readable name for the check. Defaults to function.name</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>The decorated function.</p>"},{"location":"reference/commands/#niobot.commands.event","title":"event","text":"<pre><code>event(name: str = None) -&gt; Callable\n</code></pre> <p>Allows you to register event listeners in modules.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the event (no <code>on_</code> prefix)</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code>"},{"location":"reference/context/","title":"Context","text":"<p>For each command invoked, the first argument is always a <code>Context</code> instance, which holds a lot of metadata, and a few utility functions to help you write commands.</p> <p>A lot of the time, these are the three main attributes you'll be using:</p> <ul> <li><code>Context.room</code> (<code>nio.MatrixRoom</code>) - the room the command was invoked in.</li> <li><code>Context.event</code> (<code>nio.RoomMessageText</code>) - the message that invoked this command.</li> <li><code>Context.respond</code> - a utility class to help you respond to the command.</li> </ul>"},{"location":"reference/context/#command-context","title":"Command Context","text":"<p>Event-based context for a command callback</p>"},{"location":"reference/context/#niobot.context.Context.room","title":"room  <code>property</code>","text":"<pre><code>room: MatrixRoom\n</code></pre> <p>The room that the event was dispatched in</p>"},{"location":"reference/context/#niobot.context.Context.client","title":"client  <code>property</code>","text":"<pre><code>client: NioBot\n</code></pre> <p>The current instance of the client</p>"},{"location":"reference/context/#niobot.context.Context.command","title":"command  <code>property</code>","text":"<pre><code>command: Command\n</code></pre> <p>The current command being invoked</p>"},{"location":"reference/context/#niobot.context.Context.args","title":"args  <code>property</code>","text":"<pre><code>args: list[str]\n</code></pre> <p>Each argument given to this command</p>"},{"location":"reference/context/#niobot.context.Context.message","title":"message  <code>property</code>","text":"<pre><code>message: RoomMessageText\n</code></pre> <p>The current message</p>"},{"location":"reference/context/#niobot.context.Context.original_response","title":"original_response  <code>property</code>","text":"<pre><code>original_response: Optional[RoomSendResponse]\n</code></pre> <p>The result of Context.reply(), if it exists.</p>"},{"location":"reference/context/#niobot.context.Context.latency","title":"latency  <code>property</code>","text":"<pre><code>latency: float\n</code></pre> <p>Returns the current event's latency in milliseconds.</p>"},{"location":"reference/context/#niobot.context.Context.respond","title":"respond  <code>async</code>","text":"<pre><code>respond(\n    content: Optional[str] = None,\n    file: Optional[BaseAttachment] = None,\n) -&gt; ContextualResponse\n</code></pre> <p>Responds to the current event.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>Optional[str]</code> <p>The text to reply with</p> <code>None</code> <code>file</code> <code>Optional[BaseAttachment]</code> <p>A file to reply with</p> <code>None</code> <p>Returns:</p> Type Description <code>ContextualResponse</code>"},{"location":"reference/context/#contextual-response","title":"Contextual Response","text":"<p>Context class for managing replies.</p> <p>Usage of this function is not required, however it is a useful utility.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.message","title":"message  <code>property</code>","text":"<pre><code>message: Optional[RoomMessageText]\n</code></pre> <p>Fetches the current message for this response</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.reply","title":"reply  <code>async</code>","text":"<pre><code>reply(*args) -&gt; ContextualResponse\n</code></pre> <p>Replies to the current response.</p> <p>This does NOT reply to the original invoking message.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>args to pass to send_message</p> <code>()</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>a new ContextualResponse object.</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.edit","title":"edit  <code>async</code>","text":"<pre><code>edit(content: str, **kwargs) -&gt; ContextualResponse\n</code></pre> <p>Edits the current response.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The new content to edit with</p> required <code>kwargs</code> <p>Any extra arguments to pass to Client.edit_message</p> <code>{}</code> <p>Returns:</p> Type Description <code>ContextualResponse</code> <p>self</p>"},{"location":"reference/context/#niobot.context.ContextualResponse.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(reason: Optional[str] = None) -&gt; None\n</code></pre> <p>Redacts the current response.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Optional[str]</code> <p>An optional reason for the redaction</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None, as there will be no more response.</p>"},{"location":"reference/events/","title":"Event Reference","text":""},{"location":"reference/events/#a-little-note-about-event-names","title":"A little note about event names","text":"<p>Event names are never prefixed with <code>on_</code>, so make sure you're listening to events like <code>message</code>, not <code>on_message</code>!</p> <p>While trying to listen for an <code>on_</code> prefixed event will still work, it will throw warnings in the console, and may be deprecated in the future.</p>"},{"location":"reference/events/#niobot-specific-events","title":"NioBot-specific events","text":"<p>There are two types of events in niobot: those that are dispatched by niobot itself, and those that're dispatched by <code>matrix-nio</code>. In order to keep backwards compatability, as well as high flexibility and extensibility, niobot's NioBot class actually subclasses nio.AsyncClient. This means that anything you can do with <code>matrix-nio</code>, you can do with niobot.</p> <p>However, for simplicity, niobot dispatches its own events independently of <code>matrix-nio</code>. These events are listed below.</p> <p>You can listen to these events with niobot.NioBot.on_event.</p> Example <pre><code>import niobot\n\nbot = niobot.NioBot(...)\n\n\n@bot.on_event(\"ready\")\nasync def on_ready(result):\n    print(\"Bot is ready!\")\n    print(\"Logged in as:\", bot.user_id)\n\n\nbot.run(...)\n</code></pre>"},{"location":"reference/events/#niobot._event_stubs.event_loop_running","title":"event_loop_running  <code>async</code>","text":"<pre><code>event_loop_running() -&gt; Optional[Any]\n</code></pre> <p>An event that is fired once the event loop is running.</p> <p>You should use this event to perform any startup tasks.</p> <p>This event is fired before the bot logs in, and before the first <code>sync()</code> is performed.</p> <p>This means that if, for example, you wanted to initialise a database, or make some HTTP request in a module, You can @[nio]bot.event(\"event_loop_running\") do it here.</p> Initialising a database in a module <pre><code>import niobot\nimport aiosqlite\n\nclass MyModule(niobot.Module):\n    def __init__(self, bot):\n        super().__init__(bot)\n        self.db = None\n\n    @niobot.event(\"event_loop_running\")\n    async def event_loop_running(self):\n        self.db = await aiosqlite.connect(\"mydb.db\")\n        await self.db.execute(...)\n        await self.db.commit\n</code></pre>"},{"location":"reference/events/#niobot._event_stubs.ready","title":"ready  <code>async</code>","text":"<pre><code>ready(result: SyncResponse) -&gt; Optional[Any]\n</code></pre> <p>An event that is fired when the bot's first <code>sync()</code> is completed.</p> <p>This indicates that the bot successfully logged in, synchronised with the server, and is ready to receive events.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>SyncResponse</code> <p>The response from the sync.</p> required"},{"location":"reference/events/#niobot._event_stubs.message","title":"message  <code>async</code>","text":"<pre><code>message(\n    room: MatrixRoom, event: RoomMessageText\n) -&gt; Optional[Any]\n</code></pre> <p>An event that is fired when the bot receives a message in a room that it is in.</p> <p>This event is dispatched before commands are processed, and as such the convenient niobot.Context is unavailable.</p> <p>Tip</p> <p>If you want to be able to use the niobot.Context in your event handlers, you should use the <code>command</code> event instead.</p> <p>Furthermore, if you want more fine-grained control over how commands are parsed and handled, you should override niobot.NioBot.process_message instead of using the <code>message</code> event.</p> <p>Parameters:</p> Name Type Description Default <code>room</code> <code>MatrixRoom</code> <p>The room that the message was received in.</p> required <code>event</code> <code>RoomMessageText</code> <p>The raw event that triggered the message.</p> required"},{"location":"reference/events/#niobot._event_stubs.command","title":"command  <code>async</code>","text":"<pre><code>command(ctx: Context) -&gt; Optional[Any]\n</code></pre> <p>This event is dispatched once a command is finished being prepared, and is about to be invoked.</p> <p>This event is dispatched after the <code>message</code> event, but before <code>command_complete</code> and <code>command_error</code>.</p> <p>This event features the original context, which can be used to access the message, the command, and the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context of the command.</p> required"},{"location":"reference/events/#niobot._event_stubs.command_complete","title":"command_complete  <code>async</code>","text":"<pre><code>command_complete(\n    ctx: Context, result: Any\n) -&gt; Optional[Any]\n</code></pre> <p>This event is dispatched after a command has been invoked, and has completed successfully.</p> <p>This event features the context, which can be used to access the message, the command, and the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context of the command.</p> required <code>result</code> <code>Any</code> <p>The result of the command (the returned value of the callback)</p> required"},{"location":"reference/events/#niobot._event_stubs.command_error","title":"command_error  <code>async</code>","text":"<pre><code>command_error(\n    ctx: Context, error: CommandError\n) -&gt; Optional[Any]\n</code></pre> <p>This event is dispatched after a command has been invoked, and has completed with an error.</p> <p>This event features the context, which can be used to access the message, the command, and the arguments.</p> Getting the original error <p>As the error is wrapped in a niobot.CommandError, you can access the original error by accessing the <code>CommandError.original</code> attribute.</p> <pre><code>@bot.event(\"command_error\")\nasync def on_command_error(ctx, error):\n    original_error = error.original\n    print(\"Error:\", original_error)\n</code></pre> <p>It is encouraged that you inform the end user about an error that has occurred, as by default the error is simply logged to the console. Don't forget, you've got the whole <code>Context</code> instance - use it!</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context of the command.</p> required <code>error</code> <code>CommandError</code> <p>The error that was raised.</p> required"},{"location":"reference/events/#matrix-nio-events","title":"<code>matrix-nio</code> events","text":"<p>See the <code>matrix-nio</code> documentation for the base-library set of events.</p> <p>Remember, you'll need to use nio.Client.add_event_callback in order to listen to these!</p>"},{"location":"reference/exceptions/","title":"Exceptions","text":""},{"location":"reference/exceptions/#niobot.exceptions.NioBotException","title":"NioBotException","text":"<p>             Bases: <code>Exception</code></p> <p>Base exception for NioBot.</p> <p>Warning</p> <p>In some rare cases, all of <code>exception</code>, <code>response</code> and <code>original</code> may be None.</p> <p>All other exceptions raised by this library will subclass this exception, so at least all the below are always available:</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>Optional[str]</code> <p>A simple humanised explanation of the issue, if available.</p> <code>response</code> <code>Optional[ErrorResponse]</code> <p>The response object from the server, if available.</p> <code>exception</code> <code>Optional[Union[ErrorResponse, BaseException]]</code> <p>The exception that was raised, if available.</p> <code>original</code> <code>Union[ErrorResponse, BaseException, None]</code> <p>The original response, or exception if response was not available.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.bottom_of_chain","title":"bottom_of_chain","text":"<pre><code>bottom_of_chain(\n    other: Optional[Union[Exception, ErrorResponse]] = None\n) -&gt; Union[BaseException, ErrorResponse]\n</code></pre> <p>Recursively checks the <code>original</code> attribute of the exception until it reaches the bottom of the chain.</p> <p>This function finds you the absolute first exception that was raised.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Optional[Union[Exception, ErrorResponse]]</code> <p>The other exception to recurse down. If None, defaults to the exception this method is called on.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[BaseException, ErrorResponse]</code> <p>The bottom of the chain exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Returns a human-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NioBotException.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Returns a developer-readable version of the exception.</p>"},{"location":"reference/exceptions/#niobot.exceptions.GenericMatrixError","title":"GenericMatrixError","text":"<p>             Bases: <code>NioBotException</code></p> <p>Exception for generic matrix errors where a valid response was expected, but got an ErrorResponse instead.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MessageException","title":"MessageException","text":"<p>             Bases: <code>NioBotException</code></p> <p>Exception for message-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.LoginException","title":"LoginException","text":"<p>             Bases: <code>NioBotException</code></p> <p>Exception for login-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaException","title":"MediaException","text":"<p>             Bases: <code>MessageException</code></p> <p>Exception for media-related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaUploadException","title":"MediaUploadException","text":"<p>             Bases: <code>MediaException</code></p> <p>Exception for media-uploading related errors</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaDownloadException","title":"MediaDownloadException","text":"<p>             Bases: <code>MediaException</code></p> <p>Exception for media-downloading related errors</p>"},{"location":"reference/exceptions/#niobot.exceptions.MediaCodecWarning","title":"MediaCodecWarning","text":"<p>             Bases: <code>ResourceWarning</code></p> <p>Warning that is dispatched when a media file is not in a supported codec.</p> <p>You can filter this warning by using <code>warnings.filterwarnings(\"ignore\", category=niobot.MediaCodecWarning)</code></p> <p>Often times, matrix clients are web-based, so they're limited to what the browser can display. This is usually:</p> <ul> <li>h264/vp8/vp9/av1/theora video</li> <li>aac/opus/vorbis/mp3/pcm_* audio</li> <li>jpg/png/webp/avif/gif images</li> </ul>"},{"location":"reference/exceptions/#niobot.exceptions.MetadataDetectionException","title":"MetadataDetectionException","text":"<p>             Bases: <code>MediaException</code></p> <p>Exception raised when metadata detection fails. Most of the time, this is an ffmpeg-related error</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandError","title":"CommandError","text":"<p>             Bases: <code>NioBotException</code></p> <p>Exception subclass for all command invocation related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandNotFoundError","title":"CommandNotFoundError","text":"<p>             Bases: <code>CommandError</code></p> <p>Exception raised when a command is not found.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandPreparationError","title":"CommandPreparationError","text":"<p>             Bases: <code>CommandError</code></p> <p>Exception subclass for errors raised while preparing a command for execution.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandDisabledError","title":"CommandDisabledError","text":"<p>             Bases: <code>CommandPreparationError</code></p> <p>Exception raised when a command is disabled.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandArgumentsError","title":"CommandArgumentsError","text":"<p>             Bases: <code>CommandPreparationError</code></p> <p>Exception subclass for command argument related errors.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CommandParserError","title":"CommandParserError","text":"<p>             Bases: <code>CommandArgumentsError</code></p> <p>Exception raised when there is an error parsing arguments.</p>"},{"location":"reference/exceptions/#niobot.exceptions.CheckFailure","title":"CheckFailure","text":"<p>             Bases: <code>CommandPreparationError</code></p> <p>Exception raised when a generic check call fails.</p> <p>You should prefer one of the subclass errors over this generic one, or a custom subclass.</p> <p><code>CheckFailure</code> is often raised by the built-in checker when a check returns a falsy value without raising an error.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NotOwner","title":"NotOwner","text":"<p>             Bases: <code>CheckFailure</code></p> <p>Exception raised when the command invoker is not the owner of the bot.</p>"},{"location":"reference/exceptions/#niobot.exceptions.InsufficientPower","title":"InsufficientPower","text":"<p>             Bases: <code>CheckFailure</code></p> <p>Exception raised when the command invoker does not have enough power to run the command.</p>"},{"location":"reference/exceptions/#niobot.exceptions.NotADirectRoom","title":"NotADirectRoom","text":"<p>             Bases: <code>CheckFailure</code></p> <p>Exception raised when the current room is not <code>m.direct</code> (a DM room)</p>"},{"location":"reference/utils/federation/","title":"Federation","text":"<p>There isn't a lot here aside from a homeserver resolver. A lot of the federation is already handled by matrix-nio itself, so there isn't a lot of need for federation-specific utilities.</p>"},{"location":"reference/utils/federation/#niobot.utils.federation.resolve_homeserver","title":"resolve_homeserver  <code>async</code>","text":"<pre><code>resolve_homeserver(domain: str) -&gt; str\n</code></pre> <p>Resolves a given homeserver part to the actual homeserver</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain to crawl</p> required <p>Returns:</p> Type Description <code>str</code> <p>The resolved homeserver</p>"},{"location":"reference/utils/help_command/","title":"The help command","text":"<p><code>NioBot</code> comes with a built-in help command, which can be used to display information about other commands.</p> <p>This built-in command is simple, slick, and most importantly, helpful. It takes one optional argument, <code>command</code>, which changes the output to display information about a specific command. Without this, the help command will list every enabled command, their aliases, a short help string, and a short description about the command (by default, the first line of the docstring).</p> <p>This allows for you to easily just add commands and not have to worry about documenting them outside of simply defining their usage in the command decorator, and a short description in the docstring.</p> An example of the help command with no arguments Source of this sample <p>This is the output of the help command from  nexy7574/niobot-test</p> <pre><code>?[help|h]: Shows a list of commands for this bot\n?[ytdl|yt|dl|yl-dl|yt-dlp] &lt;url&gt; [format]: Downloads a video from YouTube\n?[quote|q]: Generate a random quote.\n?ping: Shows the roundtrip latency\n?info: Shows information about the bot\n?cud: Creates, updates, and deletes a message\n?upload &lt;type: image|video|audio|file&gt;: Uploads an image\n?hello: Asks for an input\n?version: Shows the version of nio\n?[pretty-print|pp]: Pretty prints given JSON\n?eval: Evaluates Python code\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p> An example of the help command with a specified command name Source of this sample <p>This is the output of the help command from  nexy7574/niobot-test</p> <pre><code>?[help|h]:\nShows a list of commands for this bot\n</code></pre> Info <p>There is markdown formatting in the output, but it is not shown here.</p>"},{"location":"reference/utils/help_command/#registering-your-own-help-command","title":"Registering your own help command","text":"<p>If you would like to register your own help command, you need to be aware of the following:</p> <ul> <li>The help command is a command, much like any other command, and is registered as such. You should be aware of  aliases, case sensitivity, command states (e.g. disabled/enabled), etc.</li> <li>A help command is almost always a user's first impression of your bot. You should make sure that it works 100% of the time, is insanely simple to use, and is very helpful. A help command that just says \"You can use command like ?info\" is not helpful at all, and will likely turn many users away.</li> </ul> <p>???+ question Are there any dangers to these help commands?</p>"},{"location":"reference/utils/help_command/#help-command-functions","title":"Help Command functions:","text":""},{"location":"reference/utils/help_command/#niobot.utils.help_command.clean_output","title":"clean_output","text":"<pre><code>clean_output(\n    text: str,\n    *,\n    escape_user_mentions: bool = True,\n    escape_room_mentions: bool = True,\n    escape_room_references: bool = False,\n    escape_all_periods: bool = False,\n    escape_all_at_signs: bool = False,\n    escape_method: Optional[Callable[[str], str]] = None\n) -&gt; str\n</code></pre> <p>Escapes given text and sanitises it, ready for outputting to the user.</p> <p>This should always be used when echoing any sort of user-provided content, as we all know there will be some annoying troll who will just go <code>@room</code> for no apparent reason every 30 seconds.</p> <p>Do not rely on this!</p> <p>This function is not guaranteed to escape all possible mentions, and should not be relied upon to do so. It is only meant to be used as a convenience function for simple commands.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text to sanitise</p> required <code>escape_user_mentions</code> <code>bool</code> <p>Escape all @user:homeserver.tld mentions</p> <code>True</code> <code>escape_room_mentions</code> <code>bool</code> <p>Escape all @room mentions</p> <code>True</code> <code>escape_room_references</code> <code>bool</code> <p>Escape all #room:homeserver.tld references</p> <code>False</code> <code>escape_all_periods</code> <code>bool</code> <p>Escape all literal <code>.</code> characters (can be used to escape all links)</p> <code>False</code> <code>escape_all_at_signs</code> <code>bool</code> <p>Escape all literal <code>@</code> characters (can be used to escape all mentions)</p> <code>False</code> <code>escape_method</code> <code>Optional[Callable[[str], str]]</code> <p>A custom escape method to use instead of the built-in one (which just wraps characters in <code>\\u200b</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The cleaned text</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.format_command_name","title":"format_command_name","text":"<pre><code>format_command_name(command: Command) -&gt; str\n</code></pre> <p>Formats the command name with its aliases if applicable</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.format_command_line","title":"format_command_line","text":"<pre><code>format_command_line(prefix: str, command: Command) -&gt; str\n</code></pre> <p>Formats a command line, including name(s) &amp; usage.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.get_short_description","title":"get_short_description","text":"<pre><code>get_short_description(command: Command) -&gt; str\n</code></pre> <p>Generates a short (&lt;100 characters) help description for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.get_long_description","title":"get_long_description","text":"<pre><code>get_long_description(command: Command) -&gt; str\n</code></pre> <p>Gets the full help text for a command.</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.default_help_command","title":"default_help_command  <code>async</code>","text":"<pre><code>default_help_command(ctx: Context)\n</code></pre> <p>Displays help text</p>"},{"location":"reference/utils/help_command/#niobot.utils.help_command.help_command_callback","title":"help_command_callback","text":"<pre><code>help_command_callback(ctx: Context)\n</code></pre> <p>Default help command callback</p>"},{"location":"reference/utils/parsers/","title":"Parsers","text":"<p>These are a handful of built-in parsers that you can use with <code>niobot.Argument</code>.</p> How do I use these? <p>To use a parser, you simply pass <code>parser=&lt;function&gt;</code> when creating <code>Argument()</code>. For example:</p> <pre><code>from niobot import Argument, command, NioBot\nfrom niobot.utils.parsers import float_parser\n\nbot = NioBot(...)\n\n@bot.command(\n    name=\"sum\", \n    arguments=[\n        Argument(\"num1\", parser=float_parser),\n        Argument(\"num2\", parser=float_parser)\n    ]\n)\nasync def add_numbers(ctx: Context, num1: float, num2: float):\n    await ctx.respond(\"{!s} + {!s} = {!s}\".format(num1, num2, num1 + num2))\n\nbot.run(...)\n</code></pre> <p>While this is roughly equivalent to <code>Argument(\"num1\", type=float)</code>, it can be helpful in cases like  json_parser where you need to parse complex types.</p> <p>Tip</p> <p>You can also create your own parsers! See Creating Parsers for more information.</p> <p>This utility modules contains a handful of simple off-the-shelf parser for some basic python types.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.Parser","title":"Parser","text":"<p>             Bases: <code>ABC</code></p> <p>A base model class for parsers.</p> <p>This ABC defines one uniform method, which is <code>__call__</code>, which takes a Context instance, Argument instance, and the user-provided string value.</p> <p>This parser is designed to be instantiated, and then called with the above arguments. If you want to make a simple parser that does not take additional configuration, it is recommended to use StatelessParser instead.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.StatelessParser","title":"StatelessParser","text":"<p>             Bases: <code>Parser</code>, <code>ABC</code></p> <p>A parser base that will not be instantiated, but rather called directly.</p> <p>This is useful for parsers that do not take any configuration (such as the simple BooleanParser), where a simple one-off call is enough.</p> <p>Traditionally, you'd call a Parser like this:</p> <pre><code>parser = Parser(my_argument=True)\nresult = parser(ctx, arg, value)\n# or, in one line\nresult = Parser(my_argument=True)(ctx, arg, value)\n</code></pre> <p>However, for some simple parsers, there's no need to instantiate them. Instead, you can call them directly. The <code>StatelessParser</code> ABC adds the <code>parse</code> classmethod, meaning you can simply do the following:</p> <p><pre><code>result = Parser.parse(ctx, arg, value)\n</code></pre> Which is just a shortand for the above one-liner. This offers little to no performance benefit, however can make code look cleaner.</p> <p>As this ABC subclasses the regular Parser, you can still use the traditional instantiation+call method.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.StatelessParser.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(\n    ctx: Context, arg: Argument, value: str\n) -&gt; Optional[Any]\n</code></pre> <p>Parses the given value using this parser without needing to call __init__() first.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The context instance</p> required <code>arg</code> <code>Argument</code> <p>The argument instance</p> required <code>value</code> <code>str</code> <p>The value to parse</p> required <p>Returns:</p> Type Description <code>typing.Optional[typing.Any]</code> <p>The parsed value</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.BooleanParser","title":"BooleanParser","text":"<p>             Bases: <code>StatelessParser</code></p> <p>Converts a given string into a boolean. Value is casefolded before being parsed.</p> <p>The following resolves to true: * 1, y, yes, true, on</p> <p>The following resolves to false: * 0, n, no, false, off</p> <p>The following will raise a command argument error: anything else</p> <p>Returns:</p> Type Description <code>bool</code> <p>A parsed boolean</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.FloatParser","title":"FloatParser","text":"<p>             Bases: <code>StatelessParser</code></p> <p>Converts a given string into a floating point number.</p> <p>Returns:</p> Type Description <code>float</code> <p>A parsed floating point number</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.IntegerParser","title":"IntegerParser","text":"<p>             Bases: <code>Parser</code></p> <p>Parses an integer, or optionally a real number.</p> <p>Parameters:</p> Name Type Description Default <code>allow_floats</code> <code>bool</code> <p>Whether to simply defer non-explicit-integer values to the float parser. This results in the return type being float</p> <code>False</code> <code>base</code> <code>int</code> <p>The base to parse the integer in. Defaults to 10 (denary). 2 is Binary, and 16 is Hexadecimal.</p> <code>10</code> <p>Returns:</p> Type Description <code>Union[int, float]</code> <p>A parsed integer or float, depending on input &amp; allow_floats</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid number.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.JSONParser","title":"JSONParser","text":"<p>             Bases: <code>StatelessParser</code></p> <p>Converts a given string into a JSON object.</p> <p>Performance boost</p> <p>If you want this to be fast, you should install orjson. It is a drop-in replacement for the standard library. While the parser will still work without it, it may be slower, especially for larger payloads.</p> <p>Returns:</p> Type Description <code>Union[dict, list, str, int, float, None, bool]</code> <p>The parsed JSON object</p> <p>Raises:</p> Type Description <code>CommandParserError</code> <p>if the value is not a valid JSON object.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.RoomParser","title":"RoomParser","text":"<p>             Bases: <code>StatelessParser</code></p> <p>Parses a room ID, alias, or matrix.to link into a MatrixRoom object.</p> This parser is async <p>This parser is async, and should be awaited when used manually.</p> <p>Returns:</p> Type Description <code>nio.MatrixRoom</code> <p>The parsed room instance</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.EventParser","title":"EventParser","text":"<p>             Bases: <code>Parser</code></p> <p>Parses an event reference from either its ID, or matrix.to link.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>Optional[str]</code> <p>The event type to expect (such as m.room.message). If None, any event type is allowed.</p> <code>None</code> <p>Returns:</p> Type Description <code>typing.Coroutine</code> <p>The actual internal (async) parser.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.MatrixDotToParser","title":"MatrixDotToParser","text":"<p>             Bases: <code>Parser</code></p> <p>Converts a matrix.to link into a MatrixRoomLink namedtuple, which consists of the room, event, and any query passed to the URL.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The domain to check for. Defaults to matrix.to, consistent with average client behaviour.</p> <code>'matrix.to'</code> <code>require_room</code> <code>bool</code> <p>Whether to require the room part of this url to be present</p> <code>True</code> <code>require_event</code> <code>bool</code> <p>Whether to require the event part of this url to be present</p> <code>False</code> <code>allow_user_as_room</code> <code>bool</code> <p>Whether to allow user links as room links</p> <code>True</code> <code>stateless</code> <code>bool</code> <p>If true, the link will only be parsed, not resolved. This means rooms will stay as their IDs, etc.</p> <code>False</code> <p>Returns:</p> Type Description <code>typing.Coroutine</code> <p>The actual internal (async) parser.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.MXCParser","title":"MXCParser","text":"<p>             Bases: <code>StatelessParser</code></p> <p>Parses an MXC URL into a MatrixMXCUrl namedtuple, which consists of the server and media ID.</p> <p>Returns:</p> Type Description <code>MatrixMXCUrl (namedtuple)</code> <p>The parsed MXC URL</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.MatrixUserParser","title":"MatrixUserParser","text":"<p>             Bases: <code>StatelessParser</code></p> <p>Parses a string into a MatrixUser instance from matrix-nio.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.boolean_parser","title":"boolean_parser","text":"<pre><code>boolean_parser(*args, **kwargs)\n</code></pre> <p>Deprecated boolean parser. Please use niobot.utils.parsers.BooleanParser instead.</p> <p>Deprecated function</p> <p>This function is deprecated and will be removed in 1.2.0.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.float_parser","title":"float_parser","text":"<pre><code>float_parser(*args, **kwargs)\n</code></pre> <p>Deprecated float parser. Please use niobot.utils.parsers.FloatParser instead.</p> <p>Deprecated function</p> <p>This function is deprecated and will be removed in 1.2.0.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.integer_parser","title":"integer_parser","text":"<pre><code>integer_parser(allow_floats: bool = False, base: int = 10)\n</code></pre> <p>Deprecated integer parser. Please use niobot.utils.parsers.IntegerParser instead.</p> <p>Deprecated function</p> <p>This function is deprecated and will be removed in 1.2.0.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.json_parser","title":"json_parser","text":"<pre><code>json_parser(*args, **kwargs)\n</code></pre> <p>Deprecated integer parser. Please use niobot.utils.parsers.JSONParser instead.</p> <p>Deprecated function</p> <p>This function is deprecated and will be removed in 1.2.0.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.room_parser","title":"room_parser","text":"<pre><code>room_parser(*args, **kwargs)\n</code></pre> <p>Deprecated room parser. Please use niobot.utils.parsers.RoomParser instead.</p> <p>Deprecated function</p> <p>This function is deprecated and will be removed in 1.2.0.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.event_parser","title":"event_parser","text":"<pre><code>event_parser(event_type: Optional[str] = None)\n</code></pre> <p>Deprecated event parser. Please use niobot.utils.parsers.EventParser instead.</p> <p>Deprecated function</p> <p>This function is deprecated and will be removed in 1.2.0.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.matrix_to_parser","title":"matrix_to_parser","text":"<pre><code>matrix_to_parser(\n    require_room: bool = True,\n    require_event: bool = False,\n    allow_user_as_room: bool = True,\n)\n</code></pre> <p>Deprecated matrix.to parser. Please use niobot.utils.parsers.MatrixDotToParser instead.</p> <p>Deprecated function</p> <p>This function is deprecated and will be removed in 1.2.0.</p>"},{"location":"reference/utils/parsers/#niobot.utils.parsers.mxc_parser","title":"mxc_parser","text":"<pre><code>mxc_parser(*args, **kwargs)\n</code></pre> <p>Deprecated MXC parser. Please use niobot.utils.parsers.MXCParser instead.</p> <p>Deprecated function</p> <p>This function is deprecated and will be removed in 1.2.0.</p>"},{"location":"reference/utils/parsers/#creating-parsers","title":"Creating Parsers","text":"The old way (pre-1.1.0) <p>Creating your own parser is actually really easy. All the library needs from you is a function that:</p> <ul> <li>Takes <code>niobot.Context</code> as its first argument</li> <li>Takes <code>niobot.Argument</code> as its second argument</li> <li>Takes a <code>str</code>ing (the user's input) as its third argument</li> <li>Returns a sensible value</li> <li>Or, raises CommandArgumentsError with a helpful error message.</li> </ul> <p>Do all of this, and you can very easily just pass this to <code>Argument</code>!</p> <p>For example, if you wanted to take a <code>datetime</code>, you could write your own parser like this:</p> <pre><code>from datetime import datetime\nfrom niobot import Argument, command, NioBot\n\n\ndef datetime_parser(ctx: Context, arg: Argument, user_input: str):\n    try:\n        return datetime.strptime(user_input, \"%Y-%m-%d %H:%M:%S\")\n    except ValueError:\n        raise CommandArgumentsError(\"Invalid datetime format. Expected YYYY-MM-DD HH:MM:SS\")\n\nbot = NioBot(...)\n\n\n@bot.command(name=\"remindme\", arguments=[Argument(\"time\", arg_type=datetime, parser=datetime_parser)])\nasync def remind_me(ctx: Context, time: datetime):\n    await ctx.respond(\"I'll remind you at {}!\".format(time.strftime(\"%c\")))\n\nbot.run(...)\n</code></pre> <p>Creating custom parsers for nio-bot is really simple. All you need to do is subclass either  Parser or StatelessParser and implement the <code>parse</code> method.</p> <p>However, if you want some detailed information, seek the guide</p>"},{"location":"reference/utils/string_view/","title":"String View","text":"<p>This is mostly an internal utility.</p> <p>The ArgumentView is mostly used by the internal command parser to parse arguments. While you will be able to use this yourself, its very unlikely that you'll ever actually need it.</p> <p>This is a work in progress.</p> <p>The string view does a lot of complicated maths and logic to determine arguments. It's not as simple as just splitting the string on every whitespace and calling it an argument, the ArgumentView parser has to check for quotes, escape characters, and more.</p> <p>Due to the complexity of the parser, it's very likely that there are still bugs in the parser. Fixes welcome!</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView","title":"ArgumentView","text":"<p>A parser designed to allow for multi-word arguments and quotes</p> <p>For example, the arguments <code>1 \"2 3\" 4</code> would result in three items in the internal list: <code>1</code>, <code>2 3</code>, and <code>4</code></p> <p>This is most useful when parsing arguments from a command, as it allows for multi-word arguments.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to parse</p> required"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.eof","title":"eof  <code>property</code>","text":"<pre><code>eof: bool\n</code></pre> <p>Returns whether the parser has reached the end of the string</p> <p>Returns:</p> Type Description <p>Whether the parser has reached the end of the string (cursor is greater than or equal to the length of the string)</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.add_arg","title":"add_arg","text":"<pre><code>add_arg(argument: str) -&gt; None\n</code></pre> <p>Adds an argument to the argument list</p> <p>Parameters:</p> Name Type Description Default <code>argument</code> <code>str</code> <p>The argument to add</p> required <p>Returns:</p> Type Description <code>None</code> <p>none</p>"},{"location":"reference/utils/string_view/#niobot.utils.string_view.ArgumentView.parse_arguments","title":"parse_arguments","text":"<pre><code>parse_arguments() -&gt; ArgumentView\n</code></pre> <p>Main parsing engine.</p> <p>Returns:</p> Type Description <code>ArgumentView</code> <p>self</p>"},{"location":"reference/utils/typing/","title":"Typing helper","text":"<p>This utility module contains one tool: the <code>Typing</code> class. It is internally used in the <code>&lt;send/edit/delete&gt;_message</code> functions of <code>NioBot</code>, but you can use it at any point to send typing events to the chat.</p>"},{"location":"reference/utils/typing/#usage","title":"Usage","text":"<p>Context manager to manage typing notifications.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>NioBot</code> <p>The <code>NioBot</code> instance</p> required <code>room_id</code> <code>str</code> <p>The room id to send the typing notification to</p> required <code>timeout</code> <code>int</code> <p>The timeout in seconds</p> <code>30</code> <code>persistent</code> <code>bool</code> <p>Whether to send a typing notification every <code>timeout</code> seconds, to keep the typing status active</p> <code>True</code> <p>Warning</p> <p>Nesting <code>Typing</code> instances for one specific room is a bad idea, as when each instance is exited, it stops typing for the given room. For example, the below will not work as expected:</p> <pre><code>from niobot import NioBot, utils\n\nbot = NioBot(...)\n\n@bot.command()\nasync def ping(ctx):\n    async with utils.Typing(ctx.client, ctx.room.room_id):\n        await ctx.respond(\"Pong!\")\n\nbot.run(...)\n</code></pre> <p>This will not work because <code>Context.respond</code> calls <code>NioBot.send_message</code>, and <code>NioBot.send_message</code> creates its own <code>Typing</code> instance. Once <code>ctx.respond</code> returns, the internal <code>Typing</code> instance is destroyed, and the typing event is stopped, as is the behaviour of exiting the context manager. This means that either if on the loop, the upper-most <code>utils.Typing</code> instance will simply just create a new typing notification, or will not (especially if <code>persistent</code> was set to <code>False</code>). This breaks the whole persistence of typing.</p> If you want to use <code>Typing</code> to show that you're processing something: <p>If you want to use <code>Typing</code> to show a user that your bot is \"thinking\", or similar, you should make sure you exit the instance before responding. For example:</p> <pre><code>from niobot import NioBot, Typing\nimport httpx\n\nbot = NioBot(...)\n\n@bot.command()\nasync def process(ctx):\n    \"\"\"Spends a worryingly long time making a network request.\"\"\"\n    async with Typing(ctx.client, ctx.room.room_id):\n        await httpx.get(\"https://example.com\")\n    await ctx.respond(\"Done!\")\n</code></pre> <p>Be aware that this will cause a momentary blip in the <code>xyz is typing</code> status, but this is unavoidable, simply due to the semi-stateless nature of this context wrapper</p> <p>A potential future solution would be to implement some funky internal lock mechanism and/or just prevent nested <code>Typing</code> instances, but this is not a priority at the moment.</p>"},{"location":"reference/utils/typing/#niobot.utils.Typing.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__()\n</code></pre> <p>Starts the typing notification loop, or sends a single typing notification if not persistent.</p>"},{"location":"reference/utils/typing/#niobot.utils.Typing.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(exc_type, exc, tb)\n</code></pre> <p>Cancels any existing typing loop under this instance and sends a typing notification to stop typing.</p>"},{"location":"reference/utils/unblock/","title":"Unblock","text":"<p>A common problem developers encounter when working with an asyncio event loop is long blocking code. This can be caused by a number of things, but the most common is a call to a library that is not async-aware, and has many blocking operations (such as <code>requests</code>, or even the built-in <code>open()</code> + <code>read()</code> functions).</p> <p>To alleviate this, NioBot provides an \"unblock\" utility, which is a simple async function that will run any blocking code in the event loop executor, and returns the result, without pausing the event loop. This is equivalent to <code>loop.run_in_executor(None, func, *args, **kwargs)</code>.</p> A good example <p><pre><code>from niobot import NioBot, command\nfrom niobot.utils import run_blocking\n\nbot = NioBot(...)\n\n\n@bot.command(name=\"read\")\nasync def read_file(ctx: Context, filename: str):\n    with open(filename, \"r\") as f:\n        contents = await run_blocking(f.read)\n    await ctx.respond(contents)\n\nbot.run(...)\n</code></pre> This will read the contents of a file, without blocking the event loop, unlike the following code:</p> A bad example <p><pre><code>    from niobot import NioBot, command\n    from niobot.utils import run_blocking\n\n    bot = NioBot(...)\n\n\n    @bot.command(name=\"read\")\n    async def read_file(ctx: Context, filename: str):\n        with open(filename, \"r\") as f:\n            contents = f.read()\n        await ctx.respond(contents)\n\n    bot.run(...)\n</code></pre> This example is bad because it will prevent any other event processing until <code>f.read()</code> finishes, which is really bad if the file is large, or the disk is slow. For example, if you read at 1mb/s, and you have a 10 megabyte file, you will block the event loop for approximately 10 seconds, which means your program cannot do anything in those ten seconds, and as such your bot will appear to be non-functional!</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.run_blocking","title":"run_blocking  <code>async</code>","text":"<pre><code>run_blocking(\n    function: Callable[..., T], *args: Any, **kwargs: Any\n) -&gt; T\n</code></pre> <p>Takes a blocking function and runs it in a thread, returning the result.</p> <p>You should use this for any long-running functions that may take a long time to respond that are not coroutines that you can await. For example, running a subprocess.</p> Example <pre><code>import asyncio\nimport subprocess\nfrom niobot.utils import run_blocking\n\nasync def main():\n    result = await run_blocking(subprocess.run, [\"find\", \"*.py\", \"-type\", \"f\"], capture_output=True)\n    print(result)\n\nasyncio.run(main())\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[..., T]</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T</code> <p>The result of the function.</p>"},{"location":"reference/utils/unblock/#niobot.utils.unblocking.force_await","title":"force_await  <code>async</code>","text":"<pre><code>force_await(\n    function: Union[Callable, Coroutine],\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>Takes a function, and if it needs awaiting, it will be awaited. If it is a synchronous function, it runs it in the event loop, preventing it from blocking.</p> <p>This is equivalent to (pseudo): <pre><code>if can_await(x):\n    await x\nelse:\n    await run_blocking(x)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Union[Callable, Coroutine]</code> <p>The function to call. Make sure you do not call it, just pass it.</p> required <code>args</code> <code>Any</code> <p>The arguments to pass to the function.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>The keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <p>The result of the function.</p>"}]}